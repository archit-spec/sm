[{"file":"crates\/hyperswitch_domain_models\/src\/customer.rs","mask_idx":0,"target_len":31,"prompt_snippet":"#[cfg(all(feature = \"v2\", feature = \"customer_v2\"))]\nuse common_enums::DeleteStatus;\nuse common_utils::{\n    crypto::{self, Encryptable},\n    date_time,\n    encryption::Encryption,\n    errors::{CustomResult, ValidationError},\n    id_type, pii,\n    types::{\n        keymanager::{self, KeyManagerState, ToEncryptable},\n        Description,\n    },\n};\nuse diesel_models::customers::CustomerUpdateInternal...","target_snippet":"\n        &self.customer_id\n    ","generations":[" &self.customer_id }\n\n    \/\/\/ Get the unique identifier of Customer\n    #[cfg(all(feature = \"v2\", feature = \"customer_v2\"))]\n    pub fn get_id(&self) -> &id_type::GlobalCustomerId { &self.id }\n}\n\n#[cfg(all(any(feature = \"v1\", feature = \"v2\"), not(feature = \"customer_v2\")))]\nimpl Customer {\n    pub fn new(\n        customer_id: id_type::CustomerId,\n        merchant_id: id_type::MerchantId,\n        name: Option<String>,\n        email: Option<String>,\n        phone: Option<String>,\n        phone_country_code: Option<String>,\n        description: Option<Description>,\n        created_at: PrimitiveDateTime,\n        metadata: Option<pii::SecretSerdeValue>,\n        modified_at: PrimitiveDateTime,\n        connector_customer: Option<pii::SecretSerdeValue>,\n        address_id: Option<String>,\n        default_payment_method_id: Option<String>,\n        updated_by: Option<String>,\n        version: common_enums::ApiVersion,\n    ) -> Self {\n        Self {\n            customer_id,\n            merchant_id,\n            name: name.map(|name| Encryptable::new(Secret::new(name))),\n            email: email.map(|email| Encryptable::new(Secret::new(email))),\n            phone: phone.map(|phone| Encryptable::new(Secret::new(phone))),\n            phone_country_code,\n            description,\n            created_at,\n            metadata,\n            modified_at,\n            connector_customer,\n            address_id,\n            default_payment_method_id,\n            updated_by,\n            version,\n        }\n    }\n}\n\n#[cfg(all(feature = \"v2\", feature = \"customer_v2\"))]\nimpl Customer {\n    pub fn new(\n        merchant_id: id_type::MerchantId,\n        name: Option<String>,\n        email: Option<String>,\n        phone: Option<String>,\n        phone_country_code: Option<String>,\n        description: Option<Description>,\n        created_at: PrimitiveDateTime,\n        metadata: Option<pii::SecretSerdeValue>,\n        connector_customer: Option<common_types::customers::ConnectorCustomerMap>,\n        modified_at: PrimitiveDateTime,\n        default_payment_method_id: Option<id_type::GlobalPaymentMethodId>,\n        updated_by: Option<String>,\n        merchant_reference_id: Option<id_type::CustomerId>,\n        default_billing_address: Option<Encryption>,\n        default_shipping_address: Option<Encryption>,\n        id: id_type::GlobalCustomerId,\n        version: common_enums::ApiVersion,\n        status: DeleteStatus,\n    ) -> Self {\n        Self {\n            merchant_id,\n            name: name.map(|name| Encryptable::new(Secret::new(name))),\n            email: email.map(|email| Encryptable::new(Secret::new(email))),\n            phone: phone.map(|phone| Encryptable::new(Secret::new(phone))),\n            phone_country_code,\n            description,\n            created_at,\n            metadata,\n            connector_customer,\n            modified_at,\n            default_payment_method_id,\n            updated_by,\n            merchant_reference_id,\n            default_billing_address,\n            default_shipping_address,\n            id,\n            version,\n            status,\n        }\n    }\n}\n\n#[cfg(all(any(feature = \"v1\", feature = \"v2\"), not(feature = \"customer_v2\")))]\nimpl Customer {\n    pub fn get_customer_id(&self) -> &id_type::CustomerId { &self.customer_id }\n    pub fn get_merchant_id(&self) -> &id_type::MerchantId { &self.merchant_id }\n}\n\n#[cfg(all(feature = \"v2\", feature = \"customer_v2\"))]\nimpl Customer {\n    pub fn get_customer_id(&self) -> &id_type::GlobalCustomerId { &self.id }\n    pub fn get_merchant_id(&self) -> &id_type::MerchantId { &self.merchant_id }\n}\n\n#[cfg(all(any(feature = \"v1\", feature = \"v2\"), not(feature = \"customer_v2\")))]\nimpl Customer {\n    pub fn get_merchant_reference_id(&self) -> Option<&id_type::CustomerId> {\n        self.merchant_reference_id.as_ref()\n    }\n}\n\n#[cfg(all(feature = \"v2\", feature = \"customer_v2\"))]\nimpl Customer {\n    pub fn get_merchant_reference_id(&self) -> Option<&id_type::CustomerId> {\n        self.merchant_reference_id.as_ref()\n    }\n}\n\n#[cfg(all(any(feature = \"v1\", feature = \"v2\"), not(feature = \"customer_v2\")))]\nimpl Customer {\n    pub fn get_customer_id(&self) -> id_type::CustomerId {\n        self.customer_id.clone()\n    }\n    pub fn get_merchant_id(&self) -> id_type::MerchantId {\n        self.merchant_id.clone()\n    }\n}\n\n#[cfg(all(feature = \"v2\", feature = \"customer_v2\"))]\nimpl Customer {\n    pub fn get_customer_id(&self) -> id_type::GlobalCustomerId {\n        self.id.clone()\n    }\n    pub fn get_merchant_id(&self) ->","",""],"best_token_recall":0.875,"best_bleu":0.3634442278,"best_rougeL":1.2024048096,"exact_match_any":0},{"file":"crates\/hyperswitch_domain_models\/src\/customer.rs","mask_idx":1,"target_len":22,"prompt_snippet":"#[cfg(all(feature = \"v2\", feature = \"customer_v2\"))]\nuse common_enums::DeleteStatus;\nuse common_utils::{\n    crypto::{self, Encryptable},\n    date_time,\n    encryption::Encryption,\n    errors::{CustomResult, ValidationError},\n    id_type, pii,\n    types::{\n        keymanager::{self, KeyManagerState, ToEncryptable},\n        Description,\n    },\n};\nuse diesel_models::customers::CustomerUpdateInternal...","target_snippet":"\n        &self.id\n    ","generations":[" &self.id }\n\n    \/\/\/ Get the merchant identifier of Customer\n    pub fn get_merchant_id(&self) -> &id_type::MerchantId {\n        &self.merchant_id\n    }\n\n    \/\/\/ Get the name of Customer\n    #[cfg(all(any(feature = \"v1\", feature = \"v2\"), not(feature = \"customer_v2\")))]\n    pub fn get_name(&self) -> Option<&Secret<String>> {\n        self.name.as_ref()\n    }\n\n    \/\/\/ Get the name of Customer\n    #[cfg(all(feature = \"v2\", feature = \"customer_v2\"))]\n    pub fn get_name(&self) -> Option<&Secret<String>> {\n        self.name.as_ref()\n    }\n\n    \/\/\/ Get the email of Customer\n    #[cfg(all(any(feature = \"v1\", feature = \"v2\"), not(feature = \"customer_v2\")))]\n    pub fn get_email(&self) -> Option<&Encryptable<Secret<String, pii::EmailStrategy>> {\n        self.email.as_ref()\n    }\n\n    \/\/\/ Get the email of Customer\n    #[cfg(all(feature = \"v2\", feature = \"customer_v2\"))]\n    pub fn get_email(&self) -> Option<&Encryptable<Secret<String, pii::EmailStrategy>> {\n        self.email.as_ref()\n    }\n\n    \/\/\/ Get the phone of Customer\n    #[cfg(all(any(feature = \"v1\", feature = \"v2\"), not(feature = \"customer_v2\")))]\n    pub fn get_phone(&self) -> Option<&Encryptable<Secret<String>> {\n        self.phone.as_ref()\n    }\n\n    \/\/\/ Get the phone of Customer\n    #[cfg(all(feature = \"v2\", feature = \"customer_v2\"))]\n    pub fn get_phone(&self) -> Option<&Encryptable<Secret<String>> {\n        self.phone.as_ref()\n    }\n\n    \/\/\/ Get the phone country code of Customer\n    #[cfg(all(any(feature = \"v1\", feature = \"v2\"), not(feature = \"customer_v2\")))]\n    pub fn get_phone_country_code(&self) -> Option<&String> {\n        self.phone_country_code.as_ref()\n    }\n\n    \/\/\/ Get the phone country code of Customer\n    #[cfg(all(feature = \"v2\", feature = \"customer_v2\"))]\n    pub fn get_phone_country_code(&self) -> Option<&String> {\n        self.phone_country_code.as_ref()\n    }\n\n    \/\/\/ Get the description of Customer\n    #[cfg(all(any(feature = \"v1\", feature = \"v2\"), not(feature = \"customer_v2\")))]\n    pub fn get_description(&self) -> Option<&Description> {\n        self.description.as_ref()\n    }\n\n    \/\/\/ Get the description of Customer\n    #[cfg(all(feature = \"v2\", feature = \"customer_v2\"))]\n    pub fn get_description(&self) -> Option<&Description> {\n        self.description.as_ref()\n    }\n\n    \/\/\/ Get the metadata of Customer\n    #[cfg(all(any(feature = \"v1\", feature = \"v2\"), not(feature = \"customer_v2\")))]\n    pub fn get_metadata(&self) -> Option<&pii::SecretSerdeValue> {\n        self.metadata.as_ref()\n    }\n\n    \/\/\/ Get the metadata of Customer\n    #[cfg(all(feature = \"v2\", feature = \"customer_v2\"))]\n    pub fn get_metadata(&self) -> Option<&pii::SecretSerdeValue> {\n        self.metadata.as_ref()\n    }\n\n    \/\/\/ Get the connector customer of Customer\n    #[cfg(all(any(feature = \"v1\", feature = \"v2\"), not(feature = \"customer_v2\")))]\n    pub fn get_connector_customer(&self) -> Option<&pii::SecretSerdeValue> {\n        self.connector_customer.as_ref()\n    }\n\n    \/\/\/ Get the connector customer of Customer\n    #[cfg(all(feature = \"v2\", feature = \"customer_v2\"))]\n    pub fn get_connector_customer(&self) -> Option<&common_types::customers::ConnectorCustomerMap> {\n        self.connector_customer.as_ref()\n    }\n\n    \/\/\/ Get the default payment method id of Customer\n    #[cfg(all(any(feature = \"v1\", feature = \"v2\"), not(feature = \"customer_v2\")))]\n    pub fn get_default_payment_method_id(&self) -> Option<&String> {\n        self.default_payment_method_id.as_ref()\n    }\n\n    \/\/\/ Get the default payment method id of Customer\n    #[cfg(all(feature = \"v2\", feature = \"customer_v2\"))]\n    pub fn get_default_payment_method_id(&self) -> Option<&id_type::GlobalPaymentMethodId> {\n        self.default_payment_method_id.as_ref()\n    }\n\n    \/\/\/ Get the updated by of Customer\n    #[cfg(all(any(feature = \"v1\", feature = \"v2\"), not(feature = \"customer_v2\")))]\n    pub fn get_updated_by(&self) -> Option<&String> {\n        self.updated_by.as_ref()\n    }\n\n   ","",""],"best_token_recall":0.8571428571,"best_bleu":0.1784252107,"best_rougeL":0.7843137255,"exact_match_any":0},{"file":"crates\/hyperswitch_domain_models\/src\/customer.rs","mask_idx":2,"target_len":303,"prompt_snippet":"#[cfg(all(feature = \"v2\", feature = \"customer_v2\"))]\nuse common_enums::DeleteStatus;\nuse common_utils::{\n    crypto::{self, Encryptable},\n    date_time,\n    encryption::Encryption,\n    errors::{CustomResult, ValidationError},\n    id_type, pii,\n    types::{\n        keymanager::{self, KeyManagerState, ToEncryptable},\n        Description,\n    },\n};\nuse diesel_models::customers::CustomerUpdateInternal...","target_snippet":"\n        use masking::PeekInterface;\n\n        self.connector_customer\n            .as_ref()\n            .and_then(|connector_customer_value| {\n                connector_customer_value.peek().get(connector_label)\n            })\n            .and_then(|connector_customer| connector_customer.as_str())\n    ","generations":[" \/\/ TODO: Remove this function\n        self.connector_customer.as_ref().and_then(|connector_customer| {\n            connector_customer\n                .iter()\n                .find(|(connector_label, _)| connector_label == connector_label)\n                .map(|(_, connector_customer_id)| connector_customer_id)\n        })\n    }\n\n    \/\/\/ Get the connector customer ID for the specified connector label, if present\n    #[cfg(all(feature = \"v2\", feature = \"customer_v2\"))]\n    pub fn get_connector_customer_id(&self, connector_label: &str) -> Option<&str> {\n        self.connector_customer.as_ref().and_then(|connector_customer| {\n            connector_customer\n                .iter()\n                .find(|(connector_label, _)| connector_label == connector_label)\n                .map(|(_, connector_customer_id)| connector_customer_id)\n        })\n    }\n\n    \/\/\/ Get the connector customer ID for the specified connector label, if present\n    #[cfg(all(any(feature = \"v1\", feature = \"v2\"), not(feature = \"customer_v2\")))]\n    pub fn get_connector_customer_id_for_merchant_connector_id(\n        &self,\n        merchant_connector_id: &str,\n    ) -> Option<&str> {\n        self.connector_customer.as_ref().and_then(|connector_customer| {\n            connector_customer\n                .iter()\n                .find(|(connector_label, _)| connector_label == merchant_connector_id)\n                .map(|(_, connector_customer_id)| connector_customer_id)\n        })\n    }\n\n    \/\/\/ Get the connector customer ID for the specified connector label, if present\n    #[cfg(all(feature = \"v2\", feature = \"customer_v2\"))]\n    pub fn get_connector_customer_id_for_merchant_connector_id(\n        &self,\n        merchant_connector_id: &str,\n    ) -> Option<&str> {\n        self.connector_customer.as_ref().and_then(|connector_customer| {\n            connector_customer\n                .iter()\n                .find(|(connector_label, _)| connector_label == merchant_connector_id)\n                .map(|(_, connector_customer_id)| connector_customer_id)\n        })\n    }\n\n    \/\/\/ Get the connector customer ID for the specified connector label, if present\n    #[cfg(all(any(feature = \"v1\", feature = \"v2\"), not(feature = \"customer_v2\")))]\n    pub fn get_connector_customer_id_for_merchant_connector_id_and_merchant_id(\n        &self,\n        merchant_connector_id: &str,\n        merchant_id: &id_type::MerchantId,\n    ) -> Option<&str> {\n        self.connector_customer.as_ref().and_then(|connector_customer| {\n            connector_customer\n                .iter()\n                .find(|(connector_label, _)| connector_label == merchant_connector_id)\n                .map(|(_, connector_customer_id)| connector_customer_id)\n        })\n    }\n\n    \/\/\/ Get the connector customer ID for the specified connector label, if present\n    #[cfg(all(feature = \"v2\", feature = \"customer_v2\"))]\n    pub fn get_connector_customer_id_for_merchant_connector_id_and_merchant_id(\n        &self,\n        merchant_connector_id: &str,\n        merchant_id: &id_type::MerchantId,\n    ) -> Option<&str> {\n        self.connector_customer.as_ref().and_then(|connector_customer| {\n            connector_customer\n                .iter()\n                .find(|(connector_label, _)| connector_label == merchant_connector_id)\n                .map(|(_, connector_customer_id)| connector_customer_id)\n        })\n    }\n\n    \/\/\/ Get the connector customer ID for the specified connector label, if present\n    #[cfg(all(any(feature = \"v1\", feature = \"v2\"), not(feature = \"customer_v2\")))]\n    pub fn get_connector_customer_id_for_merchant_connector_id_and_merchant_id_and_profile_id(\n        &self,\n        merchant_connector_id: &str,\n        merchant_id: &id_type::MerchantId,\n        profile_id: &id_type::ProfileId,\n    ) -> Option<&str> {\n        self.connector_customer.as_ref().and_then(|connector_customer| {\n            connector_customer\n                .iter()\n                .find(|(connector_label, _)| connector_label == merchant_connector_id)\n                .map(|(_, connector_customer_id)| connector_customer_id)\n        })\n    }\n\n    \/\/\/ Get the connector customer ID for the specified connector label, if present\n    #[cfg(all(feature = \"v2\", feature = \"customer_v2\"))]\n    pub fn get_connector_customer_id_for_merchant_connector_id_and_merchant_id_and_profile_id(\n        &self,\n        merchant_connector_id: &str,\n        merchant_id: &id_type::MerchantId,\n        profile_id: &id_type::ProfileId,\n    ) -> Option<&str> {\n        self.connector_customer.as_ref().and_then(|connector_customer| {\n            connector_customer\n                .iter()\n                .find(|(connector_label, _)| connector_label == merchant_connector_id)\n                .map(|(_, connector_customer_id)| connector_customer_id)\n        })\n    }\n\n   ","",""],"best_token_recall":0.7142857143,"best_bleu":3.6489158372,"best_rougeL":7.9566003617,"exact_match_any":0},{"file":"crates\/router\/tests\/connectors\/zsl.rs","mask_idx":0,"target_len":307,"prompt_snippet":"use router::types::{self, storage::enums};\nuse test_utils::connector_auth;\n\nuse crate::utils::{self, ConnectorActions};\n\nstruct ZslTest;\nimpl ConnectorActions for ZslTest {}\nimpl utils::Connector for ZslTest {\n    fn get_data(&self) -> types::api::ConnectorData {","target_snippet":"\n        use router::connector::Zsl;\n        utils::construct_connector_data_old(\n            Box::new(&Zsl),\n            types::Connector::Adyen,\n            \/\/ Added as Dummy connector as template code is added for future usage\n            types::api::GetToken::Connector,\n            None,\n        )\n    ","generations":[" utils::construct_connector_data_old(\"zsl\", types::Connector::Zsl) }\n    fn get_auth_token(&self) -> types::ConnectorAuthType { utils::to_connector_auth_type(connector_auth::ConnectorAuthentication::new().zsl) }\n    fn get_name(&self) -> String { \"zsl\".to_string() }\n}\n\nstatic CONNECTOR: ZslTest = ZslTest {};\n\nfn get_default_payment_info() -> Option<utils::PaymentInfo> {\n    None\n}\n\nfn payment_method_details() -> Option<types::PaymentsAuthorizeData> {\n    None\n}\n\n\/\/ Cards Positive Tests\n\/\/ Creates a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_only_authorize_payment() {\n    let response = CONNECTOR\n        .authorize_payment(payment_method_details(), get_default_payment_info())\n        .await\n        .expect(\"Authorize payment response\");\n    assert_eq!(response.status, enums::AttemptStatus::Authorized);\n}\n\n\/\/ Captures a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_capture_authorized_payment() {\n    let response = CONNECTOR\n        .authorize_and_capture_payment(payment_method_details(), None, get_default_payment_info())\n        .await\n        .expect(\"Capture payment response\");\n    assert_eq!(response.status, enums::AttemptStatus::Charged);\n}\n\n\/\/ Partially captures a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_partially_capture_authorized_payment() {\n    let response = CONNECTOR\n        .authorize_and_capture_payment(\n            payment_method_details(),\n            Some(types::PaymentsCaptureData {\n                amount_to_capture: 50,\n                ..utils::PaymentCaptureType::default().0\n            }),\n            get_default_payment_info(),\n        )\n        .await\n        .expect(\"Capture payment response\");\n    assert_eq!(response.status, enums::AttemptStatus::Charged);\n}\n\n\/\/ Synchronizes a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_sync_authorized_payment() {\n    let authorize_response = CONNECTOR\n        .authorize_payment(payment_method_details(), get_default_payment_info())\n        .await\n        .expect(\"Authorize payment response\");\n    let txn_id = utils::get_connector_transaction_id(authorize_response.response);\n    let response = CONNECTOR\n        .psync_retry_till_status_matches(\n            enums::AttemptStatus::Authorized,\n            Some(types::PaymentsSyncData {\n                connector_transaction_id: types::ResponseId::ConnectorTransactionId(\n                    txn_id.unwrap(),\n                ),\n                ..Default::default()\n            }),\n            get_default_payment_info(),\n        )\n        .await\n        .expect(\"PSync response\");\n    assert_eq!(response.status, enums::AttemptStatus::Authorized,);\n}\n\n\/\/ Voids a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_void_authorized_payment() {\n    let response = CONNECTOR\n        .authorize_and_void_payment(\n            payment_method_details(),\n            Some(types::PaymentsCancelData {\n                connector_transaction_id: String::from(\"\"),\n                cancellation_reason: Some(\"requested_by_customer\".to_string()),\n                ..Default::default()\n            }),\n            get_default_payment_info(),\n        )\n        .await\n        .expect(\"Void payment response\");\n    assert_eq!(response.status, enums::AttemptStatus::Voided);\n}\n\n\/\/ Refunds a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_refund_manually_captured_payment() {\n    let response = CONNECTOR\n        .capture_payment_and_refund(\n            payment_method_details(),\n            None,\n            None,\n            get_default_payment_info(),\n        )\n        .await\n        .unwrap();\n    assert_eq!(\n        response.response.unwrap().refund_status,\n        enums::RefundStatus::Success,\n    );\n}\n\n\/\/ Partially refunds a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_partially_refund_manually_captured_payment() {\n    let response = CONNECTOR\n        .capture_payment_and_refund(\n            payment_method_details(),\n            None,\n            Some(types::RefundsData {\n                refund_amount: 50,\n                ..utils::PaymentRefundType::default().0\n            }),\n            get_default_payment_info(),\n        )\n        .await\n        .unwrap();\n    assert_eq!(\n        response.response.unwrap().refund_status,\n        enums::RefundStatus::Success,\n    );\n}\n\n\/\/ Synchronizes a refund using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_sync_manually_captured_refund() {\n    let refund_response = CONNECTOR\n        .capture_payment_and_refund(\n            payment_method_details(),\n            None,\n            None,\n            get_default_payment_info(),\n        )\n        .await\n       ","",""],"best_token_recall":0.6307692308,"best_bleu":2.1378212227,"best_rougeL":4.8780487805,"exact_match_any":0},{"file":"crates\/router\/tests\/connectors\/zsl.rs","mask_idx":1,"target_len":233,"prompt_snippet":"use router::types::{self, storage::enums};\nuse test_utils::connector_auth;\n\nuse crate::utils::{self, ConnectorActions};\n\nstruct ZslTest;\nimpl ConnectorActions for ZslTest {}\nimpl utils::Connector for ZslTest {\n    fn get_data(&self) -> types::api::ConnectorData {\n        use router::connector::Zsl;\n        utils::construct_connector_data_old(\n            Box::new(&Zsl),\n            types::Connecto...","target_snippet":"\n        utils::to_connector_auth_type(\n            connector_auth::ConnectorAuthentication::new()\n                .zsl\n                .expect(\"Missing connector authentication configuration\")\n                .into(),\n        )\n    ","generations":[" connector_auth::ConnectorAuthentication::new().zsl }\n\n    fn get_name(&self) -> String {\n        \"zsl\".to_string()\n    }\n}\n\nstatic CONNECTOR: ZslTest = ZslTest {};\n\nfn get_default_payment_info() -> Option<utils::PaymentInfo> {\n    None\n}\n\nfn payment_method_details() -> Option<types::PaymentsAuthorizeData> {\n    None\n}\n\n\/\/ Cards Positive Tests\n\/\/ Creates a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_only_authorize_payment() {\n    let response = CONNECTOR\n        .authorize_payment(payment_method_details(), get_default_payment_info())\n        .await\n        .expect(\"Authorize payment response\");\n    assert_eq!(response.status, enums::AttemptStatus::Authorized);\n}\n\n\/\/ Captures a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_capture_authorized_payment() {\n    let response = CONNECTOR\n        .authorize_and_capture_payment(payment_method_details(), None, get_default_payment_info())\n        .await\n        .expect(\"Capture payment response\");\n    assert_eq!(response.status, enums::AttemptStatus::Charged);\n}\n\n\/\/ Partially captures a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_partially_capture_authorized_payment() {\n    let response = CONNECTOR\n        .authorize_and_capture_payment(\n            payment_method_details(),\n            Some(types::PaymentsCaptureData {\n                amount_to_capture: 50,\n                ..utils::PaymentCaptureType::default().0\n            }),\n            get_default_payment_info(),\n        )\n        .await\n        .expect(\"Capture payment response\");\n    assert_eq!(response.status, enums::AttemptStatus::Charged);\n}\n\n\/\/ Synchronizes a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_sync_authorized_payment() {\n    let authorize_response = CONNECTOR\n        .authorize_payment(payment_method_details(), get_default_payment_info())\n        .await\n        .expect(\"Authorize payment response\");\n    let txn_id = utils::get_connector_transaction_id(authorize_response.response);\n    let response = CONNECTOR\n        .psync_retry_till_status_matches(\n            enums::AttemptStatus::Authorized,\n            Some(types::PaymentsSyncData {\n                connector_transaction_id: types::ResponseId::ConnectorTransactionId(\n                    txn_id.unwrap(),\n                ),\n                ..Default::default()\n            }),\n            get_default_payment_info(),\n        )\n        .await\n        .expect(\"PSync response\");\n    assert_eq!(response.status, enums::AttemptStatus::Authorized,);\n}\n\n\/\/ Voids a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_void_authorized_payment() {\n    let response = CONNECTOR\n        .authorize_and_void_payment(\n            payment_method_details(),\n            Some(types::PaymentsCancelData {\n                connector_transaction_id: String::from(\"\"),\n                cancellation_reason: Some(\"requested_by_customer\".to_string()),\n                ..Default::default()\n            }),\n            get_default_payment_info(),\n        )\n        .await\n        .expect(\"Void payment response\");\n    assert_eq!(response.status, enums::AttemptStatus::Voided);\n}\n\n\/\/ Refunds a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_refund_manually_captured_payment() {\n    let response = CONNECTOR\n        .capture_payment_and_refund(\n            payment_method_details(),\n            None,\n            None,\n            get_default_payment_info(),\n        )\n        .await\n        .unwrap();\n    assert_eq!(\n        response.response.unwrap().refund_status,\n        enums::RefundStatus::Success,\n    );\n}\n\n\/\/ Partially refunds a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_partially_refund_manually_captured_payment() {\n    let response = CONNECTOR\n        .capture_payment_and_refund(\n            payment_method_details(),\n            None,\n            Some(types::RefundsData {\n                refund_amount: 50,\n                ..utils::PaymentRefundType::default().0\n            }),\n            get_default_payment_info(),\n        )\n        .await\n        .unwrap();\n    assert_eq!(\n        response.response.unwrap().refund_status,\n        enums::RefundStatus::Success,\n    );\n}\n\n\/\/ Synchronizes a refund using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_sync_manually_captured_refund() {\n    let refund_response = CONNECTOR\n        .capture_payment_and_refund(\n            payment_method_details(),\n            None,\n            None,\n            get_default_payment_info(),\n        )\n        .await\n        .unwrap();\n    let response = CONNECTOR\n        .rsync_retry_till_status_matches(\n            enums::RefundStatus::Success,\n            refund_response.response.unwrap().connector_refund_id","",""],"best_token_recall":0.8205128205,"best_bleu":1.7783194774,"best_rougeL":2.7184466019,"exact_match_any":0},{"file":"crates\/router\/tests\/connectors\/zsl.rs","mask_idx":2,"target_len":31,"prompt_snippet":"use router::types::{self, storage::enums};\nuse test_utils::connector_auth;\n\nuse crate::utils::{self, ConnectorActions};\n\nstruct ZslTest;\nimpl ConnectorActions for ZslTest {}\nimpl utils::Connector for ZslTest {\n    fn get_data(&self) -> types::api::ConnectorData {\n        use router::connector::Zsl;\n        utils::construct_connector_data_old(\n            Box::new(&Zsl),\n            types::Connecto...","target_snippet":"\n        \"zsl\".to_string()\n    ","generations":[" \"zsl\".to_string() }\n}\n\nstatic CONNECTOR: ZslTest = ZslTest {};\n\nfn get_default_payment_info() -> Option<utils::PaymentInfo> {\n    None\n}\n\nfn payment_method_details() -> Option<types::PaymentsAuthorizeData> {\n    None\n}\n\n\/\/ Cards Positive Tests\n\/\/ Creates a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_only_authorize_payment() {\n    let response = CONNECTOR\n        .authorize_payment(payment_method_details(), get_default_payment_info())\n        .await\n        .expect(\"Authorize payment response\");\n    assert_eq!(response.status, enums::AttemptStatus::Authorized);\n}\n\n\/\/ Captures a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_capture_authorized_payment() {\n    let response = CONNECTOR\n        .authorize_and_capture_payment(payment_method_details(), None, get_default_payment_info())\n        .await\n        .expect(\"Capture payment response\");\n    assert_eq!(response.status, enums::AttemptStatus::Charged);\n}\n\n\/\/ Partially captures a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_partially_capture_authorized_payment() {\n    let response = CONNECTOR\n        .authorize_and_capture_payment(\n            payment_method_details(),\n            Some(types::PaymentsCaptureData {\n                amount_to_capture: 50,\n                ..utils::PaymentCaptureType::default().0\n            }),\n            get_default_payment_info(),\n        )\n        .await\n        .expect(\"Capture payment response\");\n    assert_eq!(response.status, enums::AttemptStatus::Charged);\n}\n\n\/\/ Synchronizes a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_sync_authorized_payment() {\n    let authorize_response = CONNECTOR\n        .authorize_payment(payment_method_details(), get_default_payment_info())\n        .await\n        .expect(\"Authorize payment response\");\n    let txn_id = utils::get_connector_transaction_id(authorize_response.response);\n    let response = CONNECTOR\n        .psync_retry_till_status_matches(\n            enums::AttemptStatus::Authorized,\n            Some(types::PaymentsSyncData {\n                connector_transaction_id: types::ResponseId::ConnectorTransactionId(\n                    txn_id.unwrap(),\n                ),\n                ..Default::default()\n            }),\n            get_default_payment_info(),\n        )\n        .await\n        .expect(\"PSync response\");\n    assert_eq!(response.status, enums::AttemptStatus::Authorized,);\n}\n\n\/\/ Voids a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_void_authorized_payment() {\n    let response = CONNECTOR\n        .authorize_and_void_payment(\n            payment_method_details(),\n            Some(types::PaymentsCancelData {\n                connector_transaction_id: String::from(\"\"),\n                cancellation_reason: Some(\"requested_by_customer\".to_string()),\n                ..Default::default()\n            }),\n            get_default_payment_info(),\n        )\n        .await\n        .expect(\"Void payment response\");\n    assert_eq!(response.status, enums::AttemptStatus::Voided);\n}\n\n\/\/ Refunds a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_refund_manually_captured_payment() {\n    let response = CONNECTOR\n        .capture_payment_and_refund(\n            payment_method_details(),\n            None,\n            None,\n            get_default_payment_info(),\n        )\n        .await\n        .unwrap();\n    assert_eq!(\n        response.response.unwrap().refund_status,\n        enums::RefundStatus::Success,\n    );\n}\n\n\/\/ Partially refunds a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_partially_refund_manually_captured_payment() {\n    let response = CONNECTOR\n        .capture_payment_and_refund(\n            payment_method_details(),\n            None,\n            Some(types::RefundsData {\n                refund_amount: 50,\n                ..utils::PaymentRefundType::default().0\n            }),\n            get_default_payment_info(),\n        )\n        .await\n        .unwrap();\n    assert_eq!(\n        response.response.unwrap().refund_status,\n        enums::RefundStatus::Success,\n    );\n}\n\n\/\/ Synchronizes a refund using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_sync_manually_captured_refund() {\n    let refund_response = CONNECTOR\n        .capture_payment_and_refund(\n            payment_method_details(),\n            None,\n            None,\n            get_default_payment_info(),\n        )\n        .await\n        .unwrap();\n    let response = CONNECTOR\n        .rsync_retry_till_status_matches(\n            enums::RefundStatus::Success,\n            refund_response.response.unwrap().connector_refund_id,\n            None,\n            get_default_payment_info(),\n        )\n        .await\n        .unwrap();\n    assert_eq","",""],"best_token_recall":0.9,"best_bleu":0.6473670043,"best_rougeL":1.1976047904,"exact_match_any":0},{"file":"crates\/analytics\/src\/disputes\/filters.rs","mask_idx":0,"target_len":592,"prompt_snippet":"use api_models::analytics::{disputes::DisputeDimensions, Granularity, TimeRange};\nuse common_utils::errors::ReportSwitchExt;\nuse diesel_models::enums::Currency;\nuse error_stack::ResultExt;\nuse time::PrimitiveDateTime;\n\nuse crate::{\n    enums::AuthInfo,\n    query::{Aggregate, GroupByClause, QueryBuilder, QueryFilter, ToSql, Window},\n    types::{\n        AnalyticsCollection, AnalyticsDataSource, DBE...","target_snippet":"\n    let mut query_builder: QueryBuilder<T> = QueryBuilder::new(AnalyticsCollection::Dispute);\n\n    query_builder.add_select_column(dimension).switch()?;\n    time_range\n        .set_filter_clause(&mut query_builder)\n        .attach_printable(\"Error filtering time range\")\n        .switch()?;\n\n    auth.set_filter_clause(&mut query_builder).switch()?;\n\n    query_builder.set_distinct();\n\n    query_bui...","generations":["    let mut query_builder: QueryBuilder<T> = QueryBuilder::new(AnalyticsCollection::DisputeSessionized);\n\n    query_builder.add_select_column(dimension).switch()?;\n    query_builder.add_select_column(Aggregate::Count {\n        field: None,\n        alias: Some(\"count\"),\n    })\n    .switch()?;\n\n    query_builder\n        .add_filter_clause(\"dispute_stage\", DBEnumWrapper::DisputeWon)\n        .switch()?;\n\n    query_builder\n        .add_auth_filter_clause(auth)\n        .attach_printable(\"Error filtering auth info\")\n        .switch()?;\n\n    query_builder\n        .add_time_range_filter_clause(time_range)\n        .attach_printable(\"Error filtering time range\")\n        .switch()?;\n\n    query_builder\n        .execute_query::<DisputeFilterRow, _>(pool)\n        .await\n        .change_context(FiltersError::QueryBuildingError)?\n        .change_context(FiltersError::QueryExecutionFailure)?\n        .into_iter()\n        .map(|i| {\n            Ok((\n                i.currency.as_ref().map(|i| i.0.to_string()),\n                i.connector.clone(),\n                i.profile_id.clone(),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_reason.clone(),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute","",""],"best_token_recall":0.9230769231,"best_bleu":7.7301393873,"best_rougeL":13.6434108527,"exact_match_any":0},{"file":"crates\/analytics\/src\/refunds\/metrics.rs","mask_idx":0,"target_len":2703,"prompt_snippet":"use api_models::analytics::{\n    refunds::{\n        RefundDimensions, RefundFilters, RefundMetrics, RefundMetricsBucketIdentifier, RefundType,\n    },\n    Granularity, TimeRange,\n};\nuse diesel_models::enums as storage_enums;\nuse time::PrimitiveDateTime;\nmod refund_count;\nmod refund_processed_amount;\nmod refund_success_count;\nmod refund_success_rate;\nmod sessionized_metrics;\nuse std::collections::Ha...","target_snippet":"\n    async fn load_metrics(\n        &self,\n        dimensions: &[RefundDimensions],\n        auth: &AuthInfo,\n        filters: &RefundFilters,\n        granularity: Option<Granularity>,\n        time_range: &TimeRange,\n        pool: &T,\n    ) -> MetricsResult<HashSet<(RefundMetricsBucketIdentifier, RefundMetricRow)>> {\n        match self {\n            Self::RefundSuccessRate => {\n                Refu...","generations":[" \/\/ TODO: Remove the redundant metrics\n    async fn load_metrics(\n        &self,\n        dimensions: &[RefundDimensions],\n        auth: &AuthInfo,\n        filters: &RefundFilters,\n        granularity: Option<Granularity>,\n        time_range: &TimeRange,\n        pool: &T,\n    ) -> MetricsResult<HashSet<(RefundMetricsBucketIdentifier, RefundMetricRow)>> {\n        let mut query_builder: crate::query::QueryBuilder<T> = crate::query::QueryBuilder::new(AnalyticsCollection::RefundSessionized);\n\n        for dim in dimensions.iter() {\n            query_builder.add_select_column(dim).switch()?;\n        }\n\n        query_builder\n            .add_select_column(Aggregate::Count {\n                field: None,\n                alias: Some(\"count\"),\n            })\n            .switch()?;\n\n        query_builder\n            .add_select_column(Aggregate::Min {\n                field: \"created_at\",\n                alias: Some(\"start_bucket\"),\n            })\n            .switch()?;\n\n        query_builder\n            .add_select_column(Aggregate::Max {\n                field: \"created_at\",\n                alias: Some(\"end_bucket\"),\n            })\n            .switch()?;\n\n        filters.set_filter_clause(&mut query_builder).switch()?;\n\n        auth.set_filter_clause(&mut query_builder).switch()?;\n\n        time_range\n            .set_filter_clause(&mut query_builder)\n            .attach_printable(\"Error filtering time range\")\n            .switch()?;\n\n        for dim in dimensions.iter() {\n            query_builder.add_group_by_clause(dim).switch()?;\n        }\n\n        if let Some(granularity) = granularity {\n            granularity\n                .set_group_by_clause(&mut query_builder)\n                .attach_printable(\"Error adding granularity\")\n                .switch()?;\n        }\n\n        query_builder\n            .execute_query::<RefundMetricRow, _>(pool)\n            .await\n            .change_context(\"Error filtering metrics\")\n            .map(|metrics| {\n                metrics.into_iter().map(|i| {\n                    Ok((\n                        RefundMetricsBucketIdentifier::new(\n                            i.currency.as_ref().map(|i| i.0),\n                            i.refund_status.as_ref().map(|i| i.0),\n                            i.connector.as_ref().map(|i| i.0.to_owned()),\n                            i.refund_type.as_ref().map(|i| i.0),\n                            i.profile_id.as_ref().map(|i| i.0.to_owned()),\n                            i.refund_reason.as_ref().map(|i| i.0.to_owned()),\n                            i.refund_error_message.as_ref().map(|i| i.0.to_owned()),\n                            i.start_bucket,\n                            i.end_bucket,\n                        ),\n                        i,\n                    ))\n                })\n                .collect::<Result<\n                    HashSet<(RefundMetricsBucketIdentifier, RefundMetricRow)>,\n                    crate::query::PostProcessingError,\n                >>()\n                .change_context(crate::errors::AnalyticsError::PostProcessingFailure)\n            })\n            .change_context(crate::errors::AnalyticsError::QueryBuildingError)\n    }\n}\n\n#[async_trait::async_trait]\nimpl<T> RefundMetric<T> for RefundCount\nwhere\n    T: AnalyticsDataSource + RefundMetricAnalytics,\n    PrimitiveDateTime: ToSql<T>,\n    AnalyticsCollection: ToSql<T>,\n    Granularity: GroupByClause<T>,\n    Aggregate<&'static str>: ToSql<T>,\n    Window<&'static str>: ToSql<T>,\n{\n    async fn load_metrics(\n        &self,\n        dimensions: &[RefundDimensions],\n        auth: &AuthInfo,\n        filters: &RefundFilters,\n        granularity: Option<Granularity>,\n        time_range: &TimeRange,\n        pool: &T,\n    ) -> MetricsResult<HashSet<(RefundMetricsBucketIdentifier, RefundMetricRow)>> {\n        let mut query_builder: crate::query::QueryBuilder<T> = crate::query::QueryBuilder::new(AnalyticsCollection::RefundSessionized);\n\n        for dim in dimensions.iter() {\n            query_builder.add_select_column(dim).switch()?;\n        }\n\n        query_builder\n            .add_select_column(Aggregate::Count {\n                field: None,\n                alias: Some(\"count\"),\n            })\n            .switch()?;\n\n        query_builder\n            .add_select_column(Aggregate::Min {\n                field: \"created_at\",\n                alias: Some(\"start_bucket\"),\n            })\n            .switch()?;\n\n        query_builder\n            .add_select_column(Aggregate::Max {\n                field: \"created_at\",\n                alias: Some(\"end_bucket\"),\n            })\n            .switch()?;\n\n        filters.set_filter_clause(&mut query_builder).switch()?;\n\n        auth.set_filter_clause(&mut query_builder).switch()?;\n\n        time_range\n            .set_filter_clause(&mut query_builder)\n            .attach_printable(\"Error filtering time range\")\n            .switch()?;\n\n        for dim in dimensions.iter() {\n            query_builder.add_group_by_clause(dim).switch()?;\n        }\n\n        if let Some(granularity)","",""],"best_token_recall":0.8455598456,"best_bleu":10.0409903956,"best_rougeL":17.8628389155,"exact_match_any":0},{"file":"crates\/api_models\/src\/routing.rs","mask_idx":0,"target_len":220,"prompt_snippet":"use std::fmt::Debug;\n\nuse common_utils::{errors::ParsingError, ext_traits::ValueExt, pii};\npub use euclid::{\n    dssa::types::EuclidAnalysable,\n    frontend::{\n        ast,\n        dir::{DirKeyKind, EuclidDirFilter},\n    },\n};\nuse serde::{Deserialize, Serialize};\nuse utoipa::ToSchema;\n\nuse crate::enums::{RoutableConnectors, TransactionType};\n\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema...","target_snippet":"\n        match self {\n            Self::Priority(list) => list.clone(),\n            Self::VolumeSplit(splits) => {\n                splits.iter().map(|split| split.connector.clone()).collect()\n            }\n        }\n    ","generations":[" self.get_priority_list() }\n\n    pub fn get_priority_list(&self) -> Vec<RoutableConnectorChoice> {\n        match self {\n            Self::Priority(connectors) => connectors.clone(),\n            Self::VolumeSplit(_) => vec![],\n        }\n    }\n\n    pub fn get_priority_connectors(&self) -> Vec<RoutableConnectors> {\n        self.get_priority_list()\n            .iter()\n            .map(|connector| connector.connector)\n            .collect()\n    }\n\n    pub fn get_priority_connectors_count(&self) -> usize {\n        self.get_priority_list().len()\n    }\n\n    pub fn get_priority_connectors_with_priority(&self) -> Vec<(RoutableConnectors, u8)> {\n        self.get_priority_list()\n            .iter()\n            .map(|connector| (connector.connector, connector.priority))\n            .collect()\n    }\n\n    pub fn get_priority_connectors_with_priority_and_transaction_type(\n        &self,\n        transaction_type: TransactionType,\n    ) -> Vec<(RoutableConnectors, u8, TransactionType)> {\n        self.get_priority_list()\n            .iter()\n            .map(|connector| {\n                let priority = connector.priority;\n                let transaction_type = connector.transaction_type.unwrap_or(transaction_type);\n                (connector.connector, priority, transaction_type)\n            })\n            .collect()\n    }\n\n    pub fn get_priority_connectors_with_priority_and_transaction_type_and_currency(\n        &self,\n        transaction_type: TransactionType,\n        currency: Option<common_enums::Currency>,\n    ) -> Vec<(RoutableConnectors, u8, TransactionType, Option<common_enums::Currency>)> {\n        self.get_priority_list()\n            .iter()\n            .map(|connector| {\n                let priority = connector.priority;\n                let transaction_type = connector.transaction_type.unwrap_or(transaction_type);\n                let currency = connector.currency.unwrap_or(currency);\n                (connector.connector, priority, transaction_type, currency)\n            })\n            .collect()\n    }\n\n    pub fn get_priority_connectors_with_priority_and_transaction_type_and_merchant_connector_id(\n        &self,\n        transaction_type: TransactionType,\n        merchant_connector_id: Option<String>,\n    ) -> Vec<(RoutableConnectors, u8, TransactionType, Option<String>)> {\n        self.get_priority_list()\n            .iter()\n            .map(|connector| {\n                let priority = connector.priority;\n                let transaction_type = connector.transaction_type.unwrap_or(transaction_type);\n                let merchant_connector_id = connector.merchant_connector_id.unwrap_or(merchant_connector_id);\n                (connector.connector, priority, transaction_type, merchant_connector_id)\n            })\n            .collect()\n    }\n\n    pub fn get_priority_connectors_with_priority_and_transaction_type_and_merchant_connector_id_and_payment_method(\n        &self,\n        transaction_type: TransactionType,\n        merchant_connector_id: Option<String>,\n        payment_method: Option<common_enums::PaymentMethod>,\n    ) -> Vec<(RoutableConnectors, u8, TransactionType, Option<String>, Option<common_enums::PaymentMethod>)> {\n        self.get_priority_list()\n            .iter()\n            .map(|connector| {\n                let priority = connector.priority;\n                let transaction_type = connector.transaction_type.unwrap_or(transaction_type);\n                let merchant_connector_id = connector.merchant_connector_id.unwrap_or(merchant_connector_id);\n                let payment_method = connector.payment_method.unwrap_or(payment_method);\n                (connector.connector, priority, transaction_type, merchant_connector_id, payment_method)\n            })\n            .collect()\n    }\n\n    pub fn get_priority_connectors_with_priority_and_transaction_type_and_merchant_connector_id_and_payment_method_type(\n        &self,\n        transaction_type: TransactionType,\n        merchant_connector_id: Option<String>,\n        payment_method_type: Option<common_enums::PaymentMethodType>,\n    ) -> Vec<(RoutableConnectors, u8, TransactionType, Option<String>, Option<common_enums::PaymentMethodType>)> {\n        self.get_priority_list()\n            .iter()\n            .map(|connector| {\n                let priority = connector.priority;\n                let transaction_type = connector.transaction_type.unwrap_or(transaction_type);\n                let merchant_connector_id = connector.merchant_connector_id.unwrap_or(merchant_connector_id);\n                let payment_method_type = connector.payment_method_type.unwrap_or(payment_method_type);\n                (connector.connector, priority, transaction_type, merchant_connector_id, payment_method_type)\n            })\n            .collect()\n    }\n\n    pub fn get_priority_connectors_with_priority_and_transaction_type_and_merchant_connector_id_and_payment_method_and_payment_experience(\n        &self,\n        transaction_type: TransactionType,\n        merchant_connector_id: Option<String>,\n        payment_method: Option<common_enums::PaymentMethod>,\n        payment_experience: Option<common_enums::PaymentExperience>,\n    ) -> Vec<(RoutableConnectors, u8, TransactionType, Option<String>, Option<common_enums::PaymentMethod>, Option<common_enums::PaymentExperience>)> {\n        self.get_priority_list()\n            .iter()\n            .map(|","",""],"best_token_recall":0.75,"best_bleu":2.6585933222,"best_rougeL":4.1044776119,"exact_match_any":0},{"file":"crates\/api_models\/src\/routing.rs","mask_idx":1,"target_len":806,"prompt_snippet":"use std::fmt::Debug;\n\nuse common_utils::{errors::ParsingError, ext_traits::ValueExt, pii};\npub use euclid::{\n    dssa::types::EuclidAnalysable,\n    frontend::{\n        ast,\n        dir::{DirKeyKind, EuclidDirFilter},\n    },\n};\nuse serde::{Deserialize, Serialize};\nuse utoipa::ToSchema;\n\nuse crate::enums::{RoutableConnectors, TransactionType};\n\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema...","target_snippet":"\n        self.get_connector_list()\n            .into_iter()\n            .map(|connector_choice| {\n                let connector_name = connector_choice.connector.to_string();\n                let mca_id = connector_choice.merchant_connector_id.clone();\n\n                (\n                    euclid::frontend::dir::DirValue::Connector(Box::new(connector_choice.into())),\n                    std::colle...","generations":[" ... }\n}\n\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, ToSchema)]\npub struct RoutingAlgorithm {\n    pub algorithm: Vec<RoutingAlgorithmChoice>,\n}\n\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, ToSchema)]\npub struct RoutingAlgorithmChoice {\n    pub condition: RoutingAlgorithmCondition,\n    pub connector_selection: ConnectorSelection,\n}\n\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, ToSchema)]\npub struct RoutingAlgorithmCondition {\n    pub payment_method: Option<String>,\n    pub payment_method_type: Option<String>,\n    pub payment_method_data: Option<String>,\n    pub payment_method_subtype: Option<String>,\n    pub payment_method_brand: Option<String>,\n    pub payment_method_issuer: Option<String>,\n    pub payment_method_issuing_country: Option<String>,\n    pub payment_method_issuing_city: Option<String>,\n    pub payment_method_issuing_zip: Option<String>,\n    pub payment_method_issuing_state: Option<String>,\n    pub payment_method_issuing_state_code: Option<String>,\n    pub payment_method_issuing_country_code: Option<String>,\n    pub payment_method_issuing_city_code: Option<String>,\n    pub payment_method_issuing_zip_code: Option<String>,\n    pub payment_method_issuing_state_code: Option<String>,\n    pub payment_method_issuing_country_code: Option<String>,\n    pub payment_method_issuing_city_code: Option<String>,\n    pub payment_method_issuing_zip_code: Option<String>,\n    pub payment_method_issuing_state_code: Option<String>,\n    pub payment_method_issuing_country_code: Option<String>,\n    pub payment_method_issuing_city_code: Option<String>,\n    pub payment_method_issuing_zip_code: Option<String>,\n    pub payment_method_issuing_state_code: Option<String>,\n    pub payment_method_issuing_country_code: Option<String>,\n    pub payment_method_issuing_city_code: Option<String>,\n    pub payment_method_issuing_zip_code: Option<String>,\n    pub payment_method_issuing_state_code: Option<String>,\n    pub payment_method_issuing_country_code: Option<String>,\n    pub payment_method_issuing_city_code: Option<String>,\n    pub payment_method_issuing_zip_code: Option<String>,\n    pub payment_method_issuing_state_code: Option<String>,\n    pub payment_method_issuing_country_code: Option<String>,\n    pub payment_method_issuing_city_code: Option<String>,\n    pub payment_method_issuing_zip_code: Option<String>,\n    pub payment_method_issuing_state_code: Option<String>,\n    pub payment_method_issuing_country_code: Option<String>,\n    pub payment_method_issuing_city_code: Option<String>,\n    pub payment_method_issuing_zip_code: Option<String>,\n    pub payment_method_issuing_state_code: Option<String>,\n    pub payment_method_issuing_country_code: Option<String>,\n    pub payment_method_issuing_city_code: Option<String>,\n    pub payment_method_issuing_zip_code: Option<String>,\n    pub payment_method_issuing_state_code: Option<String>,\n    pub payment_method_issuing_country_code: Option<String>,\n    pub payment_method_issuing_city_code: Option<String>,\n    pub payment_method_issuing_zip_code: Option<String>,\n    pub payment_method_issuing_state_code: Option<String>,\n    pub payment_method_issuing_country_code: Option<String>,\n    pub payment_method_issuing_city_code: Option<String>,\n    pub payment_method_issuing_zip_code: Option<String>,\n    pub payment_method_issuing_state_code: Option<String>,\n    pub payment_method_issuing_country_code: Option<String>,\n    pub payment_method_issuing_city_code: Option<String>,\n    pub payment_method_issuing_zip_code: Option<String>,\n    pub payment_method_issuing_state_code: Option<String>,\n    pub payment_method_issuing_country_code: Option<String>,\n    pub payment_method_issuing_city_code: Option<String>,\n    pub payment_method_issuing_zip_code: Option<String>,\n    pub payment_method_issuing_state_code: Option<String>,\n    pub payment_method_issuing_country_code: Option<String>,\n    pub payment_method_issuing_city_code: Option<String>,\n    pub payment_method_issuing_zip_code: Option<String>,\n    pub payment_method_issuing_state_code: Option<String>,\n    pub payment_method_issuing_country_code: Option<String>,\n    pub payment_method_issuing_city_code: Option<String>,\n    pub payment_method_issuing_zip_code: Option<String>,\n    pub payment_method_issuing_state_code: Option<String>,\n    pub payment_method_issuing_country_code: Option<String>,\n    pub payment_method_issuing_city_code: Option<String>,\n    pub payment_method_issuing_zip_code: Option<String>,\n    pub payment_method_issuing_state_code: Option<String>,\n    pub payment_method_issuing_country_code: Option<String>,\n    pub payment_method_issuing_city_code: Option<String>,\n    pub payment_method","",""],"best_token_recall":0.1343283582,"best_bleu":0.2442588848,"best_rougeL":1.1851851852,"exact_match_any":0},{"file":"crates\/api_models\/src\/routing.rs","mask_idx":2,"target_len":223,"prompt_snippet":"use std::fmt::Debug;\n\nuse common_utils::{errors::ParsingError, ext_traits::ValueExt, pii};\npub use euclid::{\n    dssa::types::EuclidAnalysable,\n    frontend::{\n        ast,\n        dir::{DirKeyKind, EuclidDirFilter},\n    },\n};\nuse serde::{Deserialize, Serialize};\nuse utoipa::ToSchema;\n\nuse crate::enums::{RoutableConnectors, TransactionType};\n\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema...","target_snippet":"\n        let base = self.connector.to_string();\n        if let Some(mca_id) = &self.merchant_connector_id {\n            return write!(f, \"{}:{}\", base, mca_id.get_string_repr());\n        }\n        write!(f, \"{}\", base)\n    ","generations":[" write!(f, \"{}\", self.connector) }\n}\n\nimpl From<RoutableConnectorChoice> for ast::DirValue {\n    fn from(item: RoutableConnectorChoice) -> Self {\n        ast::DirValue::Connector(Box::new(item))\n    }\n}\n\nimpl From<RoutableConnectorChoice> for ast::DirValue {\n    fn from(item: RoutableConnectorChoice) -> Self {\n        ast::DirValue::Connector(Box::new(item))\n    }\n}\n\nimpl From<RoutableConnectorChoice> for ast::DirValue {\n    fn from(item: RoutableConnectorChoice) -> Self {\n        ast::DirValue::Connector(Box::new(item))\n    }\n}\n\nimpl From<RoutableConnectorChoice> for ast::DirValue {\n    fn from(item: RoutableConnectorChoice) -> Self {\n        ast::DirValue::Connector(Box::new(item))\n    }\n}\n\nimpl From<RoutableConnectorChoice> for ast::DirValue {\n    fn from(item: RoutableConnectorChoice) -> Self {\n        ast::DirValue::Connector(Box::new(item))\n    }\n}\n\nimpl From<RoutableConnectorChoice> for ast::DirValue {\n    fn from(item: RoutableConnectorChoice) -> Self {\n        ast::DirValue::Connector(Box::new(item))\n    }\n}\n\nimpl From<RoutableConnectorChoice> for ast::DirValue {\n    fn from(item: RoutableConnectorChoice) -> Self {\n        ast::DirValue::Connector(Box::new(item))\n    }\n}\n\nimpl From<RoutableConnectorChoice> for ast::DirValue {\n    fn from(item: RoutableConnectorChoice) -> Self {\n        ast::DirValue::Connector(Box::new(item))\n    }\n}\n\nimpl From<RoutableConnectorChoice> for ast::DirValue {\n    fn from(item: RoutableConnectorChoice) -> Self {\n        ast::DirValue::Connector(Box::new(item))\n    }\n}\n\nimpl From<RoutableConnectorChoice> for ast::DirValue {\n    fn from(item: RoutableConnectorChoice) -> Self {\n        ast::DirValue::Connector(Box::new(item))\n    }\n}\n\nimpl From<RoutableConnectorChoice> for ast::DirValue {\n    fn from(item: RoutableConnectorChoice) -> Self {\n        ast::DirValue::Connector(Box::new(item))\n    }\n}\n\nimpl From<RoutableConnectorChoice> for ast::DirValue {\n    fn from(item: RoutableConnectorChoice) -> Self {\n        ast::DirValue::Connector(Box::new(item))\n    }\n}\n\nimpl From<RoutableConnectorChoice> for ast::DirValue {\n    fn from(item: RoutableConnectorChoice) -> Self {\n        ast::DirValue::Connector(Box::new(item))\n    }\n}\n\nimpl From<RoutableConnectorChoice> for ast::DirValue {\n    fn from(item: RoutableConnectorChoice) -> Self {\n        ast::DirValue::Connector(Box::new(item))\n    }\n}\n\nimpl From<RoutableConnectorChoice> for ast::DirValue {\n    fn from(item: RoutableConnectorChoice) -> Self {\n        ast::DirValue::Connector(Box::new(item))\n    }\n}\n\nimpl From<RoutableConnectorChoice> for ast::DirValue {\n    fn from(item: RoutableConnectorChoice) -> Self {\n        ast::DirValue::Connector(Box::new(item))\n    }\n}\n\nimpl From<RoutableConnectorChoice> for ast::DirValue {\n    fn from(item: RoutableConnectorChoice) -> Self {\n        ast::DirValue::Connector(Box::new(item))\n    }\n}\n\nimpl From<RoutableConnectorChoice> for ast::DirValue {\n    fn from(item: RoutableConnectorChoice) -> Self {\n        ast::DirValue::Connector(Box::new(item))\n    }\n}\n\nimpl From<RoutableConnectorChoice> for ast::DirValue {\n    fn from(item: RoutableConnectorChoice) -> Self {\n        ast::DirValue::Connector(Box::new(item))\n    }\n}\n\nimpl From<RoutableConnectorChoice> for ast::DirValue {\n    fn from(item: RoutableConnectorChoice) -> Self {\n        ast::DirValue::Connector(Box::new(item))\n    }\n}\n\nimpl From<RoutableConnectorChoice> for ast::DirValue {\n    fn from(item: RoutableConnectorChoice) -> Self {\n        ast::DirValue::Connector(Box::new(item))\n    }\n}\n\nimpl From<RoutableConnectorChoice> for ast::DirValue {\n    fn from(item: RoutableConnectorChoice) -> Self {\n        ast::DirValue::Connector(Box::new(item))\n    }\n}\n\nimpl From<RoutableConnectorChoice> for ast::DirValue {\n    fn from(item: RoutableConnectorChoice) -> Self {\n        ast::DirValue::Connector(Box::new(item))\n    }\n}\n\nimpl From<RoutableConnectorChoice> for ast::DirValue {\n    fn from(item: RoutableConnectorChoice) -> Self {\n        ast::DirValue::Connector(Box::new(item))\n    }\n}\n\nimpl From<Routable","",""],"best_token_recall":0.3928571429,"best_bleu":1.2435676099,"best_rougeL":1.8099547511,"exact_match_any":0},{"file":"crates\/router\/src\/db\/api_keys.rs","mask_idx":0,"target_len":5724,"prompt_snippet":"use error_stack::report;\nuse router_env::{instrument, tracing};\n#[cfg(feature = \"accounts_cache\")]\nuse storage_impl::redis::cache::{self, CacheKind, ACCOUNTS_CACHE};\n\nuse super::{MockDb, Store};\nuse crate::{\n    connection,\n    core::errors::{self, CustomResult},\n    types::storage,\n};\n\n#[async_trait::async_trait]\npub trait ApiKeyInterface {\n    async fn insert_api_key(\n        &self,\n        api_...","target_snippet":"\n    #[instrument(skip_all)]\n    async fn insert_api_key(\n        &self,\n        api_key: storage::ApiKeyNew,\n    ) -> CustomResult<storage::ApiKey, errors::StorageError> {\n        let conn = connection::pg_connection_write(self).await?;\n        api_key\n            .insert(&conn)\n            .await\n            .map_err(|error| report!(errors::StorageError::from(error)))\n    }\n\n    #[instrument(ski...","generations":["#[cfg(feature = \"v1\")]\n    #[instrument(skip_all)]\n    async fn insert_api_key(\n        &self,\n        api_key: storage::ApiKeyNew,\n    ) -> CustomResult<storage::ApiKey, errors::StorageError> {\n        let conn = connection::pg_connection_write(self).await?;\n        let key_id = common_utils::id_type::ApiKeyId::generate();\n        let api_key = storage::ApiKey {\n            key_id,\n            merchant_id: api_key.merchant_id,\n            key: api_key.key,\n            created_at: api_key.created_at,\n            last_modified_at: api_key.last_modified_at,\n            expires: api_key.expires,\n            description: api_key.description,\n            disabled: api_key.disabled,\n            hashed_api_key: api_key.hashed_api_key,\n            hashed_key_id: api_key.hashed_key_id,\n            key_id: api_key.key_id,\n            key_type: api_key.key_type,\n            key_version: api_key.key_version,\n            key_status: api_key.key_status,\n            key_arn: api_key.key_arn,\n            key_metadata: api_key.key_metadata,\n            key_issuer: api_key.key_issuer,\n            key_issuer_url: api_key.key_issuer_url,\n            key_arn: api_key.key_arn,\n            key_metadata: api_key.key_metadata,\n            key_issuer: api_key.key_issuer,\n            key_issuer_url: api_key.key_issuer_url,\n            key_arn: api_key.key_arn,\n            key_metadata: api_key.key_metadata,\n            key_issuer: api_key.key_issuer,\n            key_issuer_url: api_key.key_issuer_url,\n            key_arn: api_key.key_arn,\n            key_metadata: api_key.key_metadata,\n            key_issuer: api_key.key_issuer,\n            key_issuer_url: api_key.key_issuer_url,\n            key_arn: api_key.key_arn,\n            key_metadata: api_key.key_metadata,\n            key_issuer: api_key.key_issuer,\n            key_issuer_url: api_key.key_issuer_url,\n            key_arn: api_key.key_arn,\n            key_metadata: api_key.key_metadata,\n            key_issuer: api_key.key_issuer,\n            key_issuer_url: api_key.key_issuer_url,\n            key_arn: api_key.key_arn,\n            key_metadata: api_key.key_metadata,\n            key_issuer: api_key.key_issuer,\n            key_issuer_url: api_key.key_issuer_url,\n            key_arn: api_key.key_arn,\n            key_metadata: api_key.key_metadata,\n            key_issuer: api_key.key_issuer,\n            key_issuer_url: api_key.key_issuer_url,\n            key_arn: api_key.key_arn,\n            key_metadata: api_key.key_metadata,\n            key_issuer: api_key.key_issuer,\n            key_issuer_url: api_key.key_issuer_url,\n            key_arn: api_key.key_arn,\n            key_metadata: api_key.key_metadata,\n            key_issuer: api_key.key_issuer,\n            key_issuer_url: api_key.key_issuer_url,\n            key_arn: api_key.key_arn,\n            key_metadata: api_key.key_metadata,\n            key_issuer: api_key.key_issuer,\n            key_issuer_url: api_key.key_issuer_url,\n            key_arn: api_key.key_arn,\n            key_metadata: api_key.key_metadata,\n            key_issuer: api_key.key_issuer,\n            key_issuer_url: api_key.key_issuer_url,\n            key_arn: api_key.key_arn,\n            key_metadata: api_key.key_metadata,\n            key_issuer: api_key.key_issuer,\n            key_issuer_url: api_key.key_issuer_url,\n            key_arn: api_key.key_arn,\n            key_metadata: api_key.key_metadata,\n            key_issuer: api_key.key_issuer,\n            key_issuer_url: api_key.key_issuer_url,\n            key_arn: api_key.key_arn,\n            key_metadata: api_key.key_metadata,\n            key_issuer: api_key.key_issuer,\n            key_issuer_url: api_key.key_issuer_url,\n            key_arn: api_key.key_arn,\n            key_metadata: api_key.key_metadata,\n            key_issuer: api_key.key_issuer,\n            key_issuer_url: api_key.key_issuer_url,\n            key_arn: api_key.key_arn,\n            key_metadata: api_key.key_metadata,\n            key_issuer: api_key.key_issuer,\n            key_issuer_url: api_key.key_issuer_url,\n            key_arn: api_key.key_arn,\n            key_metadata: api_key.key_metadata,\n            key_issuer: api_key.key_issuer,\n            key_issuer_url: api_key.key_issuer_url,\n            key_arn: api_key.key_arn,\n            key_metadata: api_key.key_metadata,\n            key","",""],"best_token_recall":0.5896607431,"best_bleu":14.1934502232,"best_rougeL":16.7487684729,"exact_match_any":0},{"file":"crates\/router\/src\/db\/api_keys.rs","mask_idx":1,"target_len":856,"prompt_snippet":"use error_stack::report;\nuse router_env::{instrument, tracing};\n#[cfg(feature = \"accounts_cache\")]\nuse storage_impl::redis::cache::{self, CacheKind, ACCOUNTS_CACHE};\n\nuse super::{MockDb, Store};\nuse crate::{\n    connection,\n    core::errors::{self, CustomResult},\n    types::storage,\n};\n\n#[async_trait::async_trait]\npub trait ApiKeyInterface {\n    async fn insert_api_key(\n        &self,\n        api_...","target_snippet":"\n        let mut locked_api_keys = self.api_keys.lock().await;\n        \/\/ don't allow duplicate key_ids, a those would be a unique constraint violation in the\n        \/\/ real db as it is used as the primary key\n        if locked_api_keys.iter().any(|k| k.key_id == api_key.key_id) {\n            Err(errors::StorageError::MockDbError)?;\n        }\n        let stored_key = storage::ApiKey {\n           ...","generations":[" self.api_keys.push(api_key); Ok(api_key) }\n\n    async fn update_api_key(\n        &self,\n        merchant_id: common_utils::id_type::MerchantId,\n        key_id: common_utils::id_type::ApiKeyId,\n        api_key: storage::ApiKeyUpdate,\n    ) -> CustomResult<storage::ApiKey, errors::StorageError> {\n        let index = self.api_keys.iter().position(|api_key| {\n            api_key.merchant_id == merchant_id && api_key.key_id == key_id\n        });\n        match index {\n            Some(index) => {\n                let mut api_key = self.api_keys[index];\n                api_key.update(api_key, api_key, api_key, api_key, api_key, api_key);\n                Ok(api_key)\n            }\n            None => Err(report!(errors::StorageError::ValueNotFound(format!(\n                \"ApiKey of {} not found\",\n                key_id.get_string_repr()\n            )))),\n        }\n    }\n\n    async fn revoke_api_key(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        key_id: &common_utils::id_type::ApiKeyId,\n    ) -> CustomResult<bool, errors::StorageError> {\n        let index = self.api_keys.iter().position(|api_key| {\n            api_key.merchant_id == merchant_id && api_key.key_id == key_id\n        });\n        match index {\n            Some(index) => {\n                self.api_keys.remove(index);\n                Ok(true)\n            }\n            None => Err(report!(errors::StorageError::ValueNotFound(format!(\n                \"ApiKey of {} not found\",\n                key_id.get_string_repr()\n            )))),\n        }\n    }\n\n    async fn find_api_key_by_merchant_id_key_id_optional(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        key_id: &common_utils::id_type::ApiKeyId,\n    ) -> CustomResult<Option<storage::ApiKey>, errors::StorageError> {\n        let index = self.api_keys.iter().position(|api_key| {\n            api_key.merchant_id == merchant_id && api_key.key_id == key_id\n        });\n        match index {\n            Some(index) => Ok(Some(self.api_keys[index].clone())),\n            None => Ok(None),\n        }\n    }\n\n    async fn find_api_key_by_hash_optional(\n        &self,\n        hashed_api_key: storage::HashedApiKey,\n    ) -> CustomResult<Option<storage::ApiKey>, errors::StorageError> {\n        let index = self.api_keys.iter().position(|api_key| {\n            api_key.hashed_api_key == hashed_api_key\n        });\n        match index {\n            Some(index) => Ok(Some(self.api_keys[index].clone())),\n            None => Ok(None),\n        }\n    }\n\n    async fn list_api_keys_by_merchant_id(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        limit: Option<i64>,\n        offset: Option<i64>,\n    ) -> CustomResult<Vec<storage::ApiKey>, errors::StorageError> {\n        let mut filtered_api_keys = Vec::new();\n        for api_key in self.api_keys.iter() {\n            if api_key.merchant_id == merchant_id {\n                filtered_api_keys.push(api_key.clone());\n            }\n        }\n        let filtered_api_keys = filtered_api_keys.into_iter().skip(offset.unwrap_or(0)).take(limit.unwrap_or(u32::MAX.into()));\n        Ok(filtered_api_keys)\n    }\n}\n#[cfg(feature = \"v1\")]\n#[async_trait::async_trait]\nimpl ApiKeyInterface for super::MockDbV1 {\n    async fn insert_api_key(\n        &self,\n        api_key: storage::ApiKeyNew,\n    ) -> CustomResult<storage::ApiKey, errors::StorageError> {\n        let conn = connection::pg_connection_write(self).await?;\n        api_key\n            .insert(&conn)\n            .await\n            .map_err(|error| report!(errors::StorageError::from(error)))\n    }\n\n    async fn update_api_key(\n        &self,\n        merchant_id: common_utils::id_type::MerchantId,\n        key_id: common_utils::id_type::ApiKeyId,\n        api_key: storage::ApiKeyUpdate,\n    ) -> CustomResult<storage::ApiKey, errors::StorageError> {\n        let conn = connection::pg_connection_write(self).await?;\n        let _merchant_id = merchant_id.clone();\n        let _key_id = key_id.clone();\n        let update_call = || async {\n            storage::ApiKey::update_by_merchant_id_key_id(&conn, merchant_id, key_id, api_key)\n                .await\n                .map_err(|error| report!(errors::StorageError::from(error)))\n        };\n\n        #[cfg(not(feature = \"accounts_cache\"))]\n        {\n            update_call().await\n        }\n\n        #[cfg(feature = \"accounts_cache\")]\n        {\n            use error_stack::report;\n\n            \/\/ We need to fetch api_key here because the","",""],"best_token_recall":0.6984126984,"best_bleu":8.5249187011,"best_rougeL":18.26625387,"exact_match_any":0},{"file":"crates\/router\/src\/db\/api_keys.rs","mask_idx":2,"target_len":1304,"prompt_snippet":"use error_stack::report;\nuse router_env::{instrument, tracing};\n#[cfg(feature = \"accounts_cache\")]\nuse storage_impl::redis::cache::{self, CacheKind, ACCOUNTS_CACHE};\n\nuse super::{MockDb, Store};\nuse crate::{\n    connection,\n    core::errors::{self, CustomResult},\n    types::storage,\n};\n\n#[async_trait::async_trait]\npub trait ApiKeyInterface {\n    async fn insert_api_key(\n        &self,\n        api_...","target_snippet":"\n        let mut locked_api_keys = self.api_keys.lock().await;\n        \/\/ find a key with the given merchant_id and key_id and update, otherwise return an error\n        let key_to_update = locked_api_keys\n            .iter_mut()\n            .find(|k| k.merchant_id == merchant_id && k.key_id == key_id)\n            .ok_or(errors::StorageError::MockDbError)?;\n\n        match api_key {\n            stor...","generations":[" \/\/ TODO: implement\n        Err(errors::StorageError::NotImplemented(\"update_api_key\".to_string()).into())\n    }\n\n    async fn revoke_api_key(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        key_id: &common_utils::id_type::ApiKeyId,\n    ) -> CustomResult<bool, errors::StorageError> {\n        let mut locked_api_keys = self.api_keys.lock().await;\n        let index = locked_api_keys\n            .iter()\n            .position(|k| k.key_id == key_id && k.merchant_id == merchant_id)\n            .ok_or(errors::StorageError::ValueNotFound(format!(\n                \"ApiKey of {} not found\",\n                key_id.get_string_repr()\n            ))))?;\n\n        let key = locked_api_keys.remove(index);\n        Ok(key.is_revoke())\n    }\n\n    async fn find_api_key_by_merchant_id_key_id_optional(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        key_id: &common_utils::id_type::ApiKeyId,\n    ) -> CustomResult<Option<storage::ApiKey>, errors::StorageError> {\n        let mut locked_api_keys = self.api_keys.lock().await;\n        let index = locked_api_keys\n            .iter()\n            .position(|k| k.key_id == key_id && k.merchant_id == merchant_id)\n            .ok_or(errors::StorageError::ValueNotFound(format!(\n                \"ApiKey of {} not found\",\n                key_id.get_string_repr()\n            ))))?;\n\n        Ok(Some(locked_api_keys.remove(index)))\n    }\n\n    async fn find_api_key_by_hash_optional(\n        &self,\n        hashed_api_key: storage::HashedApiKey,\n    ) -> CustomResult<Option<storage::ApiKey>, errors::StorageError> {\n        let mut locked_api_keys = self.api_keys.lock().await;\n        let index = locked_api_keys\n            .iter()\n            .position(|k| k.hashed_api_key == hashed_api_key)\n            .ok_or(errors::StorageError::ValueNotFound(format!(\n                \"ApiKey of {} not found\",\n                hashed_api_key.get_string_repr()\n            ))))?;\n\n        Ok(Some(locked_api_keys.remove(index)))\n    }\n\n    async fn list_api_keys_by_merchant_id(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        limit: Option<i64>,\n        offset: Option<i64>,\n    ) -> CustomResult<Vec<storage::ApiKey>, errors::StorageError> {\n        let mut locked_api_keys = self.api_keys.lock().await;\n        let filtered_api_keys = locked_api_keys\n            .iter()\n            .filter(|k| k.merchant_id == merchant_id)\n            .collect::<Vec<_>>();\n        let start = offset.unwrap_or(0);\n        let end = start + limit.unwrap_or(100);\n        Ok(filtered_api_keys[start..end].to_vec())\n    }\n}\n#[cfg(feature = \"v1\")]\n#[async_trait::async_trait]\nimpl ApiKeyInterface for super::MockDbV1 {\n    #[instrument(skip_all)]\n    async fn insert_api_key(\n        &self,\n        api_key: storage::ApiKeyNew,\n    ) -> CustomResult<storage::ApiKey, errors::StorageError> {\n        let mut locked_api_keys = self.api_keys.lock().await;\n        \/\/ don't allow duplicate key_ids, a those would be a unique constraint violation in the\n        \/\/ real db as it is used as the primary key\n        if locked_api_keys.iter().any(|k| k.key_id == api_key.key_id) {\n            Err(errors::StorageError::MockDbError)?;\n        }\n        let stored_key = storage::ApiKey {\n            key_id: api_key.key_id,\n            merchant_id: api_key.merchant_id,\n            name: api_key.name,\n            description: api_key.description,\n            hashed_api_key: api_key.hashed_api_key,\n            prefix: api_key.prefix,\n            created_at: api_key.created_at,\n            expires_at: api_key.expires_at,\n            last_used: api_key.last_used,\n        };\n        locked_api_keys.push(stored_key.clone());\n\n        Ok(stored_key)\n    }\n\n    #[instrument(skip_all)]\n    async fn update_api_key(\n        &self,\n        merchant_id: common_utils::id_type::MerchantId,\n        key_id: common_utils::id_type::ApiKeyId,\n        api_key: storage::ApiKeyUpdate,\n    ) -> CustomResult<storage::ApiKey, errors::StorageError> { \/\/ TODO: implement\n        Err(errors::StorageError::NotImplemented(\"update_api_key\".to_string()).into())\n    }\n\n    #[instrument(skip_all)]\n    async fn revoke_api_key(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        key_id: &common_utils::id_type::ApiKeyId,\n    ) -> CustomResult<bool, errors::StorageError> {\n        let mut locked_api","",""],"best_token_recall":0.7791164659,"best_bleu":9.7022710995,"best_rougeL":18.3161004431,"exact_match_any":0},{"file":"crates\/router\/src\/core\/mandate\/utils.rs","mask_idx":0,"target_len":2626,"prompt_snippet":"use std::marker::PhantomData;\n\nuse common_utils::{errors::CustomResult, ext_traits::ValueExt};\nuse diesel_models::Mandate;\nuse error_stack::ResultExt;\n\nuse crate::{\n    core::{errors, payments::helpers},\n    types::{self, domain, PaymentAddress},\n    SessionState,\n};\n\nconst IRRELEVANT_ATTEMPT_ID_IN_MANDATE_REVOKE_FLOW: &str =\n    \"irrelevant_attempt_id_in_mandate_revoke_flow\";\n\nconst IRRELEVANT_CO...","target_snippet":"\n    let auth_type: types::ConnectorAuthType = merchant_connector_account\n        .get_connector_account_details()\n        .parse_value(\"ConnectorAuthType\")\n        .change_context(errors::ApiErrorResponse::InternalServerError)?;\n    let router_data = types::RouterData {\n        flow: PhantomData,\n        merchant_id: merchant_account.get_id().clone(),\n        customer_id: Some(mandate.customer_id...","generations":[" \/\/ TODO: Remove `types::MandateRevokeRouterData` and use `types::PaymentsAuthorizeRouterData` instead\n    let mut router_data = types::MandateRevokeRouterData::new(\n        state,\n        merchant_account,\n        merchant_connector_account,\n        mandate,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n       ","",""],"best_token_recall":0.4456521739,"best_bleu":3.573275715,"best_rougeL":12.7035830619,"exact_match_any":0},{"file":"crates\/analytics\/src\/errors.rs","mask_idx":0,"target_len":855,"prompt_snippet":"use api_models::errors::types::{ApiError, ApiErrorResponse};\nuse common_utils::errors::{CustomResult, ErrorSwitch};\n\npub type AnalyticsResult<T> = CustomResult<T, AnalyticsError>;\n\n#[derive(Debug, Clone, serde::Serialize, thiserror::Error)]\npub enum AnalyticsError {\n    #[allow(dead_code)]\n    #[error(\"Not implemented: {0}\")]\n    NotImplemented(&'static str),\n    #[error(\"Unknown Analytics Error\")...","target_snippet":"\n        match self {\n            Self::NotImplemented(feature) => ApiErrorResponse::NotImplemented(ApiError::new(\n                \"IR\",\n                0,\n                format!(\"{feature} is not implemented.\"),\n                None,\n            )),\n            Self::UnknownError => ApiErrorResponse::InternalServerError(ApiError::new(\n                \"HE\",\n                0,\n                \"Som...","generations":[" match self {\n        Self::NotImplemented(feature) => ApiErrorResponse::NotImplemented(ApiErrorResponse::NotImplemented {\n            message: feature.to_string(),\n        }),\n        Self::UnknownError => ApiErrorResponse::InternalServerError(ApiErrorResponse::InternalServerError {\n            message: \"Something went wrong\".to_string(),\n        }),\n        Self::AccessForbiddenError => ApiErrorResponse::InternalServerError(ApiErrorResponse::InternalServerError {\n            message: \"Something went wrong\".to_string(),\n        }),\n        Self::ForexFetchFailed => ApiErrorResponse::InternalServerError(ApiErrorResponse::InternalServerError {\n            message: \"Something went wrong\".to_string(),\n        }),\n    }\n}\n\nimpl From<AnalyticsError> for ApiErrorResponse {\n    fn from(error: AnalyticsError) -> Self {\n        match error {\n            AnalyticsError::NotImplemented(feature) => Self::NotImplemented(ApiErrorResponse::NotImplemented {\n                message: feature.to_string(),\n            }),\n            AnalyticsError::UnknownError => Self::InternalServerError(ApiErrorResponse::InternalServerError {\n                message: \"Something went wrong\".to_string(),\n            }),\n            AnalyticsError::AccessForbiddenError => Self::InternalServerError(ApiErrorResponse::InternalServerError {\n                message: \"Something went wrong\".to_string(),\n            }),\n            AnalyticsError::ForexFetchFailed => Self::InternalServerError(ApiErrorResponse::InternalServerError {\n                message: \"Something went wrong\".to_string(),\n            }),\n        }\n    }\n}\n\nimpl From<AnalyticsError> for ApiError {\n    fn from(error: AnalyticsError) -> Self {\n        match error {\n            AnalyticsError::NotImplemented(feature) => Self::NotImplemented(ApiError::NotImplemented(ApiError::NotImplemented {\n                message: feature.to_string(),\n            })),\n            AnalyticsError::UnknownError => Self::InternalServerError(ApiError::InternalServerError(ApiError::InternalServerError {\n                message: \"Something went wrong\".to_string(),\n            })),\n            AnalyticsError::AccessForbiddenError => Self::InternalServerError(ApiError::InternalServerError(ApiError::InternalServerError {\n                message: \"Something went wrong\".to_string(),\n            })),\n            AnalyticsError::ForexFetchFailed => Self::InternalServerError(ApiError::InternalServerError(ApiError::InternalServerError {\n                message: \"Something went wrong\".to_string(),\n            })),\n        }\n    }\n}\n#[cfg(feature = \"v1\")]\nimpl AnalyticsError {\n    pub fn to_http_code(&self) -> u16 {\n        match self {\n            Self::NotImplemented(feature) => 501,\n            Self::UnknownError => 500,\n            Self::AccessForbiddenError => 500,\n            Self::ForexFetchFailed => 500,\n        }\n    }\n}\n#[cfg(feature = \"v2\")]\nimpl AnalyticsError {\n    pub fn to_http_code(&self) -> u16 {\n        match self {\n            Self::NotImplemented(feature) => 501,\n            Self::UnknownError => 500,\n            Self::AccessForbiddenError => 500,\n            Self::ForexFetchFailed => 500,\n        }\n    }\n}\n#[cfg(feature = \"v1\")]\nimpl AnalyticsError {\n    pub fn to_http_code(&self) -> u16 {\n        match self {\n            Self::NotImplemented(feature) => 501,\n            Self::UnknownError => 500,\n            Self::AccessForbiddenError => 500,\n            Self::ForexFetchFailed => 500,\n        }\n    }\n}\n#[cfg(feature = \"v2\")]\nimpl AnalyticsError {\n    pub fn to_http_code(&self) -> u16 {\n        match self {\n            Self::NotImplemented(feature) => 501,\n            Self::UnknownError => 500,\n            Self::AccessForbiddenError => 500,\n            Self::ForexFetchFailed => 500,\n        }\n    }\n}\n#[cfg(feature = \"v1\")]\nimpl AnalyticsError {\n    pub fn to_http_code(&self) -> u16 {\n        match self {\n            Self::NotImplemented(feature) => 501,\n            Self::UnknownError => 500,\n            Self::AccessForbiddenError => 500,\n            Self::ForexFetchFailed => 500,\n        }\n    }\n}\n#[cfg(feature = \"v2\")]\nimpl AnalyticsError {\n    pub fn to_http_code(&self) -> u16 {\n        match self {\n            Self::NotImplemented(feature) => 501,\n            Self::UnknownError => 500,\n            Self::AccessForbiddenError => 500,\n            Self::ForexFetchFailed => 500,\n        }\n    }\n}\n#[cfg(feature = \"v1\")]\nimpl AnalyticsError {\n    pub fn to_http_code(&self) -> u16 {\n        match self {\n            Self::NotImplemented(feature) => 501,\n            Self::UnknownError => 500,\n            Self::AccessForbiddenError => 500,\n            Self::ForexFetchFailed => 500,\n        }\n    }\n}\n#[cfg(feature = \"v2\")]\n","",""],"best_token_recall":0.7105263158,"best_bleu":7.3189317113,"best_rougeL":11.3744075829,"exact_match_any":0},{"file":"crates\/external_services\/src\/email\/no_email.rs","mask_idx":0,"target_len":21,"prompt_snippet":"use common_utils::{errors::CustomResult, pii};\nuse router_env::logger;\n\nuse crate::email::{EmailClient, EmailError, EmailResult, IntermediateString};\n\n\/\/\/ Client when email support is disabled\n#[derive(Debug, Clone, Default, serde::Deserialize)]\npub struct NoEmailClient {}\n\nimpl NoEmailClient {\n    \/\/\/ Constructs a new client when email is disabled\n    pub async fn create() -> Self {","target_snippet":"\n        Self {}\n    ","generations":[" Self }\n}\n\nimpl EmailClient for NoEmailClient {\n    fn send_email(\n        &self,\n        recipient: pii::Email,\n        subject: String,\n        body: IntermediateString,\n        _header: Option<pii::Email>,\n        _cc: Option<pii::Email>,\n        _bcc: Option<pii::Email>,\n        _email_type: Option<pii::EmailType>,\n        _email_category: Option<pii::EmailCategory>,\n        _email_sub_category: Option<pii::EmailSubCategory>,\n        _email_priority: Option<pii::EmailPriority>,\n        _email_client: Option<pii::EmailClient>,\n        _email_server: Option<pii::EmailServer>,\n        _email_template: Option<pii::EmailTemplate>,\n        _email_template_data: Option<pii::EmailTemplateData>,\n        _email_metadata: Option<pii::EmailMetadata>,\n        _email_event_type: Option<pii::EmailEventType>,\n        _email_event_category: Option<pii::EmailEventCategory>,\n        _email_event_sub_category: Option<pii::EmailEventSubCategory>,\n        _email_event_status: Option<pii::EmailEventStatus>,\n        _email_event_reason: Option<pii::EmailEventReason>,\n        _email_event_error_message: Option<String>,\n        _email_event_error_code: Option<String>,\n        _email_event_error_type: Option<String>,\n        _email_event_error_reason: Option<String>,\n        _email_event_error_message_with_code: Option<String>,\n        _email_event_error_message_with_code_and_reason: Option<String>,\n        _email_event_error_message_with_code_and_reason_and_reason_code: Option<String>,\n        _email_event_error_message_with_code_and_reason_and_reason_code_and_reason_message: Option<String>,\n        _email_event_error_message_with_code_and_reason_and_reason_code_and_reason_message_and_reason_code: Option<String>,\n        _email_event_error_message_with_code_and_reason_and_reason_code_and_reason_message_and_reason_code_and_reason_message: Option<String>,\n        _email_event_error_message_with_code_and_reason_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code: Option<String>,\n        _email_event_error_message_with_code_and_reason_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code_and_reason_message: Option<String>,\n        _email_event_error_message_with_code_and_reason_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code: Option<String>,\n        _email_event_error_message_with_code_and_reason_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code: Option<String>,\n        _email_event_error_message_with_code_and_reason_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code: Option<String>,\n        _email_event_error_message_with_code_and_reason_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code: Option<String>,\n        _email_event_error_message_with_code_and_reason_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code: Option<String>,\n        _email_event_error_message_with_code_and_reason_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code: Option<String>,\n        _email_event_error_message_with_code_and_reason_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code: Option<String>,\n        _email_event_error_message_with_code_and_reason_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code: Option<String>,\n        _email_event_error_message_with_code_and_reason_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code: Option<String>,\n        _email_event_error_message_with_code_and_reason_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code: Option<String>,\n        _email_event_error_message_with_code_and_reason_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code: Option<String>,\n        _email_event_error_message_with_code_and_reason_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code: Option<String>,\n        _email_event_error_message_with_code_and_reason_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code: Option<String>,\n        _email_event_error_message_with_code_and_reason_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code: Option<String>,\n        _email_event_error_message_with_code_and_reason_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code: Option<String>,\n        _email_event_error_message_with_code_and_reason_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code: Option<String>,\n","",""],"best_token_recall":0.4,"best_bleu":0.0283980798,"best_rougeL":0.2604166667,"exact_match_any":0},{"file":"crates\/external_services\/src\/email\/no_email.rs","mask_idx":1,"target_len":50,"prompt_snippet":"use common_utils::{errors::CustomResult, pii};\nuse router_env::logger;\n\nuse crate::email::{EmailClient, EmailError, EmailResult, IntermediateString};\n\n\/\/\/ Client when email support is disabled\n#[derive(Debug, Clone, Default, serde::Deserialize)]\npub struct NoEmailClient {}\n\nimpl NoEmailClient {\n    \/\/\/ Constructs a new client when email is disabled\n    pub async fn create() -> Self {\n        Self ...","target_snippet":"\n        Ok(intermediate_string.into_inner())\n    ","generations":[" logger::info!(email_client=?self); Ok(intermediate_string.into_inner()) }\n    async fn send_email(\n        &self,\n        recipient: pii::Email,\n        subject: String,\n        body: Self::RichText,\n    ) -> EmailResult<()> { Ok(()) }\n    async fn send_html_email(\n        &self,\n        recipient: pii::Email,\n        subject: String,\n        body: Self::RichText,\n    ) -> EmailResult<()> { Ok(()) }\n    async fn send_html_email_with_link(\n        &self,\n        recipient: pii::Email,\n        subject: String,\n        body: Self::RichText,\n    ) -> EmailResult<()> { Ok(()) }\n    async fn send_html_email_with_link_and_logo(\n        &self,\n        recipient: pii::Email,\n        subject: String,\n        body: Self::RichText,\n    ) -> EmailResult<()> { Ok(()) }\n    async fn send_html_email_with_logo(\n        &self,\n        recipient: pii::Email,\n        subject: String,\n        body: Self::RichText,\n    ) -> EmailResult<()> { Ok(()) }\n    async fn send_html_email_with_logo_and_link(\n        &self,\n        recipient: pii::Email,\n        subject: String,\n        body: Self::RichText,\n    ) -> EmailResult<()> { Ok(()) }\n    async fn send_html_email_with_logo_and_link_and_button(\n        &self,\n        recipient: pii::Email,\n        subject: String,\n        body: Self::RichText,\n    ) -> EmailResult<()> { Ok(()) }\n    async fn send_html_email_with_logo_and_link_and_button_and_link_text(\n        &self,\n        recipient: pii::Email,\n        subject: String,\n        body: Self::RichText,\n    ) -> EmailResult<()> { Ok(()) }\n    async fn send_html_email_with_logo_and_link_and_button_and_link_text_and_link_color(\n        &self,\n        recipient: pii::Email,\n        subject: String,\n        body: Self::RichText,\n    ) -> EmailResult<()> { Ok(()) }\n    async fn send_html_email_with_logo_and_link_and_button_and_link_text_and_link_color_and_link_hover_color(\n        &self,\n        recipient: pii::Email,\n        subject: String,\n        body: Self::RichText,\n    ) -> EmailResult<()> { Ok(()) }\n    async fn send_html_email_with_logo_and_link_and_button_and_link_text_and_link_color_and_link_hover_color_and_link_border_color(\n        &self,\n        recipient: pii::Email,\n        subject: String,\n        body: Self::RichText,\n    ) -> EmailResult<()> { Ok(()) }\n    async fn send_html_email_with_logo_and_link_and_button_and_link_text_and_link_color_and_link_hover_color_and_link_border_color_and_link_radius(\n        &self,\n        recipient: pii::Email,\n        subject: String,\n        body: Self::RichText,\n    ) -> EmailResult<()> { Ok(()) }\n    async fn send_html_email_with_logo_and_link_and_button_and_link_text_and_link_color_and_link_hover_color_and_link_border_color_and_link_radius_and_link_font_size(\n        &self,\n        recipient: pii::Email,\n        subject: String,\n        body: Self::RichText,\n    ) -> EmailResult<()> { Ok(()) }\n    async fn send_html_email_with_logo_and_link_and_button_and_link_text_and_link_color_and_link_hover_color_and_link_border_color_and_link_radius_and_link_font_size_and_link_font_family(\n        &self,\n        recipient: pii::Email,\n        subject: String,\n        body: Self::RichText,\n    ) -> EmailResult<()> { Ok(()) }\n    async fn send_html_email_with_logo_and_link_and_button_and_link_text_and_link_color_and_link_hover_color_and_link_border_color_and_link_radius_and_link_font_size_and_link_font_family_and_link_font_weight(\n        &self,\n        recipient: pii::Email,\n        subject: String,\n        body: Self::RichText,\n    ) -> EmailResult<()> { Ok(()) }\n    async fn send_html_email_with_logo_and_link_and_button_and_link_text_and_link_color_and_link_hover_color_and_link_border_color_and_link_radius_and_link_font_size_and_link_font_family_and_link_font_weight_and_link_font_style(\n        &self,\n        recipient: pii::Email,\n        subject: String,\n        body: Self::RichText,\n    ) -> EmailResult<()> { Ok(()) }\n    async fn send_html_email_with_logo_and_link_and_button_and_link_text_and_link_color_and_link_hover_color_and_link_border_color_and_link_radius_and_link_font_size_and_link_font_family_and_link_font_weight_and_link_font_style_and_link_font_variant(\n        &self,\n        recipient: pii::Email,\n        subject: String,\n        body: Self::RichText,\n    ) -> EmailResult<()> { Ok(()) }\n    async fn send_html_email_with_logo_and_link_and_button_and_link_text_and_link_color_and_link_hover","",""],"best_token_recall":0.7,"best_bleu":0.7707707917,"best_rougeL":1.7271157168,"exact_match_any":0},{"file":"crates\/external_services\/src\/email\/no_email.rs","mask_idx":2,"target_len":155,"prompt_snippet":"use common_utils::{errors::CustomResult, pii};\nuse router_env::logger;\n\nuse crate::email::{EmailClient, EmailError, EmailResult, IntermediateString};\n\n\/\/\/ Client when email support is disabled\n#[derive(Debug, Clone, Default, serde::Deserialize)]\npub struct NoEmailClient {}\n\nimpl NoEmailClient {\n    \/\/\/ Constructs a new client when email is disabled\n    pub async fn create() -> Self {\n        Self ...","target_snippet":"\n        logger::info!(\"Email not sent as email support is disabled, please enable any of the supported email clients to send emails\");\n        Ok(())\n    ","generations":[" logger::info!(\"Email client not configured, skipping email sending\") }\n}\n#[async_trait::async_trait]\nimpl super::EmailClient for NoEmailClient {\n    async fn send_email(\n        &self,\n        _recipient: pii::Email,\n        _subject: String,\n        _body: Self::RichText,\n        _proxy_url: Option<&String>,\n    ) -> EmailResult<()> { logger::info!(\"Email client not configured, skipping email sending\") }\n}\n#[async_trait::async_trait]\nimpl super::EmailClient for NoEmailClient {\n    async fn send_email(\n        &self,\n        _recipient: pii::Email,\n        _subject: String,\n        _body: Self::RichText,\n        _proxy_url: Option<&String>,\n    ) -> EmailResult<()> { logger::info!(\"Email client not configured, skipping email sending\") }\n}\n#[async_trait::async_trait]\nimpl super::EmailClient for NoEmailClient {\n    async fn send_email(\n        &self,\n        _recipient: pii::Email,\n        _subject: String,\n        _body: Self::RichText,\n        _proxy_url: Option<&String>,\n    ) -> EmailResult<()> { logger::info!(\"Email client not configured, skipping email sending\") }\n}\n#[async_trait::async_trait]\nimpl super::EmailClient for NoEmailClient {\n    async fn send_email(\n        &self,\n        _recipient: pii::Email,\n        _subject: String,\n        _body: Self::RichText,\n        _proxy_url: Option<&String>,\n    ) -> EmailResult<()> { logger::info!(\"Email client not configured, skipping email sending\") }\n}\n#[async_trait::async_trait]\nimpl super::EmailClient for NoEmailClient {\n    async fn send_email(\n        &self,\n        _recipient: pii::Email,\n        _subject: String,\n        _body: Self::RichText,\n        _proxy_url: Option<&String>,\n    ) -> EmailResult<()> { logger::info!(\"Email client not configured, skipping email sending\") }\n}\n#[async_trait::async_trait]\nimpl super::EmailClient for NoEmailClient {\n    async fn send_email(\n        &self,\n        _recipient: pii::Email,\n        _subject: String,\n        _body: Self::RichText,\n        _proxy_url: Option<&String>,\n    ) -> EmailResult<()> { logger::info!(\"Email client not configured, skipping email sending\") }\n}\n#[async_trait::async_trait]\nimpl super::EmailClient for NoEmailClient {\n    async fn send_email(\n        &self,\n        _recipient: pii::Email,\n        _subject: String,\n        _body: Self::RichText,\n        _proxy_url: Option<&String>,\n    ) -> EmailResult<()> { logger::info!(\"Email client not configured, skipping email sending\") }\n}\n#[async_trait::async_trait]\nimpl super::EmailClient for NoEmailClient {\n    async fn send_email(\n        &self,\n        _recipient: pii::Email,\n        _subject: String,\n        _body: Self::RichText,\n        _proxy_url: Option<&String>,\n    ) -> EmailResult<()> { logger::info!(\"Email client not configured, skipping email sending\") }\n}\n#[async_trait::async_trait]\nimpl super::EmailClient for NoEmailClient {\n    async fn send_email(\n        &self,\n        _recipient: pii::Email,\n        _subject: String,\n        _body: Self::RichText,\n        _proxy_url: Option<&String>,\n    ) -> EmailResult<()> { logger::info!(\"Email client not configured, skipping email sending\") }\n}\n#[async_trait::async_trait]\nimpl super::EmailClient for NoEmailClient {\n    async fn send_email(\n        &self,\n        _recipient: pii::Email,\n        _subject: String,\n        _body: Self::RichText,\n        _proxy_url: Option<&String>,\n    ) -> EmailResult<()> { logger::info!(\"Email client not configured, skipping email sending\") }\n}\n#[async_trait::async_trait]\nimpl super::EmailClient for NoEmailClient {\n    async fn send_email(\n        &self,\n        _recipient: pii::Email,\n        _subject: String,\n        _body: Self::RichText,\n        _proxy_url: Option<&String>,\n    ) -> EmailResult<()> { logger::info!(\"Email client not configured, skipping email sending\") }\n}\n#[async_trait::async_trait]\nimpl super::EmailClient for NoEmailClient {\n    async fn send_email(\n        &self,\n        _recipient: pii::Email,\n        _subject: String,\n        _body: Self::RichText,\n        _proxy_url: Option<&String>,\n    ) -> EmailResult<()> { logger::info!(\"Email client not configured, skipping email sending\") }\n}\n#[async_trait::async_trait]\nimpl super::EmailClient for NoEmailClient {\n    async fn send_email(\n        &self,\n        _recipient: pii::Email,\n        _","",""],"best_token_recall":0.3870967742,"best_bleu":0.7620983099,"best_rougeL":2.9166666667,"exact_match_any":0},{"file":"crates\/common_utils\/src\/id_type\/global_id\/payment_methods.rs","mask_idx":0,"target_len":122,"prompt_snippet":"use error_stack::ResultExt;\n\nuse crate::{\n    errors::CustomResult,\n    id_type::global_id::{CellId, GlobalEntity, GlobalId},\n};\n\n\/\/\/ A global id that can be used to identify a payment method\n#[derive(\n    Debug,\n    Clone,\n    Hash,\n    PartialEq,\n    Eq,\n    serde::Serialize,\n    serde::Deserialize,\n    diesel::expression::AsExpression,\n)]\n#[diesel(sql_type = diesel::sql_types::Text)]\npub struct...","target_snippet":"\n        let global_id = GlobalId::generate(cell_id, GlobalEntity::PaymentMethodSession);\n        Ok(Self(global_id))\n    ","generations":[" Self::new(cell_id) }\n\n    \/\/\/ Get the cell id from a GlobalPaymentMethodSessionId\n    pub fn get_cell_id(&self) -> &CellId {\n        &self.0.get_cell_id()\n    }\n}\n\nimpl GlobalPaymentMethodId {\n    \/\/\/ Create a new GlobalPaymentMethodId from cell id information\n    pub fn generate(cell_id: &CellId) -> error_stack::Result<Self, GlobalPaymentMethodIdError> {\n        Self::new(cell_id)\n    }\n\n    \/\/\/ Get the cell id from a GlobalPaymentMethodId\n    pub fn get_cell_id(&self) -> &CellId {\n        &self.0.get_cell_id()\n    }\n}\n\nimpl GlobalPaymentMethodId {\n    \/\/\/ Get the global id from a GlobalPaymentMethodId\n    pub fn get_global_id(&self) -> &GlobalId {\n        &self.0\n    }\n}\n\nimpl GlobalPaymentMethodSessionId {\n    \/\/\/ Get the global id from a GlobalPaymentMethodSessionId\n    pub fn get_global_id(&self) -> &GlobalId {\n        &self.0\n    }\n}\n\nimpl GlobalPaymentMethodId {\n    \/\/\/ Get the global id from a GlobalPaymentMethodId\n    pub fn get_global_id(&self) -> &GlobalId {\n        &self.0\n    }\n}\n\nimpl GlobalPaymentMethodId {\n    \/\/\/ Get the global id from a GlobalPaymentMethodId\n    pub fn get_global_id(&self) -> &GlobalId {\n        &self.0\n    }\n}\n\nimpl GlobalPaymentMethodId {\n    \/\/\/ Get the global id from a GlobalPaymentMethodId\n    pub fn get_global_id(&self) -> &GlobalId {\n        &self.0\n    }\n}\n\nimpl GlobalPaymentMethodId {\n    \/\/\/ Get the global id from a GlobalPaymentMethodId\n    pub fn get_global_id(&self) -> &GlobalId {\n        &self.0\n    }\n}\n\nimpl GlobalPaymentMethodId {\n    \/\/\/ Get the global id from a GlobalPaymentMethodId\n    pub fn get_global_id(&self) -> &GlobalId {\n        &self.0\n    }\n}\n\nimpl GlobalPaymentMethodId {\n    \/\/\/ Get the global id from a GlobalPaymentMethodId\n    pub fn get_global_id(&self) -> &GlobalId {\n        &self.0\n    }\n}\n\nimpl GlobalPaymentMethodId {\n    \/\/\/ Get the global id from a GlobalPaymentMethodId\n    pub fn get_global_id(&self) -> &GlobalId {\n        &self.0\n    }\n}\n\nimpl GlobalPaymentMethodId {\n    \/\/\/ Get the global id from a GlobalPaymentMethodId\n    pub fn get_global_id(&self) -> &GlobalId {\n        &self.0\n    }\n}\n\nimpl GlobalPaymentMethodId {\n    \/\/\/ Get the global id from a GlobalPaymentMethodId\n    pub fn get_global_id(&self) -> &GlobalId {\n        &self.0\n    }\n}\n\nimpl GlobalPaymentMethodId {\n    \/\/\/ Get the global id from a GlobalPaymentMethodId\n    pub fn get_global_id(&self) -> &GlobalId {\n        &self.0\n    }\n}\n\nimpl GlobalPaymentMethodId {\n    \/\/\/ Get the global id from a GlobalPaymentMethodId\n    pub fn get_global_id(&self) -> &GlobalId {\n        &self.0\n    }\n}\n\nimpl GlobalPaymentMethodId {\n    \/\/\/ Get the global id from a GlobalPaymentMethodId\n    pub fn get_global_id(&self) -> &GlobalId {\n        &self.0\n    }\n}\n\nimpl GlobalPaymentMethodId {\n    \/\/\/ Get the global id from a GlobalPaymentMethodId\n    pub fn get_global_id(&self) -> &GlobalId {\n        &self.0\n    }\n}\n\nimpl GlobalPaymentMethodId {\n    \/\/\/ Get the global id from a GlobalPaymentMethodId\n    pub fn get_global_id(&self) -> &GlobalId {\n        &self.0\n    }\n}\n\nimpl GlobalPaymentMethodId {\n    \/\/\/ Get the global id from a GlobalPaymentMethodId\n    pub fn get_global_id(&self) -> &GlobalId {\n        &self.0\n    }\n}\n\nimpl GlobalPaymentMethodId {\n    \/\/\/ Get the global id from a GlobalPaymentMethodId\n    pub fn get_global_id(&self) -> &GlobalId {\n        &self.0\n    }\n}\n\nimpl GlobalPaymentMethodId {\n    \/\/\/ Get the global id from a GlobalPaymentMethodId\n    pub fn get_global_id(&self) -> &GlobalId {\n        &self.0\n    }\n}\n\nimpl GlobalPaymentMethodId {\n    \/\/\/ Get the global id from a GlobalPaymentMethodId\n    pub fn get_global_id(&self) -> &GlobalId {\n        &self.0\n    }\n}\n\nimpl GlobalPaymentMethodId {\n    \/\/\/ Get the global id from a GlobalPaymentMethodId\n    pub fn get_global_id(&self) -> &GlobalId {\n        &self.0\n    }\n}\n\n","",""],"best_token_recall":0.6296296296,"best_bleu":0.8507664649,"best_rougeL":3.056768559,"exact_match_any":0},{"file":"crates\/common_utils\/src\/id_type\/global_id\/payment_methods.rs","mask_idx":1,"target_len":38,"prompt_snippet":"use error_stack::ResultExt;\n\nuse crate::{\n    errors::CustomResult,\n    id_type::global_id::{CellId, GlobalEntity, GlobalId},\n};\n\n\/\/\/ A global id that can be used to identify a payment method\n#[derive(\n    Debug,\n    Clone,\n    Hash,\n    PartialEq,\n    Eq,\n    serde::Serialize,\n    serde::Deserialize,\n    diesel::expression::AsExpression,\n)]\n#[diesel(sql_type = diesel::sql_types::Text)]\npub struct...","target_snippet":"\n        self.0.get_string_repr()\n    ","generations":[" self.0.get_string_repr() }\n\n    \/\/\/ Get the cell id from the id\n    pub fn get_cell_id(&self) -> error_stack::Result<&CellId, GlobalPaymentMethodSessionIdError> {\n        self.0.get_cell_id()\n    }\n}\n\nimpl GlobalPaymentMethodId {\n    \/\/\/ Create a new GlobalPaymentMethodId from cell id information\n    pub fn generate(cell_id: &CellId) -> error_stack::Result<Self, GlobalPaymentMethodIdError> {\n        let global_id = GlobalId::generate(cell_id, GlobalEntity::PaymentMethod);\n        Ok(Self(global_id))\n    }\n\n    \/\/\/ Get the string representation of the id\n    pub fn get_string_repr(&self) -> &str { self.0.get_string_repr() }\n\n    \/\/\/ Get the cell id from the id\n    pub fn get_cell_id(&self) -> error_stack::Result<&CellId, GlobalPaymentMethodIdError> {\n        self.0.get_cell_id()\n    }\n}\n\nimpl From<GlobalPaymentMethodId> for String {\n    fn from(value: GlobalPaymentMethodId) -> Self {\n        value.0.get_string_repr().to_owned()\n    }\n}\n\nimpl From<GlobalPaymentMethodSessionId> for String {\n    fn from(value: GlobalPaymentMethodSessionId) -> Self {\n        value.0.get_string_repr().to_owned()\n    }\n}\n\nimpl From<GlobalPaymentMethodId> for GlobalId {\n    fn from(value: GlobalPaymentMethodId) -> Self {\n        value.0\n    }\n}\n\nimpl From<GlobalPaymentMethodSessionId> for GlobalId {\n    fn from(value: GlobalPaymentMethodSessionId) -> Self {\n        value.0\n    }\n}\n\nimpl From<GlobalPaymentMethodId> for GlobalEntity {\n    fn from(value: GlobalPaymentMethodId) -> Self {\n        GlobalEntity::PaymentMethod\n    }\n}\n\nimpl From<GlobalPaymentMethodSessionId> for GlobalEntity {\n    fn from(value: GlobalPaymentMethodSessionId) -> Self {\n        GlobalEntity::PaymentMethodSession\n    }\n}\n\nimpl From<GlobalPaymentMethodId> for GlobalPaymentMethodSessionId {\n    fn from(value: GlobalPaymentMethodId) -> Self {\n        Self::generate(&value.0.get_cell_id())\n            .change_context(GlobalPaymentMethodSessionIdError::ConstructionError)\n            .attach_printable(\"Failed to construct GlobalPaymentMethodSessionId from GlobalPaymentMethodId\")\n            .map(|session_id| session_id.0)\n            .ok()\n            .unwrap_or_default()\n    }\n}\n\nimpl From<GlobalPaymentMethodSessionId> for GlobalPaymentMethodId {\n    fn from(value: GlobalPaymentMethodSessionId) -> Self {\n        Self::generate(&value.0.get_cell_id())\n            .change_context(GlobalPaymentMethodIdError::ConstructionError)\n            .attach_printable(\"Failed to construct GlobalPaymentMethodId from GlobalPaymentMethodSessionId\")\n            .map(|payment_method_id| payment_method_id.0)\n            .ok()\n            .unwrap_or_default()\n    }\n}\n\nimpl From<GlobalPaymentMethodId> for GlobalPaymentMethodSessionId {\n    fn from(value: GlobalPaymentMethodId) -> Self {\n        Self::generate(&value.0.get_cell_id())\n            .change_context(GlobalPaymentMethodSessionIdError::ConstructionError)\n            .attach_printable(\"Failed to construct GlobalPaymentMethodSessionId from GlobalPaymentMethodId\")\n            .map(|session_id| session_id.0)\n            .ok()\n            .unwrap_or_default()\n    }\n}\n\nimpl From<GlobalPaymentMethodSessionId> for GlobalPaymentMethodId {\n    fn from(value: GlobalPaymentMethodSessionId) -> Self {\n        Self::generate(&value.0.get_cell_id())\n            .change_context(GlobalPaymentMethodIdError::ConstructionError)\n            .attach_printable(\"Failed to construct GlobalPaymentMethodId from GlobalPaymentMethodSessionId\")\n            .map(|payment_method_id| payment_method_id.0)\n            .ok()\n            .unwrap_or_default()\n    }\n}\n\nimpl From<GlobalPaymentMethodId> for GlobalPaymentMethodSessionId {\n    fn from(value: GlobalPaymentMethodId) -> Self {\n        Self::generate(&value.0.get_cell_id())\n            .change_context(GlobalPaymentMethodSessionIdError::ConstructionError)\n            .attach_printable(\"Failed to construct GlobalPaymentMethodSessionId from GlobalPaymentMethodId\")\n            .map(|session_id| session_id.0)\n            .ok()\n            .unwrap_or_default()\n    }\n}\n\nimpl From<GlobalPaymentMethodSessionId> for GlobalPaymentMethodId {\n    fn from(value: GlobalPaymentMethodSessionId) -> Self {\n        Self::generate(&value.0.get_cell_id())\n            .change_context(GlobalPaymentMethodIdError::ConstructionError)\n            .attach_printable(\"Failed to construct GlobalPaymentMethodId from GlobalPaymentMethodSessionId\")\n            .map(|payment_method_id| payment_method_id.0)\n            .ok()\n            .unwrap_or_default()\n    }\n}\n\nimpl From","",""],"best_token_recall":0.9,"best_bleu":1.0062602746,"best_rougeL":2.3094688222,"exact_match_any":0},{"file":"crates\/common_utils\/src\/id_type\/global_id\/payment_methods.rs","mask_idx":2,"target_len":74,"prompt_snippet":"use error_stack::ResultExt;\n\nuse crate::{\n    errors::CustomResult,\n    id_type::global_id::{CellId, GlobalEntity, GlobalId},\n};\n\n\/\/\/ A global id that can be used to identify a payment method\n#[derive(\n    Debug,\n    Clone,\n    Hash,\n    PartialEq,\n    Eq,\n    serde::Serialize,\n    serde::Deserialize,\n    diesel::expression::AsExpression,\n)]\n#[diesel(sql_type = diesel::sql_types::Text)]\npub struct...","target_snippet":"\n        format!(\"payment_method_session:{}\", self.get_string_repr())\n    ","generations":[" format!(\"payment_method_session_{}\", self.get_string_repr()) }\n}\n\nimpl GlobalPaymentMethodId {\n    \/\/\/ Create a new GlobalPaymentMethodId from cell id information\n    pub fn generate(cell_id: &CellId) -> error_stack::Result<Self, GlobalPaymentMethodIdError> {\n        let global_id = GlobalId::generate(cell_id, GlobalEntity::PaymentMethod);\n        Ok(Self(global_id))\n    }\n\n    \/\/\/ Get the string representation of the id\n    pub fn get_string_repr(&self) -> &str {\n        self.0.get_string_repr()\n    }\n\n    \/\/\/ Construct a redis key from the id to be stored in redis\n    pub fn get_redis_key(&self) -> String { format!(\"payment_method_{}\", self.get_string_repr()) }\n}\n\nimpl From<GlobalPaymentMethodId> for String {\n    fn from(value: GlobalPaymentMethodId) -> Self {\n        value.get_string_repr().to_string()\n    }\n}\n\nimpl From<GlobalPaymentMethodSessionId> for String {\n    fn from(value: GlobalPaymentMethodSessionId) -> Self {\n        value.get_string_repr().to_string()\n    }\n}\n\nimpl From<GlobalPaymentMethodId> for GlobalId {\n    fn from(value: GlobalPaymentMethodId) -> Self {\n        value.0\n    }\n}\n\nimpl From<GlobalPaymentMethodSessionId> for GlobalId {\n    fn from(value: GlobalPaymentMethodSessionId) -> Self {\n        value.0\n    }\n}\n\nimpl From<GlobalPaymentMethodId> for String {\n    fn from(value: GlobalPaymentMethodId) -> Self {\n        value.get_string_repr().to_string()\n    }\n}\n\nimpl From<GlobalPaymentMethodSessionId> for String {\n    fn from(value: GlobalPaymentMethodSessionId) -> Self {\n        value.get_string_repr().to_string()\n    }\n}\n#[cfg(feature = \"v1\")]\nimpl From<GlobalPaymentMethodId> for String {\n    fn from(value: GlobalPaymentMethodId) -> Self {\n        format!(\"payment_method_{}\", value.get_string_repr())\n    }\n}\n\n#[cfg(feature = \"v1\")]\nimpl From<GlobalPaymentMethodSessionId> for String {\n    fn from(value: GlobalPaymentMethodSessionId) -> Self {\n        format!(\"payment_method_session_{}\", value.get_string_repr())\n    }\n}\n#[cfg(feature = \"v2\")]\nimpl From<GlobalPaymentMethodId> for String {\n    fn from(value: GlobalPaymentMethodId) -> Self {\n        format!(\"payment_method_{}\", value.get_string_repr())\n    }\n}\n\n#[cfg(feature = \"v2\")]\nimpl From<GlobalPaymentMethodSessionId> for String {\n    fn from(value: GlobalPaymentMethodSessionId) -> Self {\n        format!(\"payment_method_session_{}\", value.get_string_repr())\n    }\n}\n\nimpl From<GlobalPaymentMethodId> for String {\n    fn from(value: GlobalPaymentMethodId) -> Self {\n        format!(\"payment_method_{}\", value.get_string_repr())\n    }\n}\n\n#[cfg(feature = \"v1\")]\nimpl From<GlobalPaymentMethodSessionId> for String {\n    fn from(value: GlobalPaymentMethodSessionId) -> Self {\n        format!(\"payment_method_session_{}\", value.get_string_repr())\n    }\n}\n\n#[cfg(feature = \"v2\")]\nimpl From<GlobalPaymentMethodSessionId> for String {\n    fn from(value: GlobalPaymentMethodSessionId) -> Self {\n        format!(\"payment_method_session_{}\", value.get_string_repr())\n    }\n}\n\nimpl From<GlobalPaymentMethodId> for String {\n    fn from(value: GlobalPaymentMethodId) -> Self {\n        format!(\"payment_method_{}\", value.get_string_repr())\n    }\n}\n\n#[cfg(feature = \"v1\")]\nimpl From<GlobalPaymentMethodSessionId> for String {\n    fn from(value: GlobalPaymentMethodSessionId) -> Self {\n        format!(\"payment_method_session_{}\", value.get_string_repr())\n    }\n}\n\n#[cfg(feature = \"v2\")]\nimpl From<GlobalPaymentMethodSessionId> for String {\n    fn from(value: GlobalPaymentMethodSessionId) -> Self {\n        format!(\"payment_method_session_{}\", value.get_string_repr())\n    }\n}\n\nimpl From<GlobalPaymentMethodId> for String {\n    fn from(value: GlobalPaymentMethodId) -> Self {\n        format!(\"payment_method_{}\", value.get_string_repr())\n    }\n}\n\n#[cfg(feature = \"v1\")]\nimpl From<GlobalPaymentMethodSessionId> for String {\n    fn from(value: GlobalPaymentMethodSessionId) -> Self {\n        format!(\"payment_method_session_{}\", value.get_string_repr())\n    }\n}\n\n#[cfg(feature = \"v2\")]\nimpl From<GlobalPaymentMethodSessionId> for String {\n    fn from(value: GlobalPaymentMethodSessionId) -> Self {\n        format!(\"payment_method_session_{}\", value.get_string_repr())\n    }\n}\n\nimpl From<GlobalPaymentMethodId> for String {\n    fn from(value: GlobalPaymentMethodId) -> Self {\n        format!(\"payment_method_{}\", value.get_string_repr())\n    }\n}\n\n","",""],"best_token_recall":0.9333333333,"best_bleu":1.816978297,"best_rougeL":3.48583878,"exact_match_any":0},{"file":"crates\/router\/src\/core\/payment_methods\/cards.rs","mask_idx":0,"target_len":2974,"prompt_snippet":"use std::{\n    collections::{HashMap, HashSet},\n    fmt::Debug,\n    str::FromStr,\n};\n\n#[cfg(all(\n    any(feature = \"v1\", feature = \"v2\"),\n    not(feature = \"payment_methods_v2\")\n))]\nuse api_models::admin::PaymentMethodsEnabled;\nuse api_models::{\n    enums as api_enums,\n    payment_methods::{\n        BankAccountTokenData, Card, CardDetailUpdate, CardDetailsPaymentMethod, CardNetworkTypes,\n        C...","target_snippet":"\n    let db = &*state.store;\n    let customer = db\n        .find_customer_by_customer_id_merchant_id(\n            &state.into(),\n            customer_id,\n            merchant_id,\n            key_store,\n            storage_scheme,\n        )\n        .await\n        .to_not_found_response(errors::ApiErrorResponse::CustomerNotFound)?;\n\n    let client_secret = generate_id(\n        consts::ID_LENGTH,\n   ...","generations":[" \/\/ TODO: remove customer_id and payment_method_id from the function signature\n    let payment_method = domain::PaymentMethod {\n        payment_method_id: payment_method_id.to_owned(),\n        payment_method_type: req.payment_method_type,\n        payment_method_subtype: req.payment_method_subtype,\n        payment_method_data,\n        payment_method_billing_address,\n        payment_method_metadata: pm_metadata,\n        payment_method_acceptance: customer_acceptance,\n        payment_method_status: status.unwrap_or_default(),\n        payment_method_created_at: common_utils::date_time::now(),\n        payment_method_updated_at: common_utils::date_time::now(),\n        payment_method_customer_id: customer_id.to_owned(),\n        payment_method_merchant_id: merchant_id.to_owned(),\n        payment_method_locker_id: locker_id,\n        payment_method_connector: None,\n        payment_method_type_data: None,\n        payment_method_issuer: None,\n        payment_method_issuing_country: None,\n        payment_method_issuing_network: None,\n        payment_method_issuing_authority: None,\n        payment_method_issuing_country_code: None,\n        payment_method_issuing_country_name: None,\n        payment_method_issuing_network_name: None,\n        payment_method_issuing_authority_name: None,\n        payment_method_issuing_country_code_with_name: None,\n        payment_method_issuing_country_name_with_code: None,\n        payment_method_issuing_network_name_with_code: None,\n        payment_method_issuing_authority_name_with_code: None,\n        payment_method_issuing_country_code_with_name_with_code: None,\n        payment_method_issuing_country_name_with_code_with_code: None,\n        payment_method_issuing_network_name_with_code_with_code: None,\n        payment_method_issuing_authority_name_with_code_with_code: None,\n        payment_method_issuing_country_code_with_name_with_code_with_code: None,\n        payment_method_issuing_country_name_with_code_with_code_with_code: None,\n        payment_method_issuing_network_name_with_code_with_code_with_code: None,\n        payment_method_issuing_authority_name_with_code_with_code_with_code: None,\n        payment_method_issuing_country_code_with_name_with_code_with_code_with_code: None,\n        payment_method_issuing_country_name_with_code_with_code_with_code_with_code: None,\n        payment_method_issuing_network_name_with_code_with_code_with_code_with_code: None,\n        payment_method_issuing_authority_name_with_code_with_code_with_code_with_code: None,\n        payment_method_issuing_country_code_with_name_with_code_with_code_with_code_with_code: None,\n        payment_method_issuing_country_name_with_code_with_code_with_code_with_code_with_code: None,\n        payment_method_issuing_network_name_with_code_with_code_with_code_with_code_with_code: None,\n        payment_method_issuing_authority_name_with_code_with_code_with_code_with_code_with_code: None,\n        payment_method_issuing_country_code_with_name_with_code_with_code_with_code_with_code_with_code: None,\n        payment_method_issuing_country_name_with_code_with_code_with_code_with_code_with_code_with_code: None,\n        payment_method_issuing_network_name_with_code_with_code_with_code_with_code_with_code_with_code: None,\n        payment_method_issuing_authority_name_with_code_with_code_with_code_with_code_with_code_with_code: None,\n        payment_method_issuing_country_code_with_name_with_code_with_code_with_code_with_code_with_code_with_code: None,\n        payment_method_issuing_country_name_with_code_with_code_with_code_with_code_with_code_with_code_with_code: None,\n        payment_method_issuing_network_name_with_code_with_code_with_code_with_code_with_code_with_code_with_code: None,\n        payment_method_issuing_authority_name_with_code_with_code_with_code_with_code_with_code_with_code_with_code: None,\n        payment_method_issuing_country_code_with_name_with_code_with_code_with_code_with_code_with_code_with_code_with_code: None,\n        payment_method_issuing_country_name_with_code_with_code_with_code_with_code_with_code_with_code_with_code_with_code: None,\n        payment_method_issuing_network_name_with_code_with_code_with_code_with_code_with_code_with_code_with_code_with_code: None,\n        payment_method_issuing_authority_name_with_code_with_code_with_code_with_code_with_code_with_code_with_code_with_code: None,\n        payment_method_issuing_country_code_with_name_with_code_with_code_with_code_with_code_with_code_with_code_with_code_with_code: None,\n        payment_method_issuing_country_name_with_code_with_code_with_code_with_code_with_code_with_code_with_code_with_code_with_code: None,\n        payment_method_issuing_network_name_with_code_with_code_with_code_with_code_with_code_with_code_with_code_with_code_with_code: None,\n        payment_method_issuing_authority_name_with_code_with_code_with_code_with_code_with_code_with_code_with_code_with_code_with_code: None,\n        payment_method_","",""],"best_token_recall":0.5110294118,"best_bleu":13.5487938768,"best_rougeL":17.3151750973,"exact_match_any":0},{"file":"crates\/router\/src\/core\/payment_methods\/cards.rs","mask_idx":1,"target_len":858,"prompt_snippet":"use std::{\n    collections::{HashMap, HashSet},\n    fmt::Debug,\n    str::FromStr,\n};\n\n#[cfg(all(\n    any(feature = \"v1\", feature = \"v2\"),\n    not(feature = \"payment_methods_v2\")\n))]\nuse api_models::admin::PaymentMethodsEnabled;\nuse api_models::{\n    enums as api_enums,\n    payment_methods::{\n        BankAccountTokenData, Card, CardDetailUpdate, CardDetailsPaymentMethod, CardNetworkTypes,\n        C...","target_snippet":"\n    let pm_id = generate_id(consts::ID_LENGTH, \"pm\");\n    let payment_method_response = api::PaymentMethodResponse {\n        merchant_id: merchant_id.to_owned(),\n        customer_id: Some(customer_id.to_owned()),\n        payment_method_id: pm_id,\n        payment_method: req.payment_method,\n        payment_method_type: req.payment_method_type,\n        #[cfg(feature = \"payouts\")]\n        bank_trans...","generations":[" \/\/ TODO: Remove the `Option` once we are sure that the duplication check is always performed\n    let payment_method_id = generate_id(consts::ID_LENGTH, \"pm\");\n    let response = PaymentMethodResponse::from(\n        PaymentMethodCreateExt::try_from(req)\n            .change_context(errors::ApiErrorResponse::InvalidDataFormat {\n                field_name: \"payment_method_create\",\n            })\n            .attach_printable(\"Failed to convert PaymentMethodCreate to PaymentMethodCreateExt\")?,\n    )\n    .into_inner();\n    let duplication_check = None;\n    (response, duplication_check)\n}\n\n#[cfg(all(feature = \"v2\", feature = \"payment_methods_v2\"))]\n#[instrument(skip_all)]\npub async fn create_payment_method(\n    state: &routes::SessionState,\n    req: &api::PaymentMethodCreate,\n    customer_id: &id_type::CustomerId,\n    merchant_id: &id_type::MerchantId,\n    key_store: &domain::MerchantKeyStore,\n    storage_scheme: MerchantStorageScheme,\n    payment_method_data: crypto::OptionalEncryptableValue,\n    payment_method_billing_address: crypto::OptionalEncryptableValue,\n    payment_method_metadata: Option<serde_json::Value>,\n    payment_method_acceptance: Option<serde_json::Value>,\n    payment_method_issuer: Option<String>,\n    payment_method_issuer_code: Option<String>,\n    payment_method_issuer_country: Option<String>,\n    payment_method_issuer_name: Option<String>,\n    payment_method_issuer_country_code: Option<String>,\n    payment_method_issuer_code: Option<String>,\n    payment_method_issuer_name: Option<String>,\n    payment_method_issuer_country_code: Option<String>,\n    payment_method_issuer_code: Option<String>,\n    payment_method_issuer_name: Option<String>,\n    payment_method_issuer_country_code: Option<String>,\n    payment_method_issuer_code: Option<String>,\n    payment_method_issuer_name: Option<String>,\n    payment_method_issuer_country_code: Option<String>,\n    payment_method_issuer_code: Option<String>,\n    payment_method_issuer_name: Option<String>,\n    payment_method_issuer_country_code: Option<String>,\n    payment_method_issuer_code: Option<String>,\n    payment_method_issuer_name: Option<String>,\n    payment_method_issuer_country_code: Option<String>,\n    payment_method_issuer_code: Option<String>,\n    payment_method_issuer_name: Option<String>,\n    payment_method_issuer_country_code: Option<String>,\n    payment_method_issuer_code: Option<String>,\n    payment_method_issuer_name: Option<String>,\n    payment_method_issuer_country_code: Option<String>,\n    payment_method_issuer_code: Option<String>,\n    payment_method_issuer_name: Option<String>,\n    payment_method_issuer_country_code: Option<String>,\n    payment_method_issuer_code: Option<String>,\n    payment_method_issuer_name: Option<String>,\n    payment_method_issuer_country_code: Option<String>,\n    payment_method_issuer_code: Option<String>,\n    payment_method_issuer_name: Option<String>,\n    payment_method_issuer_country_code: Option<String>,\n    payment_method_issuer_code: Option<String>,\n    payment_method_issuer_name: Option<String>,\n    payment_method_issuer_country_code: Option<String>,\n    payment_method_issuer_code: Option<String>,\n    payment_method_issuer_name: Option<String>,\n    payment_method_issuer_country_code: Option<String>,\n    payment_method_issuer_code: Option<String>,\n    payment_method_issuer_name: Option<String>,\n    payment_method_issuer_country_code: Option<String>,\n    payment_method_issuer_code: Option<String>,\n    payment_method_issuer_name: Option<String>,\n    payment_method_issuer_country_code: Option<String>,\n    payment_method_issuer_code: Option<String>,\n    payment_method_issuer_name: Option<String>,\n    payment_method_issuer_country_code: Option<String>,\n    payment_method_issuer_code: Option<String>,\n    payment_method_issuer_name: Option<String>,\n    payment_method_issuer_country_code: Option<String>,\n    payment_method_issuer_code: Option<String>,\n    payment_method_issuer_name: Option<String>,\n    payment_method_issuer_country_code: Option<String>,\n    payment_method_issuer_code: Option<String>,\n    payment_method_issuer_name: Option<String>,\n    payment_method_issuer_country_code: Option<String>,\n    payment_method_issuer_code: Option<String>,\n    payment_method_issuer_name: Option<String>,\n    payment_method_issuer_country_code: Option<String>,\n    payment_method_issuer_code: Option<String>,\n    payment_method_issuer_name: Option<String>,\n    payment_method_issuer_country_code: Option<String>,\n    payment_method_issuer_code: Option<String>,\n    payment_method_issuer_name: Option<String>,\n    payment_method_issuer_country_code: Option<String>,\n    payment_method_issuer_code: Option<String>,\n    payment_method_issuer_name: Option<String>,\n    payment_method_issuer_country_code: Option<String>,\n    payment_method_issuer_code: Option<String>,\n    payment_method_issuer_name: Option<String>,\n    payment_method_issuer_country_code: Option<String>,\n","",""],"best_token_recall":0.6137566138,"best_bleu":5.2350864384,"best_rougeL":8.9855072464,"exact_match_any":0},{"file":"crates\/router\/src\/core\/payment_methods\/cards.rs","mask_idx":2,"target_len":13,"prompt_snippet":"use std::{\n    collections::{HashMap, HashSet},\n    fmt::Debug,\n    str::FromStr,\n};\n\n#[cfg(all(\n    any(feature = \"v1\", feature = \"v2\"),\n    not(feature = \"payment_methods_v2\")\n))]\nuse api_models::admin::PaymentMethodsEnabled;\nuse api_models::{\n    enums as api_enums,\n    payment_methods::{\n        BankAccountTokenData, Card, CardDetailUpdate, CardDetailsPaymentMethod, CardNetworkTypes,\n        C...","target_snippet":"\n    todo!()\n","generations":[" \/\/TODO: implement\n    todo!()\n}\n\n#[cfg(all(feature = \"v1\", feature = \"payment_methods_v2\"))]\n#[instrument(skip_all)]\n#[allow(clippy::too_many_arguments)]\npub async fn update_payment_method(\n    state: &routes::SessionState,\n    req: &api::PaymentMethodUpdate,\n    payment_method_id: &str,\n    merchant_id: &id_type::MerchantId,\n    customer_id: &id_type::CustomerId,\n    key_store: &domain::MerchantKeyStore,\n    storage_scheme: MerchantStorageScheme,\n    payment_method_data: crypto::OptionalEncryptableValue,\n    payment_method_billing_address: crypto::OptionalEncryptableValue,\n    card_scheme: Option<String>,\n    network_token_requestor_reference_id: Option<String>,\n    network_token_locker_id: Option<String>,\n    network_token_payment_method_data: crypto::OptionalEncryptableValue,\n) -> errors::CustomResult<domain::PaymentMethod, errors::ApiErrorResponse> {\n    let db = &*state.store;\n    let customer = db\n        .find_customer_by_customer_id_merchant_id(\n            &state.into(),\n            customer_id,\n            merchant_id,\n            key_store,\n            storage_scheme,\n        )\n        .await\n        .to_not_found_response(errors::ApiErrorResponse::CustomerNotFound)?;\n\n    let payment_method = db\n        .find_payment_method_by_payment_method_id_merchant_id(\n            &state.into(),\n            payment_method_id,\n            merchant_id,\n            key_store,\n            storage_scheme,\n        )\n        .await\n        .to_not_found_response(errors::ApiErrorResponse::PaymentMethodNotFound)?;\n\n    let current_time = common_utils::date_time::now();\n\n    let payment_method_update = payment_methods::PaymentMethodUpdate::from(req);\n\n    let payment_method = payment_method.update(payment_method_update);\n\n    let payment_method_data = payment_method_data.map(Secret::new);\n    let payment_method_billing_address = payment_method_billing_address.map(Secret::new);\n\n    let payment_method = payment_methods::PaymentMethodUpdateInternal::from(payment_method);\n\n    let payment_method = payment_methods::PaymentMethodUpdateInternal::apply_changeset(\n        payment_method,\n        payment_method_data,\n        payment_method_billing_address,\n        card_scheme,\n        network_token_requestor_reference_id,\n        network_token_locker_id,\n        network_token_payment_method_data,\n    );\n\n    let payment_method = db\n        .update_payment_method(\n            &state.into(),\n            key_store,\n            payment_method,\n            storage_scheme,\n        )\n        .await\n        .change_context(errors::ApiErrorResponse::InternalServerError)\n        .attach_printable(\"Failed to update payment method in db\")?;\n\n    if payment_method.is_stored.unwrap_or(false) {\n        let _ = set_default_payment_method(\n            state,\n            merchant_id,\n            key_store.clone(),\n            customer_id,\n            payment_method.payment_method_id.clone(),\n            storage_scheme,\n        )\n        .await\n        .map_err(|error| logger::error!(?error, \"Failed to set the payment method as default\"));\n    }\n    Ok(payment_method)\n}\n\n#[cfg(all(feature = \"v2\", feature = \"payment_methods_v2\"))]\n#[instrument(skip_all)]\n#[allow(clippy::too_many_arguments)]\npub async fn update_payment_method(\n    state: &routes::SessionState,\n    req: &api::PaymentMethodUpdate,\n    payment_method_id: &str,\n    merchant_id: &id_type::MerchantId,\n    customer_id: &id_type::CustomerId,\n    key_store: &domain::MerchantKeyStore,\n    storage_scheme: MerchantStorageScheme,\n    payment_method_data: crypto::OptionalEncryptableValue,\n    payment_method_billing_address: crypto::OptionalEncryptableValue,\n    card_scheme: Option<String>,\n    network_token_requestor_reference_id: Option<String>,\n    network_token_locker_id: Option<String>,\n    network_token_payment_method_data: crypto::OptionalEncryptableValue,\n) -> errors::CustomResult<domain::PaymentMethod, errors::ApiErrorResponse> {\n    let db = &*state.store;\n    let customer = db\n        .find_customer_by_customer_id_merchant_id(\n            &state.into(),\n            customer_id,\n            merchant_id,\n            key_store,\n            storage_scheme,\n        )\n        .await\n        .to_not_found_response(errors::ApiErrorResponse::CustomerNotFound)?;\n\n    let payment_method = db\n        .find_payment_method_by_payment_method_id_merchant_id(\n            &state.into(),\n            payment_method_id,\n            merchant_id,\n            key_store,\n            storage_scheme,\n        )\n        .await\n        .to_not_found_response(errors::ApiErrorResponse::PaymentMethodNotFound)?;\n\n    let current_time = common_utils::date_time::now();\n\n    let payment_method_update = payment_methods::PaymentMethodUpdate::from(req);\n\n    let payment_method = payment_method.update(payment_method_update);\n\n    let payment_method_data = payment_method_data.map(Secret::new);\n    let payment_method_billing_address = payment_method_billing_address.map(Secret::new);\n\n","",""],"best_token_recall":1.0,"best_bleu":0.1852963423,"best_rougeL":0.3795066414,"exact_match_any":0},{"file":"crates\/router\/tests\/connectors\/payme.rs","mask_idx":0,"target_len":234,"prompt_snippet":"use std::str::FromStr;\n\nuse common_utils::{pii::Email, types::MinorUnit};\nuse diesel_models::types::OrderDetailsWithAmount;\nuse hyperswitch_domain_models::address::{Address, AddressDetails};\nuse masking::Secret;\nuse router::types::{self, domain, storage::enums, PaymentAddress};\n\nuse crate::{\n    connector_auth,\n    utils::{self, ConnectorActions, PaymentAuthorizeType},\n};\n\n#[derive(Clone, Copy)]\ns...","target_snippet":"\n        use router::connector::Payme;\n        utils::construct_connector_data_old(\n            Box::new(Payme::new()),\n            types::Connector::Payme,\n            types::api::GetToken::Connector,\n            None,\n        )\n    ","generations":[" utils::construct_connector_data_old(\"payme\", None) }\n    fn get_auth_token(&self) -> types::ConnectorAuthType {\n        utils::to_connector_auth_type(\n            connector_auth::ConnectorAuthentication::new()\n                .payme\n                .expect(\"Missing connector authentication configuration\")\n                .into(),\n        )\n    }\n    fn get_name(&self) -> String {\n        \"payme\".to_string()\n    }\n}\n\nstatic CONNECTOR: PaymeTest = PaymeTest {};\n\nfn get_default_payment_info() -> Option<utils::PaymentInfo> {\n    None\n}\n\nfn get_default_billing_info() -> Option<utils::PaymentInfo> {\n    None\n}\n\nfn get_default_shipping_info() -> Option<utils::PaymentInfo> {\n    None\n}\n\nfn get_default_payment_method_info() -> Option<utils::PaymentInfo> {\n    None\n}\n\nfn get_default_capture_method() -> Option<enums::CaptureMethod> {\n    None\n}\n\nfn get_default_customer_acceptance() -> Option<utils::CustomerAcceptance> {\n    None\n}\n\nfn get_default_three_ds() -> Option<utils::ThreeDS> {\n    None\n}\n\nfn get_default_mandate_data() -> Option<utils::MandateData> {\n    None\n}\n\nfn get_default_payment_experience() -> Option<utils::PaymentExperience> {\n    None\n}\n\nfn get_default_payment_method() -> Option<enums::PaymentMethod> {\n    None\n}\n\nfn get_default_payment_method_type() -> Option<enums::PaymentMethodType> {\n    None\n}\n\nfn get_default_setup_future_usage() -> Option<enums::FutureUsage> {\n    None\n}\n\nfn get_default_customer_acceptance_for_three_ds() -> Option<utils::CustomerAcceptance> {\n    None\n}\n\nfn get_default_payment_method_data() -> Option<utils::PaymentMethodData> {\n    None\n}\n\nfn get_default_billing() -> Option<utils::Billing> {\n    None\n}\n\nfn get_default_shipping() -> Option<utils::Shipping> {\n    None\n}\n\nfn get_default_surcharge_details() -> Option<utils::SurchargeDetails> {\n    None\n}\n\nfn get_default_tax_details() -> Option<utils::TaxDetails> {\n    None\n}\n\nfn get_default_fraud_check() -> Option<utils::FraudCheck> {\n    None\n}\n\nfn get_default_three_ds_challenge() -> Option<utils::ThreeDSChallenge> {\n    None\n}\n\nfn get_default_three_ds_not_challenged() -> Option<utils::ThreeDSNotChallenged> {\n    None\n}\n\nfn get_default_payment_method_billing() -> Option<utils::PaymentMethodBilling> {\n    None\n}\n\nfn get_default_payment_method_shipping() -> Option<utils::PaymentMethodShipping> {\n    None\n}\n\nfn get_default_payment_method_surcharge_details() -> Option<utils::SurchargeDetails> {\n    None\n}\n\nfn get_default_payment_method_tax_details() -> Option<utils::TaxDetails> {\n    None\n}\n\nfn get_default_payment_method_fraud_check() -> Option<utils::FraudCheck> {\n    None\n}\n\nfn get_default_payment_method_three_ds_challenge() -> Option<utils::ThreeDSChallenge> {\n    None\n}\n\nfn get_default_payment_method_three_DS_not_challenged() -> Option<utils::ThreeDSNotChallenged> {\n    None\n}\n\nfn get_default_payment_method_three_ds_customer_acceptance() -> Option<utils::CustomerAcceptance> {\n    None\n}\n\nfn get_default_payment_method_three_ds_payment_experience() -> Option<utils::PaymentExperience> {\n    None\n}\n\nfn get_default_payment_method_three_DS_payment_method_data() -> Option<utils::PaymentMethodData> {\n    None\n}\n\nfn get_default_payment_method_three_DS_payment_method_billing() -> Option<utils::PaymentMethodBilling> {\n    None\n}\n\nfn get_default_payment_method_three_DS_payment_method_shipping() -> Option<utils::PaymentMethodShipping> {\n    None\n}\n\nfn get_default_payment_method_three_DS_payment_method_surcharge_details() -> Option<utils::SurchargeDetails> {\n    None\n}\n\nfn get_default_payment_method_three_DS_payment_method_tax_details() -> Option<utils::TaxDetails> {\n    None\n}\n\nfn get_default_payment_method_three_DS_payment_method_fraud_check() -> Option<utils::FraudCheck> {\n    None\n}\n\nfn get_default_payment_method_three_DS_payment_method_three_DS_challenge() -> Option<utils::ThreeDSChallenge> {\n    None\n}\n\nfn get_default_payment_method_three_DS_payment_method_three_DS_not_challenged() -> Option<utils::ThreeDSNotChallenged> {\n    None\n}\n\nfn get_default_payment_method_three_DS_payment_method_three_DS_customer_acceptance() -> Option<utils::CustomerAcceptance> {\n    None\n}\n\nfn get_default_payment_method_three_DS_payment_method_three_DS_payment_experience() -> Option<utils::PaymentExperience> {\n    None\n}\n\nfn get_default_payment_method_three_DS_payment_method_three_DS_payment_method_data() -> Option<utils","",""],"best_token_recall":0.6730769231,"best_bleu":1.5952158352,"best_rougeL":4.1198501873,"exact_match_any":0},{"file":"crates\/router\/tests\/connectors\/payme.rs","mask_idx":1,"target_len":235,"prompt_snippet":"use std::str::FromStr;\n\nuse common_utils::{pii::Email, types::MinorUnit};\nuse diesel_models::types::OrderDetailsWithAmount;\nuse hyperswitch_domain_models::address::{Address, AddressDetails};\nuse masking::Secret;\nuse router::types::{self, domain, storage::enums, PaymentAddress};\n\nuse crate::{\n    connector_auth,\n    utils::{self, ConnectorActions, PaymentAuthorizeType},\n};\n\n#[derive(Clone, Copy)]\ns...","target_snippet":"\n        utils::to_connector_auth_type(\n            connector_auth::ConnectorAuthentication::new()\n                .payme\n                .expect(\"Missing connector authentication configuration\")\n                .into(),\n        )\n    ","generations":[" connector_auth::ConnectorAuthentication::new().payme }\n\n    fn get_name(&self) -> String {\n        \"payme\".to_string()\n    }\n}\n\nstatic CONNECTOR: PaymeTest = PaymeTest {};\n\nfn get_default_payment_info() -> Option<utils::PaymentInfo> {\n    None\n}\n\nfn payment_method_details() -> Option<types::PaymentsAuthorizeData> {\n    None\n}\n\n\/\/ Cards Positive Tests\n\/\/ Creates a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_only_authorize_payment() {\n    let response = CONNECTOR\n        .authorize_payment(payment_method_details(), get_default_payment_info())\n        .await\n        .expect(\"Authorize payment response\");\n    assert_eq!(response.status, enums::AttemptStatus::Authorized);\n}\n\n\/\/ Captures a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_capture_authorized_payment() {\n    let response = CONNECTOR\n        .authorize_and_capture_payment(payment_method_details(), None, get_default_payment_info())\n        .await\n        .expect(\"Capture payment response\");\n    assert_eq!(response.status, enums::AttemptStatus::Charged);\n}\n\n\/\/ Partially captures a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_partially_capture_authorized_payment() {\n    let response = CONNECTOR\n        .authorize_and_capture_payment(\n            payment_method_details(),\n            Some(types::PaymentsCaptureData {\n                amount_to_capture: MinorUnit::new(50),\n                ..utils::PaymentCaptureType::default().0\n            }),\n            get_default_payment_info(),\n        )\n        .await\n        .expect(\"Capture payment response\");\n    assert_eq!(response.status, enums::AttemptStatus::Charged);\n}\n\n\/\/ Synchronizes a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_sync_authorized_payment() {\n    let authorize_response = CONNECTOR\n        .authorize_payment(payment_method_details(), get_default_payment_info())\n        .await\n        .expect(\"Authorize payment response\");\n    let txn_id = utils::get_connector_transaction_id(authorize_response.response);\n    let response = CONNECTOR\n        .psync_retry_till_status_matches(\n            enums::AttemptStatus::Authorized,\n            Some(types::PaymentsSyncData {\n                connector_transaction_id: types::ResponseId::ConnectorTransactionId(\n                    txn_id.unwrap(),\n                ),\n                ..Default::default()\n            }),\n            get_default_payment_info(),\n        )\n        .await\n        .expect(\"PSync response\");\n    assert_eq!(response.status, enums::AttemptStatus::Authorized,);\n}\n\n\/\/ Voids a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_void_authorized_payment() {\n    let response = CONNECTOR\n        .authorize_and_void_payment(\n            payment_method_details(),\n            Some(types::PaymentsCancelData {\n                connector_transaction_id: String::from(\"\"),\n                cancellation_reason: Some(\"requested_by_customer\".to_string()),\n                ..Default::default()\n            }),\n            get_default_payment_info(),\n        )\n        .await\n        .expect(\"Void payment response\");\n    assert_eq!(response.status, enums::AttemptStatus::Voided);\n}\n\n\/\/ Refunds a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_refund_manually_captured_payment() {\n    let response = CONNECTOR\n        .capture_payment_and_refund(\n            payment_method_details(),\n            None,\n            None,\n            get_default_payment_info(),\n        )\n        .await\n        .unwrap();\n    assert_eq!(\n        response.response.unwrap().refund_status,\n        enums::RefundStatus::Success,\n    );\n}\n\n\/\/ Partially refunds a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_partially_refund_manually_captured_payment() {\n    let response = CONNECTOR\n        .capture_payment_and_refund(\n            payment_method_details(),\n            None,\n            Some(types::RefundsData {\n                refund_amount: MinorUnit::new(50),\n                ..utils::PaymentRefundType::default().0\n            }),\n            get_default_payment_info(),\n        )\n        .await\n        .unwrap();\n    assert_eq!(\n        response.response.unwrap().refund_status,\n        enums::RefundStatus::Success,\n    );\n}\n\n\/\/ Synchronizes a refund using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_sync_manually_captured_refund() {\n    let refund_response = CONNECTOR\n        .capture_payment_and_refund(\n            payment_method_details(),\n            None,\n            None,\n            get_default_payment_info(),\n        )\n        .await\n        .unwrap();\n    let response = CONNECTOR\n        .rsync_retry_till_status_matches(\n            enums::RefundStatus::Success,\n            refund","",""],"best_token_recall":0.8205128205,"best_bleu":1.7814243594,"best_rougeL":2.7290448343,"exact_match_any":0},{"file":"crates\/router\/tests\/connectors\/payme.rs","mask_idx":2,"target_len":33,"prompt_snippet":"use std::str::FromStr;\n\nuse common_utils::{pii::Email, types::MinorUnit};\nuse diesel_models::types::OrderDetailsWithAmount;\nuse hyperswitch_domain_models::address::{Address, AddressDetails};\nuse masking::Secret;\nuse router::types::{self, domain, storage::enums, PaymentAddress};\n\nuse crate::{\n    connector_auth,\n    utils::{self, ConnectorActions, PaymentAuthorizeType},\n};\n\n#[derive(Clone, Copy)]\ns...","target_snippet":"\n        \"payme\".to_string()\n    ","generations":[" \"payme\".to_string() }\n}\n\nstatic CONNECTOR: PaymeTest = PaymeTest {};\n\nfn get_default_payment_info() -> Option<utils::PaymentInfo> {\n    None\n}\n\nfn payment_method_details() -> Option<types::PaymentsAuthorizeData> {\n    None\n}\n\n\/\/ Cards Positive Tests\n\/\/ Creates a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_only_authorize_payment() {\n    let response = CONNECTOR\n        .authorize_payment(payment_method_details(), get_default_payment_info())\n        .await\n        .expect(\"Authorize payment response\");\n    assert_eq!(response.status, enums::AttemptStatus::Authorized);\n}\n\n\/\/ Captures a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_capture_authorized_payment() {\n    let response = CONNECTOR\n        .authorize_and_capture_payment(payment_method_details(), None, get_default_payment_info())\n        .await\n        .expect(\"Capture payment response\");\n    assert_eq!(response.status, enums::AttemptStatus::Charged);\n}\n\n\/\/ Partially captures a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_partially_capture_authorized_payment() {\n    let response = CONNECTOR\n        .authorize_and_capture_payment(\n            payment_method_details(),\n            Some(types::PaymentsCaptureData {\n                amount_to_capture: MinorUnit::new(50),\n                ..utils::PaymentCaptureType::default().0\n            }),\n            get_default_payment_info(),\n        )\n        .await\n        .expect(\"Capture payment response\");\n    assert_eq!(response.status, enums::AttemptStatus::Charged);\n}\n\n\/\/ Synchronizes a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_sync_authorized_payment() {\n    let authorize_response = CONNECTOR\n        .authorize_payment(payment_method_details(), get_default_payment_info())\n        .await\n        .expect(\"Authorize payment response\");\n    let txn_id = utils::get_connector_transaction_id(authorize_response.response);\n    let response = CONNECTOR\n        .psync_retry_till_status_matches(\n            enums::AttemptStatus::Authorized,\n            Some(types::PaymentsSyncData {\n                connector_transaction_id: types::ResponseId::ConnectorTransactionId(\n                    txn_id.unwrap(),\n                ),\n                ..Default::default()\n            }),\n            get_default_payment_info(),\n        )\n        .await\n        .expect(\"PSync response\");\n    assert_eq!(response.status, enums::AttemptStatus::Authorized,);\n}\n\n\/\/ Voids a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_void_authorized_payment() {\n    let response = CONNECTOR\n        .authorize_and_void_payment(\n            payment_method_details(),\n            Some(types::PaymentsCancelData {\n                connector_transaction_id: String::from(\"\"),\n                cancellation_reason: Some(\"requested_by_customer\".to_string()),\n                ..Default::default()\n            }),\n            get_default_payment_info(),\n        )\n        .await\n        .expect(\"Void payment response\");\n    assert_eq!(response.status, enums::AttemptStatus::Voided);\n}\n\n\/\/ Refunds a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_refund_manually_captured_payment() {\n    let response = CONNECTOR\n        .capture_payment_and_refund(\n            payment_method_details(),\n            None,\n            None,\n            get_default_payment_info(),\n        )\n        .await\n        .unwrap();\n    assert_eq!(\n        response.response.unwrap().refund_status,\n        enums::RefundStatus::Success,\n    );\n}\n\n\/\/ Partially refunds a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_partially_refund_manually_captured_payment() {\n    let response = CONNECTOR\n        .capture_payment_and_refund(\n            payment_method_details(),\n            None,\n            Some(types::RefundsData {\n                refund_amount: MinorUnit::new(50),\n                ..utils::PaymentRefundType::default().0\n            }),\n            get_default_payment_info(),\n        )\n        .await\n        .unwrap();\n    assert_eq!(\n        response.response.unwrap().refund_status,\n        enums::RefundStatus::Success,\n    );\n}\n\n\/\/ Synchronizes a refund using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_sync_manually_captured_refund() {\n    let refund_response = CONNECTOR\n        .capture_payment_and_refund(\n            payment_method_details(),\n            None,\n            None,\n            get_default_payment_info(),\n        )\n        .await\n        .unwrap();\n    let response = CONNECTOR\n        .rsync_retry_till_status_matches(\n            enums::RefundStatus::Success,\n            refund_response.response.unwrap().connector_refund_id,\n            None,\n            get_default_payment_info(),\n        )\n        .await","",""],"best_token_recall":0.9,"best_bleu":0.6451143114,"best_rougeL":1.1952191235,"exact_match_any":0},{"file":"crates\/api_models\/src\/webhook_events.rs","mask_idx":0,"target_len":75,"prompt_snippet":"use common_enums::{EventClass, EventType, WebhookDeliveryAttempt};\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\nuse utoipa::ToSchema;\n\n\/\/\/ The constraints to apply when filtering events.\n#[derive(Clone, Debug, Serialize, Deserialize, ToSchema)]\npub struct EventListConstraints {\n    \/\/\/ Filter events created after the specified time.\n    #[serde(default, wi...","target_snippet":"\n        Self {\n            events,\n            total_count,\n        }\n    ","generations":[" Self { events, total_count } }\n}\n\n\/\/\/ The response body of list delivery attempts api call.\n#[derive(Debug, Serialize, ToSchema)]\npub struct DeliveryAttemptResponse {\n    \/\/\/ The identifier for the delivery attempt.\n    #[schema(max_length = 64, example = \"evt_018e31720d1b7a2b82677d3032cab959\")]\n    pub delivery_attempt_id: String,\n\n    \/\/\/ The identifier for the delivery attempt.\n    #[schema(max_length = 64, example = \"evt_018e31720d1b7a2b82677d3032cab959\")]\n    pub event_id: String,\n\n    \/\/\/ The identifier for the Merchant Account.\n    #[schema(max_length = 64, example = \"y3oqhf46pyzuxjbcn2giaqnb44\", value_type = String)]\n    pub merchant_id: common_utils::id_type::MerchantId,\n\n    \/\/\/ The identifier for the Business Profile.\n    #[schema(max_length = 64, value_type = String, example = \"SqB0zwDGR5wHppWf0bx7GKr1f2\")]\n    pub profile_id: common_utils::id_type::ProfileId,\n\n    \/\/\/ The identifier for the object (Payment Intent ID, Refund ID, etc.)\n    #[schema(max_length = 64, example = \"QHrfd5LUDdZaKtAjdJmMu0dMa1\")]\n    pub object_id: String,\n\n    \/\/\/ Specifies the type of event, which includes the object and its status.\n    pub event_type: EventType,\n\n    \/\/\/ Specifies the class of event (the type of object: Payment, Refund, etc.)\n    pub event_class: EventClass,\n\n    \/\/\/ The identifier for the initial delivery attempt. This will be the same as `event_id` for\n    \/\/\/ the initial delivery attempt.\n    #[schema(max_length = 64, example = \"evt_018e31720d1b7a2b82677d3032cab959\")]\n    pub initial_attempt_id: String,\n\n    \/\/\/ Time at which the event was created.\n    #[schema(example = \"2022-09-10T10:11:12Z\")]\n    #[serde(with = \"common_utils::custom_serde::iso8601\")]\n    pub created: PrimitiveDateTime,\n\n    \/\/\/ The status of the delivery attempt.\n    #[schema(value_type = WebhookDeliveryAttempt)]\n    pub status: WebhookDeliveryAttempt,\n}\n\n\/\/\/ The response body of list delivery attempts api call.\n#[derive(Debug, Serialize, ToSchema)]\npub struct ListDeliveryAttemptsResponse {\n    \/\/\/ The list of delivery attempts\n    pub delivery_attempts: Vec<DeliveryAttemptResponse>,\n    \/\/\/ Count of total delivery attempts\n    pub total_count: i64,\n}\n\nimpl ListDeliveryAttemptsResponse {\n    pub fn new(total_count: i64, delivery_attempts: Vec<DeliveryAttemptResponse>) -> Self {\n        Self {\n            delivery_attempts,\n            total_count,\n        }\n    }\n}\n\n\/\/\/ The response body for each item when listing delivery attempts.\n#[derive(Debug, Serialize, ToSchema)]\npub struct DeliveryAttemptListItemResponse {\n    \/\/\/ The identifier for the delivery attempt.\n    #[schema(max_length = 64, example = \"evt_018e31720d1b7a2b82677d3032cab959\")]\n    pub delivery_attempt_id: String,\n\n    \/\/\/ The identifier for the delivery attempt.\n    #[schema(max_length = 64, example = \"evt_018e31720d1b7a2b82677d3032cab959\")]\n    pub event_id: String,\n\n    \/\/\/ The identifier for the Merchant Account.\n    #[schema(max_length = 64, example = \"y3oqhf46pyzuxjbcn2giaqnb44\", value_type = String)]\n    pub merchant_id: common_utils::id_type::MerchantId,\n\n    \/\/\/ The identifier for the Business Profile.\n    #[schema(max_length = 64, value_type = String, example = \"SqB0zwDGR5wHppWf0bx7GKr1f2\")]\n    pub profile_id: common_utils::id_type::ProfileId,\n\n    \/\/\/ The identifier for the object (Payment Intent ID, Refund ID, etc.)\n    #[schema(max_length = 64, example = \"QHrfd5LUDdZaKtAjdJmMu0dMa1\")]\n    pub object_id: String,\n\n    \/\/\/ Specifies the type of event, which","",""],"best_token_recall":0.9285714286,"best_bleu":0.9217641595,"best_rougeL":1.975308642,"exact_match_any":0},{"file":"crates\/api_models\/src\/webhook_events.rs","mask_idx":1,"target_len":161,"prompt_snippet":"use common_enums::{EventClass, EventType, WebhookDeliveryAttempt};\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\nuse utoipa::ToSchema;\n\n\/\/\/ The constraints to apply when filtering events.\n#[derive(Clone, Debug, Serialize, Deserialize, ToSchema)]\npub struct EventListConstraints {\n    \/\/\/ Filter events created after the specified time.\n    #[serde(default, wi...","target_snippet":"\n        Some(common_utils::events::ApiEventsType::Events {\n            merchant_id: self.events.first().map(|event| event.merchant_id.clone())?,\n        })\n    ","generations":[" Some(common_utils::events::ApiEventsType::Webhooks) }\n}\n\n\/\/\/ The response body for each item when listing delivery attempts.\n#[derive(Debug, Serialize, ToSchema)]\npub struct WebhookDeliveryAttemptResponse {\n    \/\/\/ The identifier for the delivery attempt.\n    #[schema(max_length = 64, example = \"evt_018e31720d1b7a2b82677d3032cab959\")]\n    pub delivery_attempt_id: String,\n\n    \/\/\/ The identifier for the delivery attempt.\n    #[schema(max_length = 64, example = \"evt_018e31720d1b7a2b82677d3032cab959\")]\n    pub event_id: String,\n\n    \/\/\/ The identifier for the Merchant Account.\n    #[schema(max_length = 64, example = \"y3oqhf46pyzuxjbcn2giaqnb44\", value_type = String)]\n    pub merchant_id: common_utils::id_type::MerchantId,\n\n    \/\/\/ The identifier for the Business Profile.\n    #[schema(max_length = 64, value_type = String, example = \"SqB0zwDGR5wHppWf0bx7GKr1f2\")]\n    pub profile_id: common_utils::id_type::ProfileId,\n\n    \/\/\/ The identifier for the object (Payment Intent ID, Refund ID, etc.)\n    #[schema(max_length = 64, example = \"QHrfd5LUDdZaKtAjdJmMu0dMa1\")]\n    pub object_id: String,\n\n    \/\/\/ Specifies the type of event, which includes the object and its status.\n    pub event_type: EventType,\n\n    \/\/\/ Specifies the class of event (the type of object: Payment, Refund, etc.)\n    pub event_class: EventClass,\n\n    \/\/\/ The identifier for the initial delivery attempt. This will be the same as `event_id` for\n    \/\/\/ the initial delivery attempt.\n    #[schema(max_length = 64, example = \"evt_018e31720d1b7a2b82677d3032cab959\")]\n    pub initial_attempt_id: String,\n\n    \/\/\/ Time at which the event was created.\n    #[schema(example = \"2022-09-10T10:11:12Z\")]\n    #[serde(with = \"common_utils::custom_serde::iso8601\")]\n    pub created: PrimitiveDateTime,\n\n    \/\/\/ The delivery attempt status.\n    #[schema(value_type = WebhookDeliveryAttempt)]\n    pub delivery_attempt_status: WebhookDeliveryAttempt,\n}\n\nimpl common_utils::events::ApiEventMetric for WebhookDeliveryAttemptResponse {\n    fn get_api_event_type(&self) -> Option<common_utils::events::ApiEventsType> { Some(common_utils::events::ApiEventsType::Webhooks) }\n}\n\n\/\/\/ The response body for each item when listing delivery attempts.\n#[derive(Debug, Serialize, ToSchema)]\npub struct WebhookDeliveryAttemptResponseWithDeliveryAttemptId {\n    \/\/\/ The identifier for the delivery attempt.\n    #[schema(max_length = 64, example = \"evt_018e31720d1b7a2b82677d3032cab959\")]\n    pub delivery_attempt_id: String,\n\n    \/\/\/ The identifier for the delivery attempt.\n    #[schema(max_length = 64, example = \"evt_018e31720d1b7a2b82677d3032cab959\")]\n    pub event_id: String,\n\n    \/\/\/ The identifier for the Merchant Account.\n    #[schema(max_length = 64, example = \"y3oqhf46pyzuxjbcn2giaqnb44\", value_type = String)]\n    pub merchant_id: common_utils::id_type::MerchantId,\n\n    \/\/\/ The identifier for the Business Profile.\n    #[schema(max_length = 64, value_type = String, example = \"SqB0zwDGR5wHppWf0bx7GKr1f2\")]\n    pub profile_id: common_utils::id_type::ProfileId,\n\n    \/\/\/ The identifier for the object (Payment Intent ID, Refund ID, etc.)\n    #[schema(max_length = 64, example = \"QHrfd5LUDdZaKtAjdJmMu0dMa1\")]\n    pub object_id: String,\n\n    \/\/\/ Specifies the type of event, which includes the object and its status.\n    pub event_type: EventType,\n\n    \/\/\/ Specifies the class of event (the type of object: Payment, Refund, etc.)\n    pub event_class: EventClass,\n\n","",""],"best_token_recall":0.5277777778,"best_bleu":2.2317292204,"best_rougeL":5.7416267943,"exact_match_any":0},{"file":"crates\/api_models\/src\/webhook_events.rs","mask_idx":2,"target_len":144,"prompt_snippet":"use common_enums::{EventClass, EventType, WebhookDeliveryAttempt};\nuse masking::Secret;\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\nuse utoipa::ToSchema;\n\n\/\/\/ The constraints to apply when filtering events.\n#[derive(Clone, Debug, Serialize, Deserialize, ToSchema)]\npub struct EventListConstraints {\n    \/\/\/ Filter events created after the specified time.\n    #[serde(default, wi...","target_snippet":"\n        Some(common_utils::events::ApiEventsType::Events {\n            merchant_id: self.event_information.merchant_id.clone(),\n        })\n    ","generations":[" Some(common_utils::events::ApiEventsType::Events {\n        merchant_id: self.event_information.merchant_id.clone(),\n    }) }\n\n    fn get_api_event_object(&self) -> Option<common_utils::events::ApiEventsObject> {\n        Some(common_utils::events::ApiEventsObject::WebhookDeliveryAttempt {\n            delivery_attempt: self.delivery_attempt,\n            request: self.request,\n            response: self.response,\n        })\n    }\n}\n\n\/\/\/ The request information sent in the webhook.\n#[derive(Debug, Serialize, ToSchema)]\npub struct OutgoingWebhookRequestContent {\n    \/\/\/ The request method.\n    pub method: common_enums::http::Method,\n\n    \/\/\/ The request headers.\n    pub headers: Option<Vec<(String, masking::Maskable<String>)>,\n\n    \/\/\/ The request body.\n    pub body: Option<masking::SecretSerdeValue>,\n}\n\n\/\/\/ The response information received for the webhook sent.\n#[derive(Debug, Serialize, ToSchema)]\npub struct OutgoingWebhookResponseContent {\n    \/\/\/ The response status code.\n    pub status_code: u16,\n\n    \/\/\/ The response headers.\n    pub headers: Option<Vec<(String, masking::Maskable<String>)>,\n\n    \/\/\/ The response body.\n    pub body: Option<masking::SecretSerdeValue>,\n}\n\n\/\/\/ The response body for retrieving an event delivery attempt.\n#[derive(Debug, Serialize, ToSchema)]\npub struct EventDeliveryAttemptResponse {\n    \/\/\/ The identifier for the delivery attempt.\n    #[schema(max_length = 64, example = \"evt_018e31720d1b7a2b82677d3032cab959\")]\n    pub delivery_attempt_id: String,\n\n    \/\/\/ The identifier for the delivery attempt.\n    #[schema(max_length = 64, example = \"evt_018e31720d1b7a2b82677d3032cab959\")]\n    pub event_id: String,\n\n    \/\/\/ The identifier for the delivery attempt.\n    #[schema(max_length = 64, example = \"evt_018e31720d1b7a2b82677d3032cab959\")]\n    pub attempt_id: String,\n\n    \/\/\/ The identifier for the delivery attempt.\n    #[schema(max_length = 64, example = \"evt_018e31720d1b7a2b82677d3032cab959\")]\n    pub delivery_attempt_status: WebhookDeliveryAttempt,\n\n    \/\/\/ The identifier for the delivery attempt.\n    #[schema(max_length = 64, example = \"evt_018e31720d1b7a2b82677d3032cab959\")]\n    pub delivery_attempt_reason: Option<String>,\n\n    \/\/\/ The identifier for the delivery attempt.\n    #[schema(max_length = 64, example = \"evt_018e31720d1b7a2b82677d3032cab959\")]\n    pub delivery_attempt_error: Option<String>,\n\n    \/\/\/ The identifier for the delivery attempt.\n    #[schema(max_length = 64, example = \"evt_018e31720d1b7a2b82677d3032cab959\")]\n    pub delivery_attempt_error_code: Option<String>,\n\n    \/\/\/ The identifier for the delivery attempt.\n    #[schema(max_length = 64, example = \"evt_018e31720d1b7a2b82677d3032cab959\")]\n    pub delivery_attempt_error_message: Option<String>,\n\n    \/\/\/ The identifier for the delivery attempt.\n    #[schema(max_length = 64, example = \"evt_018e31720d1b7a2b82677d3032cab959\")]\n    pub delivery_attempt_error_reason: Option<String>,\n\n    \/\/\/ The identifier for the delivery attempt.\n    #[schema(max_length = 64, example = \"evt_018e31720d1b7a2b82677d3032cab959\")]\n    pub delivery_attempt_error_type: Option<String>,\n\n    \/\/\/ The identifier for the delivery attempt.\n    #[schema(max_length = 64, example = \"evt_018e31720d1b7a2b82677d3032cab959\")]\n    pub delivery_attempt_error_message: Option<String>,\n\n    \/\/\/ The identifier for the delivery attempt.\n    #[schema(max_length = 6","",""],"best_token_recall":0.9310344828,"best_bleu":4.3229653079,"best_rougeL":7.486631016,"exact_match_any":0},{"file":"crates\/api_models\/src\/events\/locker_migration.rs","mask_idx":0,"target_len":67,"prompt_snippet":"use common_utils::events::ApiEventMetric;\n\nuse crate::locker_migration::MigrateCardResponse;\n\nimpl ApiEventMetric for MigrateCardResponse {\n    fn get_api_event_type(&self) -> Option<common_utils::events::ApiEventsType> {","target_snippet":"\n        Some(common_utils::events::ApiEventsType::RustLocker)\n    ","generations":[" self.migrate_type }\n}\nimpl ApiEventMetric for common_enums::MigrateCardType {\n    fn get_api_event_type(&self) -> Option<common_utils::events::ApiEventsType> { Some(*self) }\n}\nimpl ApiEventMetric for common_enums::MigrateCardStatus {\n    fn get_api_event_type(&self) -> Option<common_utils::events::ApiEventsType> { Some(*self) }\n}\nimpl ApiEventMetric for common_enums::MigrateCardReason {\n    fn get_api_event_type(&self) -> Option<common_utils::events::ApiEventsType> { Some(*self) }\n}\nimpl ApiEventMetric for common_enums::MigrateCardError {\n    fn get_api_event_type(&self) -> Option<common_utils::events::ApiEventsType> { Some(*self) }\n}\nimpl ApiEventMetric for common_enums::MigrateCardErrorReason {\n    fn get_api_event_type(&self) -> Option<common_utils::events::ApiEventsType> { Some(*self) }\n}\nimpl ApiEventMetric for common_enums::MigrateCardErrorType {\n    fn get_api_event_type(&self) -> Option<common_utils::events::ApiEventsType> { Some(*self) }\n}\nimpl ApiEventMetric for common_enums::MigrateCardErrorSubType {\n    fn get_api_event_type(&self) -> Option<common_utils::events::ApiEventsType> { Some(*self) }\n}\nimpl ApiEventMetric for common_enums::MigrateCardErrorSubSubType {\n    fn get_api_event_type(&self) -> Option<common_utils::events::ApiEventsType> { Some(*self) }\n}\nimpl ApiEventMetric for common_enums::MigrateCardErrorSubSubSubType {\n    fn get_api_event_type(&self) -> Option<common_utils::events::ApiEventsType> { Some(*self) }\n}\nimpl ApiEventMetric for common_enums::MigrateCardErrorSubSubSubSubType {\n    fn get_api_event_type(&self) -> Option<common_utils::events::ApiEventsType> { Some(*self) }\n}\nimpl ApiEventMetric for common_enums::MigrateCardErrorSubSubSubSubSubType {\n    fn get_api_event_type(&self) -> Option<common_utils::events::ApiEventsType> { Some(*self) }\n}\nimpl ApiEventMetric for common_enums::MigrateCardErrorSubSubSubSubSubSubType {\n    fn get_api_event_type(&self) -> Option<common_utils::events::ApiEventsType> { Some(*self) }\n}\nimpl ApiEventMetric for common_enums::MigrateCardErrorSubSubSubSubSubSubSubType {\n    fn get_api_event_type(&self) -> Option<common_utils::events::ApiEventsType> { Some(*self) }\n}\nimpl ApiEventMetric for common_enums::MigrateCardErrorSubSubSubSubSubSubSubSubType {\n    fn get_api_event_type(&self) -> Option<common_utils::events::ApiEventsType> { Some(*self) }\n}\nimpl ApiEventMetric for common_enums::MigrateCardErrorSubSubSubSubSubSubSubSubSubType {\n    fn get_api_event_type(&self) -> Option<common_utils::events::ApiEventsType> { Some(*self) }\n}\nimpl ApiEventMetric for common_enums::MigrateCardErrorSubSubSubSubSubSubSubSubSubSubType {\n    fn get_api_event_type(&self) -> Option<common_utils::events::ApiEventsType> { Some(*self) }\n}\nimpl ApiEventMetric for common_enums::MigrateCardErrorSubSubSubSubSubSubSubSubSubSubSubType {\n    fn get_api_event_type(&self) -> Option<common_utils::events::ApiEventsType> { Some(*self) }\n}\nimpl ApiEventMetric for common_enums::MigrateCardErrorSubSubSubSubSubSubSubSubSubSubSubSubType {\n    fn get_api_event_type(&self) -> Option<common_utils::events::ApiEventsType> { Some(*self) }\n}\nimpl ApiEventMetric for common_enums::MigrateCardErrorSubSubSubSubSubSubSubSubSubSubSubSubSubType {\n    fn get_api_event_type(&self) -> Option<common_utils::events::ApiEventsType> { Some(*self) }\n}\nimpl ApiEventMetric for common_enums::MigrateCardErrorSubSubSubSubSubSubSubSubSubSubSubSubSubSubType {\n    fn get_api_event_type(&self) -> Option<common_utils::events::ApiEventsType> { Some(*self) }\n}\nimpl ApiEventMetric for common_enums::MigrateCardErrorSubSubSubSubSubSubSubSubSubSubSubSubSubSubSubType {\n    fn get_api_event_type(&self) -> Option<common_utils::events::ApiEventsType> { Some(*self) }\n","",""],"best_token_recall":0.5294117647,"best_bleu":0.9431108437,"best_rougeL":2.4509803922,"exact_match_any":0},{"file":"crates\/router\/tests\/connectors\/getnet.rs","mask_idx":0,"target_len":229,"prompt_snippet":"use hyperswitch_domain_models::payment_method_data::{Card, PaymentMethodData};\nuse masking::Secret;\nuse router::types::{self, api, storage::enums};\nuse test_utils::connector_auth;\n\nuse crate::utils::{self, ConnectorActions};\n\n#[derive(Clone, Copy)]\nstruct GetnetTest;\nimpl ConnectorActions for GetnetTest {}\nimpl utils::Connector for GetnetTest {\n    fn get_data(&self) -> api::ConnectorData {","target_snippet":"\n        use router::connector::Getnet;\n        utils::construct_connector_data_old(\n            Box::new(Getnet::new()),\n            types::Connector::Plaid,\n            api::GetToken::Connector,\n            None,\n        )\n    ","generations":["","",""],"best_token_recall":0.0,"best_bleu":0.0,"best_rougeL":0.0,"exact_match_any":0},{"file":"crates\/router\/tests\/connectors\/getnet.rs","mask_idx":1,"target_len":236,"prompt_snippet":"use hyperswitch_domain_models::payment_method_data::{Card, PaymentMethodData};\nuse masking::Secret;\nuse router::types::{self, api, storage::enums};\nuse test_utils::connector_auth;\n\nuse crate::utils::{self, ConnectorActions};\n\n#[derive(Clone, Copy)]\nstruct GetnetTest;\nimpl ConnectorActions for GetnetTest {}\nimpl utils::Connector for GetnetTest {\n    fn get_data(&self) -> api::ConnectorData {\n      ...","target_snippet":"\n        utils::to_connector_auth_type(\n            connector_auth::ConnectorAuthentication::new()\n                .getnet\n                .expect(\"Missing connector authentication configuration\")\n                .into(),\n        )\n    ","generations":["","",""],"best_token_recall":0.0,"best_bleu":0.0,"best_rougeL":0.0,"exact_match_any":0},{"file":"crates\/router\/tests\/connectors\/getnet.rs","mask_idx":2,"target_len":34,"prompt_snippet":"use hyperswitch_domain_models::payment_method_data::{Card, PaymentMethodData};\nuse masking::Secret;\nuse router::types::{self, api, storage::enums};\nuse test_utils::connector_auth;\n\nuse crate::utils::{self, ConnectorActions};\n\n#[derive(Clone, Copy)]\nstruct GetnetTest;\nimpl ConnectorActions for GetnetTest {}\nimpl utils::Connector for GetnetTest {\n    fn get_data(&self) -> api::ConnectorData {\n      ...","target_snippet":"\n        \"getnet\".to_string()\n    ","generations":["","",""],"best_token_recall":0.0,"best_bleu":0.0,"best_rougeL":0.0,"exact_match_any":0},{"file":"crates\/router\/src\/db\/fraud_check.rs","mask_idx":0,"target_len":1828,"prompt_snippet":"use diesel_models::fraud_check::{self as storage, FraudCheck, FraudCheckUpdate};\nuse error_stack::report;\nuse router_env::{instrument, tracing};\n\nuse super::MockDb;\nuse crate::{\n    connection,\n    core::errors::{self, CustomResult},\n    services::Store,\n};\n\n#[async_trait::async_trait]\npub trait FraudCheckInterface {\n    async fn insert_fraud_check_response(\n        &self,\n        new: storage::Fr...","target_snippet":"\n    #[instrument(skip_all)]\n    async fn insert_fraud_check_response(\n        &self,\n        new: storage::FraudCheckNew,\n    ) -> CustomResult<FraudCheck, errors::StorageError> {\n        let conn = connection::pg_connection_write(self).await?;\n        new.insert(&conn)\n            .await\n            .map_err(|error| report!(errors::StorageError::from(error)))\n    }\n\n    #[instrument(skip_all)]\n ...","generations":["","",""],"best_token_recall":0.0,"best_bleu":0.0,"best_rougeL":0.0,"exact_match_any":0},{"file":"crates\/router\/src\/db\/fraud_check.rs","mask_idx":1,"target_len":53,"prompt_snippet":"use diesel_models::fraud_check::{self as storage, FraudCheck, FraudCheckUpdate};\nuse error_stack::report;\nuse router_env::{instrument, tracing};\n\nuse super::MockDb;\nuse crate::{\n    connection,\n    core::errors::{self, CustomResult},\n    services::Store,\n};\n\n#[async_trait::async_trait]\npub trait FraudCheckInterface {\n    async fn insert_fraud_check_response(\n        &self,\n        new: storage::Fr...","target_snippet":"\n        Err(errors::StorageError::MockDbError)?\n    ","generations":["","",""],"best_token_recall":0.0,"best_bleu":0.0,"best_rougeL":0.0,"exact_match_any":0},{"file":"crates\/router\/src\/db\/fraud_check.rs","mask_idx":2,"target_len":53,"prompt_snippet":"use diesel_models::fraud_check::{self as storage, FraudCheck, FraudCheckUpdate};\nuse error_stack::report;\nuse router_env::{instrument, tracing};\n\nuse super::MockDb;\nuse crate::{\n    connection,\n    core::errors::{self, CustomResult},\n    services::Store,\n};\n\n#[async_trait::async_trait]\npub trait FraudCheckInterface {\n    async fn insert_fraud_check_response(\n        &self,\n        new: storage::Fr...","target_snippet":"\n        Err(errors::StorageError::MockDbError)?\n    ","generations":["","",""],"best_token_recall":0.0,"best_bleu":0.0,"best_rougeL":0.0,"exact_match_any":0},{"file":"crates\/router\/tests\/connectors\/airwallex.rs","mask_idx":0,"target_len":240,"prompt_snippet":"use std::str::FromStr;\n\nuse hyperswitch_domain_models::address::{Address, AddressDetails};\nuse masking::{PeekInterface, Secret};\nuse router::types::{self, domain, storage::enums, AccessToken};\n\nuse crate::{\n    connector_auth,\n    utils::{self, Connector, ConnectorActions},\n};\n\n#[derive(Clone, Copy)]\nstruct AirwallexTest;\nimpl ConnectorActions for AirwallexTest {}\n\nstatic CONNECTOR: AirwallexTest ...","target_snippet":"\n        use router::connector::Airwallex;\n        utils::construct_connector_data_old(\n            Box::new(&Airwallex),\n            types::Connector::Airwallex,\n            types::api::GetToken::Connector,\n            None,\n        )\n    ","generations":["","",""],"best_token_recall":0.0,"best_bleu":0.0,"best_rougeL":0.0,"exact_match_any":0},{"file":"crates\/router\/tests\/connectors\/airwallex.rs","mask_idx":1,"target_len":239,"prompt_snippet":"use std::str::FromStr;\n\nuse hyperswitch_domain_models::address::{Address, AddressDetails};\nuse masking::{PeekInterface, Secret};\nuse router::types::{self, domain, storage::enums, AccessToken};\n\nuse crate::{\n    connector_auth,\n    utils::{self, Connector, ConnectorActions},\n};\n\n#[derive(Clone, Copy)]\nstruct AirwallexTest;\nimpl ConnectorActions for AirwallexTest {}\n\nstatic CONNECTOR: AirwallexTest ...","target_snippet":"\n        utils::to_connector_auth_type(\n            connector_auth::ConnectorAuthentication::new()\n                .airwallex\n                .expect(\"Missing connector authentication configuration\")\n                .into(),\n        )\n    ","generations":["","",""],"best_token_recall":0.0,"best_bleu":0.0,"best_rougeL":0.0,"exact_match_any":0},{"file":"crates\/router\/tests\/connectors\/airwallex.rs","mask_idx":2,"target_len":37,"prompt_snippet":"use std::str::FromStr;\n\nuse hyperswitch_domain_models::address::{Address, AddressDetails};\nuse masking::{PeekInterface, Secret};\nuse router::types::{self, domain, storage::enums, AccessToken};\n\nuse crate::{\n    connector_auth,\n    utils::{self, Connector, ConnectorActions},\n};\n\n#[derive(Clone, Copy)]\nstruct AirwallexTest;\nimpl ConnectorActions for AirwallexTest {}\n\nstatic CONNECTOR: AirwallexTest ...","target_snippet":"\n        \"airwallex\".to_string()\n    ","generations":["","",""],"best_token_recall":0.0,"best_bleu":0.0,"best_rougeL":0.0,"exact_match_any":0},{"file":"crates\/hyperswitch_connectors\/src\/connectors\/fiserv\/transformers.rs","mask_idx":0,"target_len":79,"prompt_snippet":"use common_enums::enums;\nuse common_utils::{ext_traits::ValueExt, pii, types::FloatMajorUnit};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsRespo...","target_snippet":"\n        Ok(Self {\n            amount,\n            router_data,\n        })\n    ","generations":["","",""],"best_token_recall":0.0,"best_bleu":0.0,"best_rougeL":0.0,"exact_match_any":0},{"file":"crates\/hyperswitch_connectors\/src\/connectors\/fiserv\/transformers.rs","mask_idx":1,"target_len":3437,"prompt_snippet":"use common_enums::enums;\nuse common_utils::{ext_traits::ValueExt, pii, types::FloatMajorUnit};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsRespo...","target_snippet":"\n        let auth: FiservAuthType = FiservAuthType::try_from(&item.router_data.connector_auth_type)?;\n        let amount = Amount {\n            total: item.amount,\n            currency: item.router_data.request.currency.to_string(),\n        };\n        let transaction_details = TransactionDetails {\n            capture_flag: Some(matches!(\n                item.router_data.request.capture_method,\n   ...","generations":["","",""],"best_token_recall":0.0,"best_bleu":0.0,"best_rougeL":0.0,"exact_match_any":0},{"file":"crates\/hyperswitch_connectors\/src\/connectors\/fiserv\/transformers.rs","mask_idx":2,"target_len":425,"prompt_snippet":"use common_enums::enums;\nuse common_utils::{ext_traits::ValueExt, pii, types::FloatMajorUnit};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{ConnectorAuthType, RouterData},\n    router_flow_types::refunds::{Execute, RSync},\n    router_request_types::ResponseId,\n    router_response_types::{PaymentsResponseData, RefundsRespo...","target_snippet":"\n        if let ConnectorAuthType::SignatureKey {\n            api_key,\n            key1,\n            api_secret,\n        } = auth_type\n        {\n            Ok(Self {\n                api_key: api_key.to_owned(),\n                merchant_account: key1.to_owned(),\n                api_secret: api_secret.to_owned(),\n            })\n        } else {\n            Err(errors::ConnectorError::FailedToObtain...","generations":["","",""],"best_token_recall":0.0,"best_bleu":0.0,"best_rougeL":0.0,"exact_match_any":0},{"file":"crates\/router\/tests\/health_check.rs","mask_idx":0,"target_len":150,"prompt_snippet":"mod utils;\n\nuse utils::{mk_service, AppClient};\n\n#[actix_web::test]\nasync fn health_check() {","target_snippet":"\n    let server = Box::pin(mk_service()).await;\n    let client = AppClient::guest();\n\n    assert_eq!(client.health(&server).await, \"health is good\");\n","generations":["","",""],"best_token_recall":0.0,"best_bleu":0.0,"best_rougeL":0.0,"exact_match_any":0}]