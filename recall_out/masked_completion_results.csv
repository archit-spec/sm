file,mask_idx,target_len,prompt_snippet,target_snippet,generations,best_token_recall,best_bleu,best_rougeL,exact_match_any
crates/hyperswitch_domain_models/src/customer.rs,0,31,"#[cfg(all(feature = ""v2"", feature = ""customer_v2""))]
use common_enums::DeleteStatus;
use common_utils::{
    crypto::{self, Encryptable},
    date_time,
    encryption::Encryption,
    errors::{CustomResult, ValidationError},
    id_type, pii,
    types::{
        keymanager::{self, KeyManagerState, ToEncryptable},
        Description,
    },
};
use diesel_models::customers::CustomerUpdateInternal...","
        &self.customer_id
    ","[' &self.customer_id }\n\n    /// Get the unique identifier of Customer\n    #[cfg(all(feature = ""v2"", feature = ""customer_v2""))]\n    pub fn get_id(&self) -> &id_type::GlobalCustomerId { &self.id }\n}\n\n#[cfg(all(any(feature = ""v1"", feature = ""v2""), not(feature = ""customer_v2"")))]\nimpl Customer {\n    pub fn new(\n        customer_id: id_type::CustomerId,\n        merchant_id: id_type::MerchantId,\n        name: Option<String>,\n        email: Option<String>,\n        phone: Option<String>,\n        phone_country_code: Option<String>,\n        description: Option<Description>,\n        created_at: PrimitiveDateTime,\n        metadata: Option<pii::SecretSerdeValue>,\n        modified_at: PrimitiveDateTime,\n        connector_customer: Option<pii::SecretSerdeValue>,\n        address_id: Option<String>,\n        default_payment_method_id: Option<String>,\n        updated_by: Option<String>,\n        version: common_enums::ApiVersion,\n    ) -> Self {\n        Self {\n            customer_id,\n            merchant_id,\n            name: name.map(|name| Encryptable::new(Secret::new(name))),\n            email: email.map(|email| Encryptable::new(Secret::new(email))),\n            phone: phone.map(|phone| Encryptable::new(Secret::new(phone))),\n            phone_country_code,\n            description,\n            created_at,\n            metadata,\n            modified_at,\n            connector_customer,\n            address_id,\n            default_payment_method_id,\n            updated_by,\n            version,\n        }\n    }\n}\n\n#[cfg(all(feature = ""v2"", feature = ""customer_v2""))]\nimpl Customer {\n    pub fn new(\n        merchant_id: id_type::MerchantId,\n        name: Option<String>,\n        email: Option<String>,\n        phone: Option<String>,\n        phone_country_code: Option<String>,\n        description: Option<Description>,\n        created_at: PrimitiveDateTime,\n        metadata: Option<pii::SecretSerdeValue>,\n        connector_customer: Option<common_types::customers::ConnectorCustomerMap>,\n        modified_at: PrimitiveDateTime,\n        default_payment_method_id: Option<id_type::GlobalPaymentMethodId>,\n        updated_by: Option<String>,\n        merchant_reference_id: Option<id_type::CustomerId>,\n        default_billing_address: Option<Encryption>,\n        default_shipping_address: Option<Encryption>,\n        id: id_type::GlobalCustomerId,\n        version: common_enums::ApiVersion,\n        status: DeleteStatus,\n    ) -> Self {\n        Self {\n            merchant_id,\n            name: name.map(|name| Encryptable::new(Secret::new(name))),\n            email: email.map(|email| Encryptable::new(Secret::new(email))),\n            phone: phone.map(|phone| Encryptable::new(Secret::new(phone))),\n            phone_country_code,\n            description,\n            created_at,\n            metadata,\n            connector_customer,\n            modified_at,\n            default_payment_method_id,\n            updated_by,\n            merchant_reference_id,\n            default_billing_address,\n            default_shipping_address,\n            id,\n            version,\n            status,\n        }\n    }\n}\n\n#[cfg(all(any(feature = ""v1"", feature = ""v2""), not(feature = ""customer_v2"")))]\nimpl Customer {\n    pub fn get_customer_id(&self) -> &id_type::CustomerId { &self.customer_id }\n    pub fn get_merchant_id(&self) -> &id_type::MerchantId { &self.merchant_id }\n}\n\n#[cfg(all(feature = ""v2"", feature = ""customer_v2""))]\nimpl Customer {\n    pub fn get_customer_id(&self) -> &id_type::GlobalCustomerId { &self.id }\n    pub fn get_merchant_id(&self) -> &id_type::MerchantId { &self.merchant_id }\n}\n\n#[cfg(all(any(feature = ""v1"", feature = ""v2""), not(feature = ""customer_v2"")))]\nimpl Customer {\n    pub fn get_merchant_reference_id(&self) -> Option<&id_type::CustomerId> {\n        self.merchant_reference_id.as_ref()\n    }\n}\n\n#[cfg(all(feature = ""v2"", feature = ""customer_v2""))]\nimpl Customer {\n    pub fn get_merchant_reference_id(&self) -> Option<&id_type::CustomerId> {\n        self.merchant_reference_id.as_ref()\n    }\n}\n\n#[cfg(all(any(feature = ""v1"", feature = ""v2""), not(feature = ""customer_v2"")))]\nimpl Customer {\n    pub fn get_customer_id(&self) -> id_type::CustomerId {\n        self.customer_id.clone()\n    }\n    pub fn get_merchant_id(&self) -> id_type::MerchantId {\n        self.merchant_id.clone()\n    }\n}\n\n#[cfg(all(feature = ""v2"", feature = ""customer_v2""))]\nimpl Customer {\n    pub fn get_customer_id(&self) -> id_type::GlobalCustomerId {\n        self.id.clone()\n    }\n    pub fn get_merchant_id(&self) ->', '', '']",0.875,0.3634442277848664,1.2024048096192386,0
crates/hyperswitch_domain_models/src/customer.rs,1,22,"#[cfg(all(feature = ""v2"", feature = ""customer_v2""))]
use common_enums::DeleteStatus;
use common_utils::{
    crypto::{self, Encryptable},
    date_time,
    encryption::Encryption,
    errors::{CustomResult, ValidationError},
    id_type, pii,
    types::{
        keymanager::{self, KeyManagerState, ToEncryptable},
        Description,
    },
};
use diesel_models::customers::CustomerUpdateInternal...","
        &self.id
    ","[' &self.id }\n\n    /// Get the merchant identifier of Customer\n    pub fn get_merchant_id(&self) -> &id_type::MerchantId {\n        &self.merchant_id\n    }\n\n    /// Get the name of Customer\n    #[cfg(all(any(feature = ""v1"", feature = ""v2""), not(feature = ""customer_v2"")))]\n    pub fn get_name(&self) -> Option<&Secret<String>> {\n        self.name.as_ref()\n    }\n\n    /// Get the name of Customer\n    #[cfg(all(feature = ""v2"", feature = ""customer_v2""))]\n    pub fn get_name(&self) -> Option<&Secret<String>> {\n        self.name.as_ref()\n    }\n\n    /// Get the email of Customer\n    #[cfg(all(any(feature = ""v1"", feature = ""v2""), not(feature = ""customer_v2"")))]\n    pub fn get_email(&self) -> Option<&Encryptable<Secret<String, pii::EmailStrategy>> {\n        self.email.as_ref()\n    }\n\n    /// Get the email of Customer\n    #[cfg(all(feature = ""v2"", feature = ""customer_v2""))]\n    pub fn get_email(&self) -> Option<&Encryptable<Secret<String, pii::EmailStrategy>> {\n        self.email.as_ref()\n    }\n\n    /// Get the phone of Customer\n    #[cfg(all(any(feature = ""v1"", feature = ""v2""), not(feature = ""customer_v2"")))]\n    pub fn get_phone(&self) -> Option<&Encryptable<Secret<String>> {\n        self.phone.as_ref()\n    }\n\n    /// Get the phone of Customer\n    #[cfg(all(feature = ""v2"", feature = ""customer_v2""))]\n    pub fn get_phone(&self) -> Option<&Encryptable<Secret<String>> {\n        self.phone.as_ref()\n    }\n\n    /// Get the phone country code of Customer\n    #[cfg(all(any(feature = ""v1"", feature = ""v2""), not(feature = ""customer_v2"")))]\n    pub fn get_phone_country_code(&self) -> Option<&String> {\n        self.phone_country_code.as_ref()\n    }\n\n    /// Get the phone country code of Customer\n    #[cfg(all(feature = ""v2"", feature = ""customer_v2""))]\n    pub fn get_phone_country_code(&self) -> Option<&String> {\n        self.phone_country_code.as_ref()\n    }\n\n    /// Get the description of Customer\n    #[cfg(all(any(feature = ""v1"", feature = ""v2""), not(feature = ""customer_v2"")))]\n    pub fn get_description(&self) -> Option<&Description> {\n        self.description.as_ref()\n    }\n\n    /// Get the description of Customer\n    #[cfg(all(feature = ""v2"", feature = ""customer_v2""))]\n    pub fn get_description(&self) -> Option<&Description> {\n        self.description.as_ref()\n    }\n\n    /// Get the metadata of Customer\n    #[cfg(all(any(feature = ""v1"", feature = ""v2""), not(feature = ""customer_v2"")))]\n    pub fn get_metadata(&self) -> Option<&pii::SecretSerdeValue> {\n        self.metadata.as_ref()\n    }\n\n    /// Get the metadata of Customer\n    #[cfg(all(feature = ""v2"", feature = ""customer_v2""))]\n    pub fn get_metadata(&self) -> Option<&pii::SecretSerdeValue> {\n        self.metadata.as_ref()\n    }\n\n    /// Get the connector customer of Customer\n    #[cfg(all(any(feature = ""v1"", feature = ""v2""), not(feature = ""customer_v2"")))]\n    pub fn get_connector_customer(&self) -> Option<&pii::SecretSerdeValue> {\n        self.connector_customer.as_ref()\n    }\n\n    /// Get the connector customer of Customer\n    #[cfg(all(feature = ""v2"", feature = ""customer_v2""))]\n    pub fn get_connector_customer(&self) -> Option<&common_types::customers::ConnectorCustomerMap> {\n        self.connector_customer.as_ref()\n    }\n\n    /// Get the default payment method id of Customer\n    #[cfg(all(any(feature = ""v1"", feature = ""v2""), not(feature = ""customer_v2"")))]\n    pub fn get_default_payment_method_id(&self) -> Option<&String> {\n        self.default_payment_method_id.as_ref()\n    }\n\n    /// Get the default payment method id of Customer\n    #[cfg(all(feature = ""v2"", feature = ""customer_v2""))]\n    pub fn get_default_payment_method_id(&self) -> Option<&id_type::GlobalPaymentMethodId> {\n        self.default_payment_method_id.as_ref()\n    }\n\n    /// Get the updated by of Customer\n    #[cfg(all(any(feature = ""v1"", feature = ""v2""), not(feature = ""customer_v2"")))]\n    pub fn get_updated_by(&self) -> Option<&String> {\n        self.updated_by.as_ref()\n    }\n\n   ', '', '']",0.8571428571428571,0.17842521066982625,0.7843137254901961,0
crates/hyperswitch_domain_models/src/customer.rs,2,303,"#[cfg(all(feature = ""v2"", feature = ""customer_v2""))]
use common_enums::DeleteStatus;
use common_utils::{
    crypto::{self, Encryptable},
    date_time,
    encryption::Encryption,
    errors::{CustomResult, ValidationError},
    id_type, pii,
    types::{
        keymanager::{self, KeyManagerState, ToEncryptable},
        Description,
    },
};
use diesel_models::customers::CustomerUpdateInternal...","
        use masking::PeekInterface;

        self.connector_customer
            .as_ref()
            .and_then(|connector_customer_value| {
                connector_customer_value.peek().get(connector_label)
            })
            .and_then(|connector_customer| connector_customer.as_str())
    ","[' // TODO: Remove this function\n        self.connector_customer.as_ref().and_then(|connector_customer| {\n            connector_customer\n                .iter()\n                .find(|(connector_label, _)| connector_label == connector_label)\n                .map(|(_, connector_customer_id)| connector_customer_id)\n        })\n    }\n\n    /// Get the connector customer ID for the specified connector label, if present\n    #[cfg(all(feature = ""v2"", feature = ""customer_v2""))]\n    pub fn get_connector_customer_id(&self, connector_label: &str) -> Option<&str> {\n        self.connector_customer.as_ref().and_then(|connector_customer| {\n            connector_customer\n                .iter()\n                .find(|(connector_label, _)| connector_label == connector_label)\n                .map(|(_, connector_customer_id)| connector_customer_id)\n        })\n    }\n\n    /// Get the connector customer ID for the specified connector label, if present\n    #[cfg(all(any(feature = ""v1"", feature = ""v2""), not(feature = ""customer_v2"")))]\n    pub fn get_connector_customer_id_for_merchant_connector_id(\n        &self,\n        merchant_connector_id: &str,\n    ) -> Option<&str> {\n        self.connector_customer.as_ref().and_then(|connector_customer| {\n            connector_customer\n                .iter()\n                .find(|(connector_label, _)| connector_label == merchant_connector_id)\n                .map(|(_, connector_customer_id)| connector_customer_id)\n        })\n    }\n\n    /// Get the connector customer ID for the specified connector label, if present\n    #[cfg(all(feature = ""v2"", feature = ""customer_v2""))]\n    pub fn get_connector_customer_id_for_merchant_connector_id(\n        &self,\n        merchant_connector_id: &str,\n    ) -> Option<&str> {\n        self.connector_customer.as_ref().and_then(|connector_customer| {\n            connector_customer\n                .iter()\n                .find(|(connector_label, _)| connector_label == merchant_connector_id)\n                .map(|(_, connector_customer_id)| connector_customer_id)\n        })\n    }\n\n    /// Get the connector customer ID for the specified connector label, if present\n    #[cfg(all(any(feature = ""v1"", feature = ""v2""), not(feature = ""customer_v2"")))]\n    pub fn get_connector_customer_id_for_merchant_connector_id_and_merchant_id(\n        &self,\n        merchant_connector_id: &str,\n        merchant_id: &id_type::MerchantId,\n    ) -> Option<&str> {\n        self.connector_customer.as_ref().and_then(|connector_customer| {\n            connector_customer\n                .iter()\n                .find(|(connector_label, _)| connector_label == merchant_connector_id)\n                .map(|(_, connector_customer_id)| connector_customer_id)\n        })\n    }\n\n    /// Get the connector customer ID for the specified connector label, if present\n    #[cfg(all(feature = ""v2"", feature = ""customer_v2""))]\n    pub fn get_connector_customer_id_for_merchant_connector_id_and_merchant_id(\n        &self,\n        merchant_connector_id: &str,\n        merchant_id: &id_type::MerchantId,\n    ) -> Option<&str> {\n        self.connector_customer.as_ref().and_then(|connector_customer| {\n            connector_customer\n                .iter()\n                .find(|(connector_label, _)| connector_label == merchant_connector_id)\n                .map(|(_, connector_customer_id)| connector_customer_id)\n        })\n    }\n\n    /// Get the connector customer ID for the specified connector label, if present\n    #[cfg(all(any(feature = ""v1"", feature = ""v2""), not(feature = ""customer_v2"")))]\n    pub fn get_connector_customer_id_for_merchant_connector_id_and_merchant_id_and_profile_id(\n        &self,\n        merchant_connector_id: &str,\n        merchant_id: &id_type::MerchantId,\n        profile_id: &id_type::ProfileId,\n    ) -> Option<&str> {\n        self.connector_customer.as_ref().and_then(|connector_customer| {\n            connector_customer\n                .iter()\n                .find(|(connector_label, _)| connector_label == merchant_connector_id)\n                .map(|(_, connector_customer_id)| connector_customer_id)\n        })\n    }\n\n    /// Get the connector customer ID for the specified connector label, if present\n    #[cfg(all(feature = ""v2"", feature = ""customer_v2""))]\n    pub fn get_connector_customer_id_for_merchant_connector_id_and_merchant_id_and_profile_id(\n        &self,\n        merchant_connector_id: &str,\n        merchant_id: &id_type::MerchantId,\n        profile_id: &id_type::ProfileId,\n    ) -> Option<&str> {\n        self.connector_customer.as_ref().and_then(|connector_customer| {\n            connector_customer\n                .iter()\n                .find(|(connector_label, _)| connector_label == merchant_connector_id)\n                .map(|(_, connector_customer_id)| connector_customer_id)\n        })\n    }\n\n   ', '', '']",0.7142857142857143,3.648915837223974,7.956600361663652,0
crates/router/tests/connectors/zsl.rs,0,307,"use router::types::{self, storage::enums};
use test_utils::connector_auth;

use crate::utils::{self, ConnectorActions};

struct ZslTest;
impl ConnectorActions for ZslTest {}
impl utils::Connector for ZslTest {
    fn get_data(&self) -> types::api::ConnectorData {","
        use router::connector::Zsl;
        utils::construct_connector_data_old(
            Box::new(&Zsl),
            types::Connector::Adyen,
            // Added as Dummy connector as template code is added for future usage
            types::api::GetToken::Connector,
            None,
        )
    ","[' utils::construct_connector_data_old(""zsl"", types::Connector::Zsl) }\n    fn get_auth_token(&self) -> types::ConnectorAuthType { utils::to_connector_auth_type(connector_auth::ConnectorAuthentication::new().zsl) }\n    fn get_name(&self) -> String { ""zsl"".to_string() }\n}\n\nstatic CONNECTOR: ZslTest = ZslTest {};\n\nfn get_default_payment_info() -> Option<utils::PaymentInfo> {\n    None\n}\n\nfn payment_method_details() -> Option<types::PaymentsAuthorizeData> {\n    None\n}\n\n// Cards Positive Tests\n// Creates a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_only_authorize_payment() {\n    let response = CONNECTOR\n        .authorize_payment(payment_method_details(), get_default_payment_info())\n        .await\n        .expect(""Authorize payment response"");\n    assert_eq!(response.status, enums::AttemptStatus::Authorized);\n}\n\n// Captures a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_capture_authorized_payment() {\n    let response = CONNECTOR\n        .authorize_and_capture_payment(payment_method_details(), None, get_default_payment_info())\n        .await\n        .expect(""Capture payment response"");\n    assert_eq!(response.status, enums::AttemptStatus::Charged);\n}\n\n// Partially captures a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_partially_capture_authorized_payment() {\n    let response = CONNECTOR\n        .authorize_and_capture_payment(\n            payment_method_details(),\n            Some(types::PaymentsCaptureData {\n                amount_to_capture: 50,\n                ..utils::PaymentCaptureType::default().0\n            }),\n            get_default_payment_info(),\n        )\n        .await\n        .expect(""Capture payment response"");\n    assert_eq!(response.status, enums::AttemptStatus::Charged);\n}\n\n// Synchronizes a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_sync_authorized_payment() {\n    let authorize_response = CONNECTOR\n        .authorize_payment(payment_method_details(), get_default_payment_info())\n        .await\n        .expect(""Authorize payment response"");\n    let txn_id = utils::get_connector_transaction_id(authorize_response.response);\n    let response = CONNECTOR\n        .psync_retry_till_status_matches(\n            enums::AttemptStatus::Authorized,\n            Some(types::PaymentsSyncData {\n                connector_transaction_id: types::ResponseId::ConnectorTransactionId(\n                    txn_id.unwrap(),\n                ),\n                ..Default::default()\n            }),\n            get_default_payment_info(),\n        )\n        .await\n        .expect(""PSync response"");\n    assert_eq!(response.status, enums::AttemptStatus::Authorized,);\n}\n\n// Voids a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_void_authorized_payment() {\n    let response = CONNECTOR\n        .authorize_and_void_payment(\n            payment_method_details(),\n            Some(types::PaymentsCancelData {\n                connector_transaction_id: String::from(""""),\n                cancellation_reason: Some(""requested_by_customer"".to_string()),\n                ..Default::default()\n            }),\n            get_default_payment_info(),\n        )\n        .await\n        .expect(""Void payment response"");\n    assert_eq!(response.status, enums::AttemptStatus::Voided);\n}\n\n// Refunds a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_refund_manually_captured_payment() {\n    let response = CONNECTOR\n        .capture_payment_and_refund(\n            payment_method_details(),\n            None,\n            None,\n            get_default_payment_info(),\n        )\n        .await\n        .unwrap();\n    assert_eq!(\n        response.response.unwrap().refund_status,\n        enums::RefundStatus::Success,\n    );\n}\n\n// Partially refunds a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_partially_refund_manually_captured_payment() {\n    let response = CONNECTOR\n        .capture_payment_and_refund(\n            payment_method_details(),\n            None,\n            Some(types::RefundsData {\n                refund_amount: 50,\n                ..utils::PaymentRefundType::default().0\n            }),\n            get_default_payment_info(),\n        )\n        .await\n        .unwrap();\n    assert_eq!(\n        response.response.unwrap().refund_status,\n        enums::RefundStatus::Success,\n    );\n}\n\n// Synchronizes a refund using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_sync_manually_captured_refund() {\n    let refund_response = CONNECTOR\n        .capture_payment_and_refund(\n            payment_method_details(),\n            None,\n            None,\n            get_default_payment_info(),\n        )\n        .await\n       ', '', '']",0.6307692307692307,2.1378212226906985,4.878048780487805,0
crates/router/tests/connectors/zsl.rs,1,233,"use router::types::{self, storage::enums};
use test_utils::connector_auth;

use crate::utils::{self, ConnectorActions};

struct ZslTest;
impl ConnectorActions for ZslTest {}
impl utils::Connector for ZslTest {
    fn get_data(&self) -> types::api::ConnectorData {
        use router::connector::Zsl;
        utils::construct_connector_data_old(
            Box::new(&Zsl),
            types::Connecto...","
        utils::to_connector_auth_type(
            connector_auth::ConnectorAuthentication::new()
                .zsl
                .expect(""Missing connector authentication configuration"")
                .into(),
        )
    ","[' connector_auth::ConnectorAuthentication::new().zsl }\n\n    fn get_name(&self) -> String {\n        ""zsl"".to_string()\n    }\n}\n\nstatic CONNECTOR: ZslTest = ZslTest {};\n\nfn get_default_payment_info() -> Option<utils::PaymentInfo> {\n    None\n}\n\nfn payment_method_details() -> Option<types::PaymentsAuthorizeData> {\n    None\n}\n\n// Cards Positive Tests\n// Creates a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_only_authorize_payment() {\n    let response = CONNECTOR\n        .authorize_payment(payment_method_details(), get_default_payment_info())\n        .await\n        .expect(""Authorize payment response"");\n    assert_eq!(response.status, enums::AttemptStatus::Authorized);\n}\n\n// Captures a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_capture_authorized_payment() {\n    let response = CONNECTOR\n        .authorize_and_capture_payment(payment_method_details(), None, get_default_payment_info())\n        .await\n        .expect(""Capture payment response"");\n    assert_eq!(response.status, enums::AttemptStatus::Charged);\n}\n\n// Partially captures a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_partially_capture_authorized_payment() {\n    let response = CONNECTOR\n        .authorize_and_capture_payment(\n            payment_method_details(),\n            Some(types::PaymentsCaptureData {\n                amount_to_capture: 50,\n                ..utils::PaymentCaptureType::default().0\n            }),\n            get_default_payment_info(),\n        )\n        .await\n        .expect(""Capture payment response"");\n    assert_eq!(response.status, enums::AttemptStatus::Charged);\n}\n\n// Synchronizes a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_sync_authorized_payment() {\n    let authorize_response = CONNECTOR\n        .authorize_payment(payment_method_details(), get_default_payment_info())\n        .await\n        .expect(""Authorize payment response"");\n    let txn_id = utils::get_connector_transaction_id(authorize_response.response);\n    let response = CONNECTOR\n        .psync_retry_till_status_matches(\n            enums::AttemptStatus::Authorized,\n            Some(types::PaymentsSyncData {\n                connector_transaction_id: types::ResponseId::ConnectorTransactionId(\n                    txn_id.unwrap(),\n                ),\n                ..Default::default()\n            }),\n            get_default_payment_info(),\n        )\n        .await\n        .expect(""PSync response"");\n    assert_eq!(response.status, enums::AttemptStatus::Authorized,);\n}\n\n// Voids a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_void_authorized_payment() {\n    let response = CONNECTOR\n        .authorize_and_void_payment(\n            payment_method_details(),\n            Some(types::PaymentsCancelData {\n                connector_transaction_id: String::from(""""),\n                cancellation_reason: Some(""requested_by_customer"".to_string()),\n                ..Default::default()\n            }),\n            get_default_payment_info(),\n        )\n        .await\n        .expect(""Void payment response"");\n    assert_eq!(response.status, enums::AttemptStatus::Voided);\n}\n\n// Refunds a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_refund_manually_captured_payment() {\n    let response = CONNECTOR\n        .capture_payment_and_refund(\n            payment_method_details(),\n            None,\n            None,\n            get_default_payment_info(),\n        )\n        .await\n        .unwrap();\n    assert_eq!(\n        response.response.unwrap().refund_status,\n        enums::RefundStatus::Success,\n    );\n}\n\n// Partially refunds a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_partially_refund_manually_captured_payment() {\n    let response = CONNECTOR\n        .capture_payment_and_refund(\n            payment_method_details(),\n            None,\n            Some(types::RefundsData {\n                refund_amount: 50,\n                ..utils::PaymentRefundType::default().0\n            }),\n            get_default_payment_info(),\n        )\n        .await\n        .unwrap();\n    assert_eq!(\n        response.response.unwrap().refund_status,\n        enums::RefundStatus::Success,\n    );\n}\n\n// Synchronizes a refund using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_sync_manually_captured_refund() {\n    let refund_response = CONNECTOR\n        .capture_payment_and_refund(\n            payment_method_details(),\n            None,\n            None,\n            get_default_payment_info(),\n        )\n        .await\n        .unwrap();\n    let response = CONNECTOR\n        .rsync_retry_till_status_matches(\n            enums::RefundStatus::Success,\n            refund_response.response.unwrap().connector_refund_id', '', '']",0.8205128205128205,1.7783194774169828,2.7184466019417477,0
crates/router/tests/connectors/zsl.rs,2,31,"use router::types::{self, storage::enums};
use test_utils::connector_auth;

use crate::utils::{self, ConnectorActions};

struct ZslTest;
impl ConnectorActions for ZslTest {}
impl utils::Connector for ZslTest {
    fn get_data(&self) -> types::api::ConnectorData {
        use router::connector::Zsl;
        utils::construct_connector_data_old(
            Box::new(&Zsl),
            types::Connecto...","
        ""zsl"".to_string()
    ","[' ""zsl"".to_string() }\n}\n\nstatic CONNECTOR: ZslTest = ZslTest {};\n\nfn get_default_payment_info() -> Option<utils::PaymentInfo> {\n    None\n}\n\nfn payment_method_details() -> Option<types::PaymentsAuthorizeData> {\n    None\n}\n\n// Cards Positive Tests\n// Creates a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_only_authorize_payment() {\n    let response = CONNECTOR\n        .authorize_payment(payment_method_details(), get_default_payment_info())\n        .await\n        .expect(""Authorize payment response"");\n    assert_eq!(response.status, enums::AttemptStatus::Authorized);\n}\n\n// Captures a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_capture_authorized_payment() {\n    let response = CONNECTOR\n        .authorize_and_capture_payment(payment_method_details(), None, get_default_payment_info())\n        .await\n        .expect(""Capture payment response"");\n    assert_eq!(response.status, enums::AttemptStatus::Charged);\n}\n\n// Partially captures a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_partially_capture_authorized_payment() {\n    let response = CONNECTOR\n        .authorize_and_capture_payment(\n            payment_method_details(),\n            Some(types::PaymentsCaptureData {\n                amount_to_capture: 50,\n                ..utils::PaymentCaptureType::default().0\n            }),\n            get_default_payment_info(),\n        )\n        .await\n        .expect(""Capture payment response"");\n    assert_eq!(response.status, enums::AttemptStatus::Charged);\n}\n\n// Synchronizes a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_sync_authorized_payment() {\n    let authorize_response = CONNECTOR\n        .authorize_payment(payment_method_details(), get_default_payment_info())\n        .await\n        .expect(""Authorize payment response"");\n    let txn_id = utils::get_connector_transaction_id(authorize_response.response);\n    let response = CONNECTOR\n        .psync_retry_till_status_matches(\n            enums::AttemptStatus::Authorized,\n            Some(types::PaymentsSyncData {\n                connector_transaction_id: types::ResponseId::ConnectorTransactionId(\n                    txn_id.unwrap(),\n                ),\n                ..Default::default()\n            }),\n            get_default_payment_info(),\n        )\n        .await\n        .expect(""PSync response"");\n    assert_eq!(response.status, enums::AttemptStatus::Authorized,);\n}\n\n// Voids a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_void_authorized_payment() {\n    let response = CONNECTOR\n        .authorize_and_void_payment(\n            payment_method_details(),\n            Some(types::PaymentsCancelData {\n                connector_transaction_id: String::from(""""),\n                cancellation_reason: Some(""requested_by_customer"".to_string()),\n                ..Default::default()\n            }),\n            get_default_payment_info(),\n        )\n        .await\n        .expect(""Void payment response"");\n    assert_eq!(response.status, enums::AttemptStatus::Voided);\n}\n\n// Refunds a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_refund_manually_captured_payment() {\n    let response = CONNECTOR\n        .capture_payment_and_refund(\n            payment_method_details(),\n            None,\n            None,\n            get_default_payment_info(),\n        )\n        .await\n        .unwrap();\n    assert_eq!(\n        response.response.unwrap().refund_status,\n        enums::RefundStatus::Success,\n    );\n}\n\n// Partially refunds a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_partially_refund_manually_captured_payment() {\n    let response = CONNECTOR\n        .capture_payment_and_refund(\n            payment_method_details(),\n            None,\n            Some(types::RefundsData {\n                refund_amount: 50,\n                ..utils::PaymentRefundType::default().0\n            }),\n            get_default_payment_info(),\n        )\n        .await\n        .unwrap();\n    assert_eq!(\n        response.response.unwrap().refund_status,\n        enums::RefundStatus::Success,\n    );\n}\n\n// Synchronizes a refund using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_sync_manually_captured_refund() {\n    let refund_response = CONNECTOR\n        .capture_payment_and_refund(\n            payment_method_details(),\n            None,\n            None,\n            get_default_payment_info(),\n        )\n        .await\n        .unwrap();\n    let response = CONNECTOR\n        .rsync_retry_till_status_matches(\n            enums::RefundStatus::Success,\n            refund_response.response.unwrap().connector_refund_id,\n            None,\n            get_default_payment_info(),\n        )\n        .await\n        .unwrap();\n    assert_eq', '', '']",0.9,0.6473670043000328,1.1976047904191616,0
crates/analytics/src/disputes/filters.rs,0,592,"use api_models::analytics::{disputes::DisputeDimensions, Granularity, TimeRange};
use common_utils::errors::ReportSwitchExt;
use diesel_models::enums::Currency;
use error_stack::ResultExt;
use time::PrimitiveDateTime;

use crate::{
    enums::AuthInfo,
    query::{Aggregate, GroupByClause, QueryBuilder, QueryFilter, ToSql, Window},
    types::{
        AnalyticsCollection, AnalyticsDataSource, DBE...","
    let mut query_builder: QueryBuilder<T> = QueryBuilder::new(AnalyticsCollection::Dispute);

    query_builder.add_select_column(dimension).switch()?;
    time_range
        .set_filter_clause(&mut query_builder)
        .attach_printable(""Error filtering time range"")
        .switch()?;

    auth.set_filter_clause(&mut query_builder).switch()?;

    query_builder.set_distinct();

    query_bui...","['    let mut query_builder: QueryBuilder<T> = QueryBuilder::new(AnalyticsCollection::DisputeSessionized);\n\n    query_builder.add_select_column(dimension).switch()?;\n    query_builder.add_select_column(Aggregate::Count {\n        field: None,\n        alias: Some(""count""),\n    })\n    .switch()?;\n\n    query_builder\n        .add_filter_clause(""dispute_stage"", DBEnumWrapper::DisputeWon)\n        .switch()?;\n\n    query_builder\n        .add_auth_filter_clause(auth)\n        .attach_printable(""Error filtering auth info"")\n        .switch()?;\n\n    query_builder\n        .add_time_range_filter_clause(time_range)\n        .attach_printable(""Error filtering time range"")\n        .switch()?;\n\n    query_builder\n        .execute_query::<DisputeFilterRow, _>(pool)\n        .await\n        .change_context(FiltersError::QueryBuildingError)?\n        .change_context(FiltersError::QueryExecutionFailure)?\n        .into_iter()\n        .map(|i| {\n            Ok((\n                i.currency.as_ref().map(|i| i.0.to_string()),\n                i.connector.clone(),\n                i.profile_id.clone(),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_reason.clone(),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute_stage.as_ref().map(|i| i.0.to_string()),\n                i.dispute', '', '']",0.9230769230769231,7.730139387310999,13.643410852713181,0
crates/analytics/src/refunds/metrics.rs,0,2703,"use api_models::analytics::{
    refunds::{
        RefundDimensions, RefundFilters, RefundMetrics, RefundMetricsBucketIdentifier, RefundType,
    },
    Granularity, TimeRange,
};
use diesel_models::enums as storage_enums;
use time::PrimitiveDateTime;
mod refund_count;
mod refund_processed_amount;
mod refund_success_count;
mod refund_success_rate;
mod sessionized_metrics;
use std::collections::Ha...","
    async fn load_metrics(
        &self,
        dimensions: &[RefundDimensions],
        auth: &AuthInfo,
        filters: &RefundFilters,
        granularity: Option<Granularity>,
        time_range: &TimeRange,
        pool: &T,
    ) -> MetricsResult<HashSet<(RefundMetricsBucketIdentifier, RefundMetricRow)>> {
        match self {
            Self::RefundSuccessRate => {
                Refu...","[' // TODO: Remove the redundant metrics\n    async fn load_metrics(\n        &self,\n        dimensions: &[RefundDimensions],\n        auth: &AuthInfo,\n        filters: &RefundFilters,\n        granularity: Option<Granularity>,\n        time_range: &TimeRange,\n        pool: &T,\n    ) -> MetricsResult<HashSet<(RefundMetricsBucketIdentifier, RefundMetricRow)>> {\n        let mut query_builder: crate::query::QueryBuilder<T> = crate::query::QueryBuilder::new(AnalyticsCollection::RefundSessionized);\n\n        for dim in dimensions.iter() {\n            query_builder.add_select_column(dim).switch()?;\n        }\n\n        query_builder\n            .add_select_column(Aggregate::Count {\n                field: None,\n                alias: Some(""count""),\n            })\n            .switch()?;\n\n        query_builder\n            .add_select_column(Aggregate::Min {\n                field: ""created_at"",\n                alias: Some(""start_bucket""),\n            })\n            .switch()?;\n\n        query_builder\n            .add_select_column(Aggregate::Max {\n                field: ""created_at"",\n                alias: Some(""end_bucket""),\n            })\n            .switch()?;\n\n        filters.set_filter_clause(&mut query_builder).switch()?;\n\n        auth.set_filter_clause(&mut query_builder).switch()?;\n\n        time_range\n            .set_filter_clause(&mut query_builder)\n            .attach_printable(""Error filtering time range"")\n            .switch()?;\n\n        for dim in dimensions.iter() {\n            query_builder.add_group_by_clause(dim).switch()?;\n        }\n\n        if let Some(granularity) = granularity {\n            granularity\n                .set_group_by_clause(&mut query_builder)\n                .attach_printable(""Error adding granularity"")\n                .switch()?;\n        }\n\n        query_builder\n            .execute_query::<RefundMetricRow, _>(pool)\n            .await\n            .change_context(""Error filtering metrics"")\n            .map(|metrics| {\n                metrics.into_iter().map(|i| {\n                    Ok((\n                        RefundMetricsBucketIdentifier::new(\n                            i.currency.as_ref().map(|i| i.0),\n                            i.refund_status.as_ref().map(|i| i.0),\n                            i.connector.as_ref().map(|i| i.0.to_owned()),\n                            i.refund_type.as_ref().map(|i| i.0),\n                            i.profile_id.as_ref().map(|i| i.0.to_owned()),\n                            i.refund_reason.as_ref().map(|i| i.0.to_owned()),\n                            i.refund_error_message.as_ref().map(|i| i.0.to_owned()),\n                            i.start_bucket,\n                            i.end_bucket,\n                        ),\n                        i,\n                    ))\n                })\n                .collect::<Result<\n                    HashSet<(RefundMetricsBucketIdentifier, RefundMetricRow)>,\n                    crate::query::PostProcessingError,\n                >>()\n                .change_context(crate::errors::AnalyticsError::PostProcessingFailure)\n            })\n            .change_context(crate::errors::AnalyticsError::QueryBuildingError)\n    }\n}\n\n#[async_trait::async_trait]\nimpl<T> RefundMetric<T> for RefundCount\nwhere\n    T: AnalyticsDataSource + RefundMetricAnalytics,\n    PrimitiveDateTime: ToSql<T>,\n    AnalyticsCollection: ToSql<T>,\n    Granularity: GroupByClause<T>,\n    Aggregate<&\'static str>: ToSql<T>,\n    Window<&\'static str>: ToSql<T>,\n{\n    async fn load_metrics(\n        &self,\n        dimensions: &[RefundDimensions],\n        auth: &AuthInfo,\n        filters: &RefundFilters,\n        granularity: Option<Granularity>,\n        time_range: &TimeRange,\n        pool: &T,\n    ) -> MetricsResult<HashSet<(RefundMetricsBucketIdentifier, RefundMetricRow)>> {\n        let mut query_builder: crate::query::QueryBuilder<T> = crate::query::QueryBuilder::new(AnalyticsCollection::RefundSessionized);\n\n        for dim in dimensions.iter() {\n            query_builder.add_select_column(dim).switch()?;\n        }\n\n        query_builder\n            .add_select_column(Aggregate::Count {\n                field: None,\n                alias: Some(""count""),\n            })\n            .switch()?;\n\n        query_builder\n            .add_select_column(Aggregate::Min {\n                field: ""created_at"",\n                alias: Some(""start_bucket""),\n            })\n            .switch()?;\n\n        query_builder\n            .add_select_column(Aggregate::Max {\n                field: ""created_at"",\n                alias: Some(""end_bucket""),\n            })\n            .switch()?;\n\n        filters.set_filter_clause(&mut query_builder).switch()?;\n\n        auth.set_filter_clause(&mut query_builder).switch()?;\n\n        time_range\n            .set_filter_clause(&mut query_builder)\n            .attach_printable(""Error filtering time range"")\n            .switch()?;\n\n        for dim in dimensions.iter() {\n            query_builder.add_group_by_clause(dim).switch()?;\n        }\n\n        if let Some(granularity)', '', '']",0.8455598455598455,10.040990395641714,17.86283891547049,0
crates/api_models/src/routing.rs,0,220,"use std::fmt::Debug;

use common_utils::{errors::ParsingError, ext_traits::ValueExt, pii};
pub use euclid::{
    dssa::types::EuclidAnalysable,
    frontend::{
        ast,
        dir::{DirKeyKind, EuclidDirFilter},
    },
};
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;

use crate::enums::{RoutableConnectors, TransactionType};

#[derive(Debug, Clone, Serialize, Deserialize, ToSchema...","
        match self {
            Self::Priority(list) => list.clone(),
            Self::VolumeSplit(splits) => {
                splits.iter().map(|split| split.connector.clone()).collect()
            }
        }
    ","[' self.get_priority_list() }\n\n    pub fn get_priority_list(&self) -> Vec<RoutableConnectorChoice> {\n        match self {\n            Self::Priority(connectors) => connectors.clone(),\n            Self::VolumeSplit(_) => vec![],\n        }\n    }\n\n    pub fn get_priority_connectors(&self) -> Vec<RoutableConnectors> {\n        self.get_priority_list()\n            .iter()\n            .map(|connector| connector.connector)\n            .collect()\n    }\n\n    pub fn get_priority_connectors_count(&self) -> usize {\n        self.get_priority_list().len()\n    }\n\n    pub fn get_priority_connectors_with_priority(&self) -> Vec<(RoutableConnectors, u8)> {\n        self.get_priority_list()\n            .iter()\n            .map(|connector| (connector.connector, connector.priority))\n            .collect()\n    }\n\n    pub fn get_priority_connectors_with_priority_and_transaction_type(\n        &self,\n        transaction_type: TransactionType,\n    ) -> Vec<(RoutableConnectors, u8, TransactionType)> {\n        self.get_priority_list()\n            .iter()\n            .map(|connector| {\n                let priority = connector.priority;\n                let transaction_type = connector.transaction_type.unwrap_or(transaction_type);\n                (connector.connector, priority, transaction_type)\n            })\n            .collect()\n    }\n\n    pub fn get_priority_connectors_with_priority_and_transaction_type_and_currency(\n        &self,\n        transaction_type: TransactionType,\n        currency: Option<common_enums::Currency>,\n    ) -> Vec<(RoutableConnectors, u8, TransactionType, Option<common_enums::Currency>)> {\n        self.get_priority_list()\n            .iter()\n            .map(|connector| {\n                let priority = connector.priority;\n                let transaction_type = connector.transaction_type.unwrap_or(transaction_type);\n                let currency = connector.currency.unwrap_or(currency);\n                (connector.connector, priority, transaction_type, currency)\n            })\n            .collect()\n    }\n\n    pub fn get_priority_connectors_with_priority_and_transaction_type_and_merchant_connector_id(\n        &self,\n        transaction_type: TransactionType,\n        merchant_connector_id: Option<String>,\n    ) -> Vec<(RoutableConnectors, u8, TransactionType, Option<String>)> {\n        self.get_priority_list()\n            .iter()\n            .map(|connector| {\n                let priority = connector.priority;\n                let transaction_type = connector.transaction_type.unwrap_or(transaction_type);\n                let merchant_connector_id = connector.merchant_connector_id.unwrap_or(merchant_connector_id);\n                (connector.connector, priority, transaction_type, merchant_connector_id)\n            })\n            .collect()\n    }\n\n    pub fn get_priority_connectors_with_priority_and_transaction_type_and_merchant_connector_id_and_payment_method(\n        &self,\n        transaction_type: TransactionType,\n        merchant_connector_id: Option<String>,\n        payment_method: Option<common_enums::PaymentMethod>,\n    ) -> Vec<(RoutableConnectors, u8, TransactionType, Option<String>, Option<common_enums::PaymentMethod>)> {\n        self.get_priority_list()\n            .iter()\n            .map(|connector| {\n                let priority = connector.priority;\n                let transaction_type = connector.transaction_type.unwrap_or(transaction_type);\n                let merchant_connector_id = connector.merchant_connector_id.unwrap_or(merchant_connector_id);\n                let payment_method = connector.payment_method.unwrap_or(payment_method);\n                (connector.connector, priority, transaction_type, merchant_connector_id, payment_method)\n            })\n            .collect()\n    }\n\n    pub fn get_priority_connectors_with_priority_and_transaction_type_and_merchant_connector_id_and_payment_method_type(\n        &self,\n        transaction_type: TransactionType,\n        merchant_connector_id: Option<String>,\n        payment_method_type: Option<common_enums::PaymentMethodType>,\n    ) -> Vec<(RoutableConnectors, u8, TransactionType, Option<String>, Option<common_enums::PaymentMethodType>)> {\n        self.get_priority_list()\n            .iter()\n            .map(|connector| {\n                let priority = connector.priority;\n                let transaction_type = connector.transaction_type.unwrap_or(transaction_type);\n                let merchant_connector_id = connector.merchant_connector_id.unwrap_or(merchant_connector_id);\n                let payment_method_type = connector.payment_method_type.unwrap_or(payment_method_type);\n                (connector.connector, priority, transaction_type, merchant_connector_id, payment_method_type)\n            })\n            .collect()\n    }\n\n    pub fn get_priority_connectors_with_priority_and_transaction_type_and_merchant_connector_id_and_payment_method_and_payment_experience(\n        &self,\n        transaction_type: TransactionType,\n        merchant_connector_id: Option<String>,\n        payment_method: Option<common_enums::PaymentMethod>,\n        payment_experience: Option<common_enums::PaymentExperience>,\n    ) -> Vec<(RoutableConnectors, u8, TransactionType, Option<String>, Option<common_enums::PaymentMethod>, Option<common_enums::PaymentExperience>)> {\n        self.get_priority_list()\n            .iter()\n            .map(|', '', '']",0.75,2.6585933222365794,4.104477611940299,0
crates/api_models/src/routing.rs,1,806,"use std::fmt::Debug;

use common_utils::{errors::ParsingError, ext_traits::ValueExt, pii};
pub use euclid::{
    dssa::types::EuclidAnalysable,
    frontend::{
        ast,
        dir::{DirKeyKind, EuclidDirFilter},
    },
};
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;

use crate::enums::{RoutableConnectors, TransactionType};

#[derive(Debug, Clone, Serialize, Deserialize, ToSchema...","
        self.get_connector_list()
            .into_iter()
            .map(|connector_choice| {
                let connector_name = connector_choice.connector.to_string();
                let mca_id = connector_choice.merchant_connector_id.clone();

                (
                    euclid::frontend::dir::DirValue::Connector(Box::new(connector_choice.into())),
                    std::colle...","[' ... }\n}\n\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, ToSchema)]\npub struct RoutingAlgorithm {\n    pub algorithm: Vec<RoutingAlgorithmChoice>,\n}\n\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, ToSchema)]\npub struct RoutingAlgorithmChoice {\n    pub condition: RoutingAlgorithmCondition,\n    pub connector_selection: ConnectorSelection,\n}\n\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, ToSchema)]\npub struct RoutingAlgorithmCondition {\n    pub payment_method: Option<String>,\n    pub payment_method_type: Option<String>,\n    pub payment_method_data: Option<String>,\n    pub payment_method_subtype: Option<String>,\n    pub payment_method_brand: Option<String>,\n    pub payment_method_issuer: Option<String>,\n    pub payment_method_issuing_country: Option<String>,\n    pub payment_method_issuing_city: Option<String>,\n    pub payment_method_issuing_zip: Option<String>,\n    pub payment_method_issuing_state: Option<String>,\n    pub payment_method_issuing_state_code: Option<String>,\n    pub payment_method_issuing_country_code: Option<String>,\n    pub payment_method_issuing_city_code: Option<String>,\n    pub payment_method_issuing_zip_code: Option<String>,\n    pub payment_method_issuing_state_code: Option<String>,\n    pub payment_method_issuing_country_code: Option<String>,\n    pub payment_method_issuing_city_code: Option<String>,\n    pub payment_method_issuing_zip_code: Option<String>,\n    pub payment_method_issuing_state_code: Option<String>,\n    pub payment_method_issuing_country_code: Option<String>,\n    pub payment_method_issuing_city_code: Option<String>,\n    pub payment_method_issuing_zip_code: Option<String>,\n    pub payment_method_issuing_state_code: Option<String>,\n    pub payment_method_issuing_country_code: Option<String>,\n    pub payment_method_issuing_city_code: Option<String>,\n    pub payment_method_issuing_zip_code: Option<String>,\n    pub payment_method_issuing_state_code: Option<String>,\n    pub payment_method_issuing_country_code: Option<String>,\n    pub payment_method_issuing_city_code: Option<String>,\n    pub payment_method_issuing_zip_code: Option<String>,\n    pub payment_method_issuing_state_code: Option<String>,\n    pub payment_method_issuing_country_code: Option<String>,\n    pub payment_method_issuing_city_code: Option<String>,\n    pub payment_method_issuing_zip_code: Option<String>,\n    pub payment_method_issuing_state_code: Option<String>,\n    pub payment_method_issuing_country_code: Option<String>,\n    pub payment_method_issuing_city_code: Option<String>,\n    pub payment_method_issuing_zip_code: Option<String>,\n    pub payment_method_issuing_state_code: Option<String>,\n    pub payment_method_issuing_country_code: Option<String>,\n    pub payment_method_issuing_city_code: Option<String>,\n    pub payment_method_issuing_zip_code: Option<String>,\n    pub payment_method_issuing_state_code: Option<String>,\n    pub payment_method_issuing_country_code: Option<String>,\n    pub payment_method_issuing_city_code: Option<String>,\n    pub payment_method_issuing_zip_code: Option<String>,\n    pub payment_method_issuing_state_code: Option<String>,\n    pub payment_method_issuing_country_code: Option<String>,\n    pub payment_method_issuing_city_code: Option<String>,\n    pub payment_method_issuing_zip_code: Option<String>,\n    pub payment_method_issuing_state_code: Option<String>,\n    pub payment_method_issuing_country_code: Option<String>,\n    pub payment_method_issuing_city_code: Option<String>,\n    pub payment_method_issuing_zip_code: Option<String>,\n    pub payment_method_issuing_state_code: Option<String>,\n    pub payment_method_issuing_country_code: Option<String>,\n    pub payment_method_issuing_city_code: Option<String>,\n    pub payment_method_issuing_zip_code: Option<String>,\n    pub payment_method_issuing_state_code: Option<String>,\n    pub payment_method_issuing_country_code: Option<String>,\n    pub payment_method_issuing_city_code: Option<String>,\n    pub payment_method_issuing_zip_code: Option<String>,\n    pub payment_method_issuing_state_code: Option<String>,\n    pub payment_method_issuing_country_code: Option<String>,\n    pub payment_method_issuing_city_code: Option<String>,\n    pub payment_method_issuing_zip_code: Option<String>,\n    pub payment_method_issuing_state_code: Option<String>,\n    pub payment_method_issuing_country_code: Option<String>,\n    pub payment_method_issuing_city_code: Option<String>,\n    pub payment_method_issuing_zip_code: Option<String>,\n    pub payment_method_issuing_state_code: Option<String>,\n    pub payment_method_issuing_country_code: Option<String>,\n    pub payment_method_issuing_city_code: Option<String>,\n    pub payment_method', '', '']",0.13432835820895522,0.2442588848181924,1.1851851851851851,0
crates/api_models/src/routing.rs,2,223,"use std::fmt::Debug;

use common_utils::{errors::ParsingError, ext_traits::ValueExt, pii};
pub use euclid::{
    dssa::types::EuclidAnalysable,
    frontend::{
        ast,
        dir::{DirKeyKind, EuclidDirFilter},
    },
};
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;

use crate::enums::{RoutableConnectors, TransactionType};

#[derive(Debug, Clone, Serialize, Deserialize, ToSchema...","
        let base = self.connector.to_string();
        if let Some(mca_id) = &self.merchant_connector_id {
            return write!(f, ""{}:{}"", base, mca_id.get_string_repr());
        }
        write!(f, ""{}"", base)
    ","[' write!(f, ""{}"", self.connector) }\n}\n\nimpl From<RoutableConnectorChoice> for ast::DirValue {\n    fn from(item: RoutableConnectorChoice) -> Self {\n        ast::DirValue::Connector(Box::new(item))\n    }\n}\n\nimpl From<RoutableConnectorChoice> for ast::DirValue {\n    fn from(item: RoutableConnectorChoice) -> Self {\n        ast::DirValue::Connector(Box::new(item))\n    }\n}\n\nimpl From<RoutableConnectorChoice> for ast::DirValue {\n    fn from(item: RoutableConnectorChoice) -> Self {\n        ast::DirValue::Connector(Box::new(item))\n    }\n}\n\nimpl From<RoutableConnectorChoice> for ast::DirValue {\n    fn from(item: RoutableConnectorChoice) -> Self {\n        ast::DirValue::Connector(Box::new(item))\n    }\n}\n\nimpl From<RoutableConnectorChoice> for ast::DirValue {\n    fn from(item: RoutableConnectorChoice) -> Self {\n        ast::DirValue::Connector(Box::new(item))\n    }\n}\n\nimpl From<RoutableConnectorChoice> for ast::DirValue {\n    fn from(item: RoutableConnectorChoice) -> Self {\n        ast::DirValue::Connector(Box::new(item))\n    }\n}\n\nimpl From<RoutableConnectorChoice> for ast::DirValue {\n    fn from(item: RoutableConnectorChoice) -> Self {\n        ast::DirValue::Connector(Box::new(item))\n    }\n}\n\nimpl From<RoutableConnectorChoice> for ast::DirValue {\n    fn from(item: RoutableConnectorChoice) -> Self {\n        ast::DirValue::Connector(Box::new(item))\n    }\n}\n\nimpl From<RoutableConnectorChoice> for ast::DirValue {\n    fn from(item: RoutableConnectorChoice) -> Self {\n        ast::DirValue::Connector(Box::new(item))\n    }\n}\n\nimpl From<RoutableConnectorChoice> for ast::DirValue {\n    fn from(item: RoutableConnectorChoice) -> Self {\n        ast::DirValue::Connector(Box::new(item))\n    }\n}\n\nimpl From<RoutableConnectorChoice> for ast::DirValue {\n    fn from(item: RoutableConnectorChoice) -> Self {\n        ast::DirValue::Connector(Box::new(item))\n    }\n}\n\nimpl From<RoutableConnectorChoice> for ast::DirValue {\n    fn from(item: RoutableConnectorChoice) -> Self {\n        ast::DirValue::Connector(Box::new(item))\n    }\n}\n\nimpl From<RoutableConnectorChoice> for ast::DirValue {\n    fn from(item: RoutableConnectorChoice) -> Self {\n        ast::DirValue::Connector(Box::new(item))\n    }\n}\n\nimpl From<RoutableConnectorChoice> for ast::DirValue {\n    fn from(item: RoutableConnectorChoice) -> Self {\n        ast::DirValue::Connector(Box::new(item))\n    }\n}\n\nimpl From<RoutableConnectorChoice> for ast::DirValue {\n    fn from(item: RoutableConnectorChoice) -> Self {\n        ast::DirValue::Connector(Box::new(item))\n    }\n}\n\nimpl From<RoutableConnectorChoice> for ast::DirValue {\n    fn from(item: RoutableConnectorChoice) -> Self {\n        ast::DirValue::Connector(Box::new(item))\n    }\n}\n\nimpl From<RoutableConnectorChoice> for ast::DirValue {\n    fn from(item: RoutableConnectorChoice) -> Self {\n        ast::DirValue::Connector(Box::new(item))\n    }\n}\n\nimpl From<RoutableConnectorChoice> for ast::DirValue {\n    fn from(item: RoutableConnectorChoice) -> Self {\n        ast::DirValue::Connector(Box::new(item))\n    }\n}\n\nimpl From<RoutableConnectorChoice> for ast::DirValue {\n    fn from(item: RoutableConnectorChoice) -> Self {\n        ast::DirValue::Connector(Box::new(item))\n    }\n}\n\nimpl From<RoutableConnectorChoice> for ast::DirValue {\n    fn from(item: RoutableConnectorChoice) -> Self {\n        ast::DirValue::Connector(Box::new(item))\n    }\n}\n\nimpl From<RoutableConnectorChoice> for ast::DirValue {\n    fn from(item: RoutableConnectorChoice) -> Self {\n        ast::DirValue::Connector(Box::new(item))\n    }\n}\n\nimpl From<RoutableConnectorChoice> for ast::DirValue {\n    fn from(item: RoutableConnectorChoice) -> Self {\n        ast::DirValue::Connector(Box::new(item))\n    }\n}\n\nimpl From<RoutableConnectorChoice> for ast::DirValue {\n    fn from(item: RoutableConnectorChoice) -> Self {\n        ast::DirValue::Connector(Box::new(item))\n    }\n}\n\nimpl From<RoutableConnectorChoice> for ast::DirValue {\n    fn from(item: RoutableConnectorChoice) -> Self {\n        ast::DirValue::Connector(Box::new(item))\n    }\n}\n\nimpl From<Routable', '', '']",0.39285714285714285,1.243567609938243,1.809954751131222,0
crates/router/src/db/api_keys.rs,0,5724,"use error_stack::report;
use router_env::{instrument, tracing};
#[cfg(feature = ""accounts_cache"")]
use storage_impl::redis::cache::{self, CacheKind, ACCOUNTS_CACHE};

use super::{MockDb, Store};
use crate::{
    connection,
    core::errors::{self, CustomResult},
    types::storage,
};

#[async_trait::async_trait]
pub trait ApiKeyInterface {
    async fn insert_api_key(
        &self,
        api_...","
    #[instrument(skip_all)]
    async fn insert_api_key(
        &self,
        api_key: storage::ApiKeyNew,
    ) -> CustomResult<storage::ApiKey, errors::StorageError> {
        let conn = connection::pg_connection_write(self).await?;
        api_key
            .insert(&conn)
            .await
            .map_err(|error| report!(errors::StorageError::from(error)))
    }

    #[instrument(ski...","['#[cfg(feature = ""v1"")]\n    #[instrument(skip_all)]\n    async fn insert_api_key(\n        &self,\n        api_key: storage::ApiKeyNew,\n    ) -> CustomResult<storage::ApiKey, errors::StorageError> {\n        let conn = connection::pg_connection_write(self).await?;\n        let key_id = common_utils::id_type::ApiKeyId::generate();\n        let api_key = storage::ApiKey {\n            key_id,\n            merchant_id: api_key.merchant_id,\n            key: api_key.key,\n            created_at: api_key.created_at,\n            last_modified_at: api_key.last_modified_at,\n            expires: api_key.expires,\n            description: api_key.description,\n            disabled: api_key.disabled,\n            hashed_api_key: api_key.hashed_api_key,\n            hashed_key_id: api_key.hashed_key_id,\n            key_id: api_key.key_id,\n            key_type: api_key.key_type,\n            key_version: api_key.key_version,\n            key_status: api_key.key_status,\n            key_arn: api_key.key_arn,\n            key_metadata: api_key.key_metadata,\n            key_issuer: api_key.key_issuer,\n            key_issuer_url: api_key.key_issuer_url,\n            key_arn: api_key.key_arn,\n            key_metadata: api_key.key_metadata,\n            key_issuer: api_key.key_issuer,\n            key_issuer_url: api_key.key_issuer_url,\n            key_arn: api_key.key_arn,\n            key_metadata: api_key.key_metadata,\n            key_issuer: api_key.key_issuer,\n            key_issuer_url: api_key.key_issuer_url,\n            key_arn: api_key.key_arn,\n            key_metadata: api_key.key_metadata,\n            key_issuer: api_key.key_issuer,\n            key_issuer_url: api_key.key_issuer_url,\n            key_arn: api_key.key_arn,\n            key_metadata: api_key.key_metadata,\n            key_issuer: api_key.key_issuer,\n            key_issuer_url: api_key.key_issuer_url,\n            key_arn: api_key.key_arn,\n            key_metadata: api_key.key_metadata,\n            key_issuer: api_key.key_issuer,\n            key_issuer_url: api_key.key_issuer_url,\n            key_arn: api_key.key_arn,\n            key_metadata: api_key.key_metadata,\n            key_issuer: api_key.key_issuer,\n            key_issuer_url: api_key.key_issuer_url,\n            key_arn: api_key.key_arn,\n            key_metadata: api_key.key_metadata,\n            key_issuer: api_key.key_issuer,\n            key_issuer_url: api_key.key_issuer_url,\n            key_arn: api_key.key_arn,\n            key_metadata: api_key.key_metadata,\n            key_issuer: api_key.key_issuer,\n            key_issuer_url: api_key.key_issuer_url,\n            key_arn: api_key.key_arn,\n            key_metadata: api_key.key_metadata,\n            key_issuer: api_key.key_issuer,\n            key_issuer_url: api_key.key_issuer_url,\n            key_arn: api_key.key_arn,\n            key_metadata: api_key.key_metadata,\n            key_issuer: api_key.key_issuer,\n            key_issuer_url: api_key.key_issuer_url,\n            key_arn: api_key.key_arn,\n            key_metadata: api_key.key_metadata,\n            key_issuer: api_key.key_issuer,\n            key_issuer_url: api_key.key_issuer_url,\n            key_arn: api_key.key_arn,\n            key_metadata: api_key.key_metadata,\n            key_issuer: api_key.key_issuer,\n            key_issuer_url: api_key.key_issuer_url,\n            key_arn: api_key.key_arn,\n            key_metadata: api_key.key_metadata,\n            key_issuer: api_key.key_issuer,\n            key_issuer_url: api_key.key_issuer_url,\n            key_arn: api_key.key_arn,\n            key_metadata: api_key.key_metadata,\n            key_issuer: api_key.key_issuer,\n            key_issuer_url: api_key.key_issuer_url,\n            key_arn: api_key.key_arn,\n            key_metadata: api_key.key_metadata,\n            key_issuer: api_key.key_issuer,\n            key_issuer_url: api_key.key_issuer_url,\n            key_arn: api_key.key_arn,\n            key_metadata: api_key.key_metadata,\n            key_issuer: api_key.key_issuer,\n            key_issuer_url: api_key.key_issuer_url,\n            key_arn: api_key.key_arn,\n            key_metadata: api_key.key_metadata,\n            key_issuer: api_key.key_issuer,\n            key_issuer_url: api_key.key_issuer_url,\n            key_arn: api_key.key_arn,\n            key_metadata: api_key.key_metadata,\n            key', '', '']",0.5896607431340872,14.193450223198694,16.748768472906402,0
crates/router/src/db/api_keys.rs,1,856,"use error_stack::report;
use router_env::{instrument, tracing};
#[cfg(feature = ""accounts_cache"")]
use storage_impl::redis::cache::{self, CacheKind, ACCOUNTS_CACHE};

use super::{MockDb, Store};
use crate::{
    connection,
    core::errors::{self, CustomResult},
    types::storage,
};

#[async_trait::async_trait]
pub trait ApiKeyInterface {
    async fn insert_api_key(
        &self,
        api_...","
        let mut locked_api_keys = self.api_keys.lock().await;
        // don't allow duplicate key_ids, a those would be a unique constraint violation in the
        // real db as it is used as the primary key
        if locked_api_keys.iter().any(|k| k.key_id == api_key.key_id) {
            Err(errors::StorageError::MockDbError)?;
        }
        let stored_key = storage::ApiKey {
           ...","[' self.api_keys.push(api_key); Ok(api_key) }\n\n    async fn update_api_key(\n        &self,\n        merchant_id: common_utils::id_type::MerchantId,\n        key_id: common_utils::id_type::ApiKeyId,\n        api_key: storage::ApiKeyUpdate,\n    ) -> CustomResult<storage::ApiKey, errors::StorageError> {\n        let index = self.api_keys.iter().position(|api_key| {\n            api_key.merchant_id == merchant_id && api_key.key_id == key_id\n        });\n        match index {\n            Some(index) => {\n                let mut api_key = self.api_keys[index];\n                api_key.update(api_key, api_key, api_key, api_key, api_key, api_key);\n                Ok(api_key)\n            }\n            None => Err(report!(errors::StorageError::ValueNotFound(format!(\n                ""ApiKey of {} not found"",\n                key_id.get_string_repr()\n            )))),\n        }\n    }\n\n    async fn revoke_api_key(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        key_id: &common_utils::id_type::ApiKeyId,\n    ) -> CustomResult<bool, errors::StorageError> {\n        let index = self.api_keys.iter().position(|api_key| {\n            api_key.merchant_id == merchant_id && api_key.key_id == key_id\n        });\n        match index {\n            Some(index) => {\n                self.api_keys.remove(index);\n                Ok(true)\n            }\n            None => Err(report!(errors::StorageError::ValueNotFound(format!(\n                ""ApiKey of {} not found"",\n                key_id.get_string_repr()\n            )))),\n        }\n    }\n\n    async fn find_api_key_by_merchant_id_key_id_optional(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        key_id: &common_utils::id_type::ApiKeyId,\n    ) -> CustomResult<Option<storage::ApiKey>, errors::StorageError> {\n        let index = self.api_keys.iter().position(|api_key| {\n            api_key.merchant_id == merchant_id && api_key.key_id == key_id\n        });\n        match index {\n            Some(index) => Ok(Some(self.api_keys[index].clone())),\n            None => Ok(None),\n        }\n    }\n\n    async fn find_api_key_by_hash_optional(\n        &self,\n        hashed_api_key: storage::HashedApiKey,\n    ) -> CustomResult<Option<storage::ApiKey>, errors::StorageError> {\n        let index = self.api_keys.iter().position(|api_key| {\n            api_key.hashed_api_key == hashed_api_key\n        });\n        match index {\n            Some(index) => Ok(Some(self.api_keys[index].clone())),\n            None => Ok(None),\n        }\n    }\n\n    async fn list_api_keys_by_merchant_id(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        limit: Option<i64>,\n        offset: Option<i64>,\n    ) -> CustomResult<Vec<storage::ApiKey>, errors::StorageError> {\n        let mut filtered_api_keys = Vec::new();\n        for api_key in self.api_keys.iter() {\n            if api_key.merchant_id == merchant_id {\n                filtered_api_keys.push(api_key.clone());\n            }\n        }\n        let filtered_api_keys = filtered_api_keys.into_iter().skip(offset.unwrap_or(0)).take(limit.unwrap_or(u32::MAX.into()));\n        Ok(filtered_api_keys)\n    }\n}\n#[cfg(feature = ""v1"")]\n#[async_trait::async_trait]\nimpl ApiKeyInterface for super::MockDbV1 {\n    async fn insert_api_key(\n        &self,\n        api_key: storage::ApiKeyNew,\n    ) -> CustomResult<storage::ApiKey, errors::StorageError> {\n        let conn = connection::pg_connection_write(self).await?;\n        api_key\n            .insert(&conn)\n            .await\n            .map_err(|error| report!(errors::StorageError::from(error)))\n    }\n\n    async fn update_api_key(\n        &self,\n        merchant_id: common_utils::id_type::MerchantId,\n        key_id: common_utils::id_type::ApiKeyId,\n        api_key: storage::ApiKeyUpdate,\n    ) -> CustomResult<storage::ApiKey, errors::StorageError> {\n        let conn = connection::pg_connection_write(self).await?;\n        let _merchant_id = merchant_id.clone();\n        let _key_id = key_id.clone();\n        let update_call = || async {\n            storage::ApiKey::update_by_merchant_id_key_id(&conn, merchant_id, key_id, api_key)\n                .await\n                .map_err(|error| report!(errors::StorageError::from(error)))\n        };\n\n        #[cfg(not(feature = ""accounts_cache""))]\n        {\n            update_call().await\n        }\n\n        #[cfg(feature = ""accounts_cache"")]\n        {\n            use error_stack::report;\n\n            // We need to fetch api_key here because the', '', '']",0.6984126984126984,8.5249187011196,18.26625386996904,0
crates/router/src/db/api_keys.rs,2,1304,"use error_stack::report;
use router_env::{instrument, tracing};
#[cfg(feature = ""accounts_cache"")]
use storage_impl::redis::cache::{self, CacheKind, ACCOUNTS_CACHE};

use super::{MockDb, Store};
use crate::{
    connection,
    core::errors::{self, CustomResult},
    types::storage,
};

#[async_trait::async_trait]
pub trait ApiKeyInterface {
    async fn insert_api_key(
        &self,
        api_...","
        let mut locked_api_keys = self.api_keys.lock().await;
        // find a key with the given merchant_id and key_id and update, otherwise return an error
        let key_to_update = locked_api_keys
            .iter_mut()
            .find(|k| k.merchant_id == merchant_id && k.key_id == key_id)
            .ok_or(errors::StorageError::MockDbError)?;

        match api_key {
            stor...","[' // TODO: implement\n        Err(errors::StorageError::NotImplemented(""update_api_key"".to_string()).into())\n    }\n\n    async fn revoke_api_key(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        key_id: &common_utils::id_type::ApiKeyId,\n    ) -> CustomResult<bool, errors::StorageError> {\n        let mut locked_api_keys = self.api_keys.lock().await;\n        let index = locked_api_keys\n            .iter()\n            .position(|k| k.key_id == key_id && k.merchant_id == merchant_id)\n            .ok_or(errors::StorageError::ValueNotFound(format!(\n                ""ApiKey of {} not found"",\n                key_id.get_string_repr()\n            ))))?;\n\n        let key = locked_api_keys.remove(index);\n        Ok(key.is_revoke())\n    }\n\n    async fn find_api_key_by_merchant_id_key_id_optional(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        key_id: &common_utils::id_type::ApiKeyId,\n    ) -> CustomResult<Option<storage::ApiKey>, errors::StorageError> {\n        let mut locked_api_keys = self.api_keys.lock().await;\n        let index = locked_api_keys\n            .iter()\n            .position(|k| k.key_id == key_id && k.merchant_id == merchant_id)\n            .ok_or(errors::StorageError::ValueNotFound(format!(\n                ""ApiKey of {} not found"",\n                key_id.get_string_repr()\n            ))))?;\n\n        Ok(Some(locked_api_keys.remove(index)))\n    }\n\n    async fn find_api_key_by_hash_optional(\n        &self,\n        hashed_api_key: storage::HashedApiKey,\n    ) -> CustomResult<Option<storage::ApiKey>, errors::StorageError> {\n        let mut locked_api_keys = self.api_keys.lock().await;\n        let index = locked_api_keys\n            .iter()\n            .position(|k| k.hashed_api_key == hashed_api_key)\n            .ok_or(errors::StorageError::ValueNotFound(format!(\n                ""ApiKey of {} not found"",\n                hashed_api_key.get_string_repr()\n            ))))?;\n\n        Ok(Some(locked_api_keys.remove(index)))\n    }\n\n    async fn list_api_keys_by_merchant_id(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        limit: Option<i64>,\n        offset: Option<i64>,\n    ) -> CustomResult<Vec<storage::ApiKey>, errors::StorageError> {\n        let mut locked_api_keys = self.api_keys.lock().await;\n        let filtered_api_keys = locked_api_keys\n            .iter()\n            .filter(|k| k.merchant_id == merchant_id)\n            .collect::<Vec<_>>();\n        let start = offset.unwrap_or(0);\n        let end = start + limit.unwrap_or(100);\n        Ok(filtered_api_keys[start..end].to_vec())\n    }\n}\n#[cfg(feature = ""v1"")]\n#[async_trait::async_trait]\nimpl ApiKeyInterface for super::MockDbV1 {\n    #[instrument(skip_all)]\n    async fn insert_api_key(\n        &self,\n        api_key: storage::ApiKeyNew,\n    ) -> CustomResult<storage::ApiKey, errors::StorageError> {\n        let mut locked_api_keys = self.api_keys.lock().await;\n        // don\'t allow duplicate key_ids, a those would be a unique constraint violation in the\n        // real db as it is used as the primary key\n        if locked_api_keys.iter().any(|k| k.key_id == api_key.key_id) {\n            Err(errors::StorageError::MockDbError)?;\n        }\n        let stored_key = storage::ApiKey {\n            key_id: api_key.key_id,\n            merchant_id: api_key.merchant_id,\n            name: api_key.name,\n            description: api_key.description,\n            hashed_api_key: api_key.hashed_api_key,\n            prefix: api_key.prefix,\n            created_at: api_key.created_at,\n            expires_at: api_key.expires_at,\n            last_used: api_key.last_used,\n        };\n        locked_api_keys.push(stored_key.clone());\n\n        Ok(stored_key)\n    }\n\n    #[instrument(skip_all)]\n    async fn update_api_key(\n        &self,\n        merchant_id: common_utils::id_type::MerchantId,\n        key_id: common_utils::id_type::ApiKeyId,\n        api_key: storage::ApiKeyUpdate,\n    ) -> CustomResult<storage::ApiKey, errors::StorageError> { // TODO: implement\n        Err(errors::StorageError::NotImplemented(""update_api_key"".to_string()).into())\n    }\n\n    #[instrument(skip_all)]\n    async fn revoke_api_key(\n        &self,\n        merchant_id: &common_utils::id_type::MerchantId,\n        key_id: &common_utils::id_type::ApiKeyId,\n    ) -> CustomResult<bool, errors::StorageError> {\n        let mut locked_api', '', '']",0.7791164658634538,9.702271099526614,18.31610044313146,0
crates/router/src/core/mandate/utils.rs,0,2626,"use std::marker::PhantomData;

use common_utils::{errors::CustomResult, ext_traits::ValueExt};
use diesel_models::Mandate;
use error_stack::ResultExt;

use crate::{
    core::{errors, payments::helpers},
    types::{self, domain, PaymentAddress},
    SessionState,
};

const IRRELEVANT_ATTEMPT_ID_IN_MANDATE_REVOKE_FLOW: &str =
    ""irrelevant_attempt_id_in_mandate_revoke_flow"";

const IRRELEVANT_CO...","
    let auth_type: types::ConnectorAuthType = merchant_connector_account
        .get_connector_account_details()
        .parse_value(""ConnectorAuthType"")
        .change_context(errors::ApiErrorResponse::InternalServerError)?;
    let router_data = types::RouterData {
        flow: PhantomData,
        merchant_id: merchant_account.get_id().clone(),
        customer_id: Some(mandate.customer_id...","[' // TODO: Remove `types::MandateRevokeRouterData` and use `types::PaymentsAuthorizeRouterData` instead\n    let mut router_data = types::MandateRevokeRouterData::new(\n        state,\n        merchant_account,\n        merchant_connector_account,\n        mandate,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n       ', '', '']",0.44565217391304346,3.573275714985593,12.703583061889251,0
crates/analytics/src/errors.rs,0,855,"use api_models::errors::types::{ApiError, ApiErrorResponse};
use common_utils::errors::{CustomResult, ErrorSwitch};

pub type AnalyticsResult<T> = CustomResult<T, AnalyticsError>;

#[derive(Debug, Clone, serde::Serialize, thiserror::Error)]
pub enum AnalyticsError {
    #[allow(dead_code)]
    #[error(""Not implemented: {0}"")]
    NotImplemented(&'static str),
    #[error(""Unknown Analytics Error"")...","
        match self {
            Self::NotImplemented(feature) => ApiErrorResponse::NotImplemented(ApiError::new(
                ""IR"",
                0,
                format!(""{feature} is not implemented.""),
                None,
            )),
            Self::UnknownError => ApiErrorResponse::InternalServerError(ApiError::new(
                ""HE"",
                0,
                ""Som...","[' match self {\n        Self::NotImplemented(feature) => ApiErrorResponse::NotImplemented(ApiErrorResponse::NotImplemented {\n            message: feature.to_string(),\n        }),\n        Self::UnknownError => ApiErrorResponse::InternalServerError(ApiErrorResponse::InternalServerError {\n            message: ""Something went wrong"".to_string(),\n        }),\n        Self::AccessForbiddenError => ApiErrorResponse::InternalServerError(ApiErrorResponse::InternalServerError {\n            message: ""Something went wrong"".to_string(),\n        }),\n        Self::ForexFetchFailed => ApiErrorResponse::InternalServerError(ApiErrorResponse::InternalServerError {\n            message: ""Something went wrong"".to_string(),\n        }),\n    }\n}\n\nimpl From<AnalyticsError> for ApiErrorResponse {\n    fn from(error: AnalyticsError) -> Self {\n        match error {\n            AnalyticsError::NotImplemented(feature) => Self::NotImplemented(ApiErrorResponse::NotImplemented {\n                message: feature.to_string(),\n            }),\n            AnalyticsError::UnknownError => Self::InternalServerError(ApiErrorResponse::InternalServerError {\n                message: ""Something went wrong"".to_string(),\n            }),\n            AnalyticsError::AccessForbiddenError => Self::InternalServerError(ApiErrorResponse::InternalServerError {\n                message: ""Something went wrong"".to_string(),\n            }),\n            AnalyticsError::ForexFetchFailed => Self::InternalServerError(ApiErrorResponse::InternalServerError {\n                message: ""Something went wrong"".to_string(),\n            }),\n        }\n    }\n}\n\nimpl From<AnalyticsError> for ApiError {\n    fn from(error: AnalyticsError) -> Self {\n        match error {\n            AnalyticsError::NotImplemented(feature) => Self::NotImplemented(ApiError::NotImplemented(ApiError::NotImplemented {\n                message: feature.to_string(),\n            })),\n            AnalyticsError::UnknownError => Self::InternalServerError(ApiError::InternalServerError(ApiError::InternalServerError {\n                message: ""Something went wrong"".to_string(),\n            })),\n            AnalyticsError::AccessForbiddenError => Self::InternalServerError(ApiError::InternalServerError(ApiError::InternalServerError {\n                message: ""Something went wrong"".to_string(),\n            })),\n            AnalyticsError::ForexFetchFailed => Self::InternalServerError(ApiError::InternalServerError(ApiError::InternalServerError {\n                message: ""Something went wrong"".to_string(),\n            })),\n        }\n    }\n}\n#[cfg(feature = ""v1"")]\nimpl AnalyticsError {\n    pub fn to_http_code(&self) -> u16 {\n        match self {\n            Self::NotImplemented(feature) => 501,\n            Self::UnknownError => 500,\n            Self::AccessForbiddenError => 500,\n            Self::ForexFetchFailed => 500,\n        }\n    }\n}\n#[cfg(feature = ""v2"")]\nimpl AnalyticsError {\n    pub fn to_http_code(&self) -> u16 {\n        match self {\n            Self::NotImplemented(feature) => 501,\n            Self::UnknownError => 500,\n            Self::AccessForbiddenError => 500,\n            Self::ForexFetchFailed => 500,\n        }\n    }\n}\n#[cfg(feature = ""v1"")]\nimpl AnalyticsError {\n    pub fn to_http_code(&self) -> u16 {\n        match self {\n            Self::NotImplemented(feature) => 501,\n            Self::UnknownError => 500,\n            Self::AccessForbiddenError => 500,\n            Self::ForexFetchFailed => 500,\n        }\n    }\n}\n#[cfg(feature = ""v2"")]\nimpl AnalyticsError {\n    pub fn to_http_code(&self) -> u16 {\n        match self {\n            Self::NotImplemented(feature) => 501,\n            Self::UnknownError => 500,\n            Self::AccessForbiddenError => 500,\n            Self::ForexFetchFailed => 500,\n        }\n    }\n}\n#[cfg(feature = ""v1"")]\nimpl AnalyticsError {\n    pub fn to_http_code(&self) -> u16 {\n        match self {\n            Self::NotImplemented(feature) => 501,\n            Self::UnknownError => 500,\n            Self::AccessForbiddenError => 500,\n            Self::ForexFetchFailed => 500,\n        }\n    }\n}\n#[cfg(feature = ""v2"")]\nimpl AnalyticsError {\n    pub fn to_http_code(&self) -> u16 {\n        match self {\n            Self::NotImplemented(feature) => 501,\n            Self::UnknownError => 500,\n            Self::AccessForbiddenError => 500,\n            Self::ForexFetchFailed => 500,\n        }\n    }\n}\n#[cfg(feature = ""v1"")]\nimpl AnalyticsError {\n    pub fn to_http_code(&self) -> u16 {\n        match self {\n            Self::NotImplemented(feature) => 501,\n            Self::UnknownError => 500,\n            Self::AccessForbiddenError => 500,\n            Self::ForexFetchFailed => 500,\n        }\n    }\n}\n#[cfg(feature = ""v2"")]\n', '', '']",0.7105263157894737,7.3189317113303325,11.374407582938387,0
crates/external_services/src/email/no_email.rs,0,21,"use common_utils::{errors::CustomResult, pii};
use router_env::logger;

use crate::email::{EmailClient, EmailError, EmailResult, IntermediateString};

/// Client when email support is disabled
#[derive(Debug, Clone, Default, serde::Deserialize)]
pub struct NoEmailClient {}

impl NoEmailClient {
    /// Constructs a new client when email is disabled
    pub async fn create() -> Self {","
        Self {}
    ","[' Self }\n}\n\nimpl EmailClient for NoEmailClient {\n    fn send_email(\n        &self,\n        recipient: pii::Email,\n        subject: String,\n        body: IntermediateString,\n        _header: Option<pii::Email>,\n        _cc: Option<pii::Email>,\n        _bcc: Option<pii::Email>,\n        _email_type: Option<pii::EmailType>,\n        _email_category: Option<pii::EmailCategory>,\n        _email_sub_category: Option<pii::EmailSubCategory>,\n        _email_priority: Option<pii::EmailPriority>,\n        _email_client: Option<pii::EmailClient>,\n        _email_server: Option<pii::EmailServer>,\n        _email_template: Option<pii::EmailTemplate>,\n        _email_template_data: Option<pii::EmailTemplateData>,\n        _email_metadata: Option<pii::EmailMetadata>,\n        _email_event_type: Option<pii::EmailEventType>,\n        _email_event_category: Option<pii::EmailEventCategory>,\n        _email_event_sub_category: Option<pii::EmailEventSubCategory>,\n        _email_event_status: Option<pii::EmailEventStatus>,\n        _email_event_reason: Option<pii::EmailEventReason>,\n        _email_event_error_message: Option<String>,\n        _email_event_error_code: Option<String>,\n        _email_event_error_type: Option<String>,\n        _email_event_error_reason: Option<String>,\n        _email_event_error_message_with_code: Option<String>,\n        _email_event_error_message_with_code_and_reason: Option<String>,\n        _email_event_error_message_with_code_and_reason_and_reason_code: Option<String>,\n        _email_event_error_message_with_code_and_reason_and_reason_code_and_reason_message: Option<String>,\n        _email_event_error_message_with_code_and_reason_and_reason_code_and_reason_message_and_reason_code: Option<String>,\n        _email_event_error_message_with_code_and_reason_and_reason_code_and_reason_message_and_reason_code_and_reason_message: Option<String>,\n        _email_event_error_message_with_code_and_reason_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code: Option<String>,\n        _email_event_error_message_with_code_and_reason_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code_and_reason_message: Option<String>,\n        _email_event_error_message_with_code_and_reason_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code: Option<String>,\n        _email_event_error_message_with_code_and_reason_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code: Option<String>,\n        _email_event_error_message_with_code_and_reason_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code: Option<String>,\n        _email_event_error_message_with_code_and_reason_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code: Option<String>,\n        _email_event_error_message_with_code_and_reason_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code: Option<String>,\n        _email_event_error_message_with_code_and_reason_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code: Option<String>,\n        _email_event_error_message_with_code_and_reason_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code: Option<String>,\n        _email_event_error_message_with_code_and_reason_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code: Option<String>,\n        _email_event_error_message_with_code_and_reason_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code: Option<String>,\n        _email_event_error_message_with_code_and_reason_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code: Option<String>,\n        _email_event_error_message_with_code_and_reason_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code: Option<String>,\n        _email_event_error_message_with_code_and_reason_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code: Option<String>,\n        _email_event_error_message_with_code_and_reason_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code: Option<String>,\n        _email_event_error_message_with_code_and_reason_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code: Option<String>,\n        _email_event_error_message_with_code_and_reason_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code: Option<String>,\n        _email_event_error_message_with_code_and_reason_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code_and_reason_message_and_reason_code: Option<String>,\n', '', '']",0.4,0.028398079821455258,0.26041666666666663,0
crates/external_services/src/email/no_email.rs,1,50,"use common_utils::{errors::CustomResult, pii};
use router_env::logger;

use crate::email::{EmailClient, EmailError, EmailResult, IntermediateString};

/// Client when email support is disabled
#[derive(Debug, Clone, Default, serde::Deserialize)]
pub struct NoEmailClient {}

impl NoEmailClient {
    /// Constructs a new client when email is disabled
    pub async fn create() -> Self {
        Self ...","
        Ok(intermediate_string.into_inner())
    ","[' logger::info!(email_client=?self); Ok(intermediate_string.into_inner()) }\n    async fn send_email(\n        &self,\n        recipient: pii::Email,\n        subject: String,\n        body: Self::RichText,\n    ) -> EmailResult<()> { Ok(()) }\n    async fn send_html_email(\n        &self,\n        recipient: pii::Email,\n        subject: String,\n        body: Self::RichText,\n    ) -> EmailResult<()> { Ok(()) }\n    async fn send_html_email_with_link(\n        &self,\n        recipient: pii::Email,\n        subject: String,\n        body: Self::RichText,\n    ) -> EmailResult<()> { Ok(()) }\n    async fn send_html_email_with_link_and_logo(\n        &self,\n        recipient: pii::Email,\n        subject: String,\n        body: Self::RichText,\n    ) -> EmailResult<()> { Ok(()) }\n    async fn send_html_email_with_logo(\n        &self,\n        recipient: pii::Email,\n        subject: String,\n        body: Self::RichText,\n    ) -> EmailResult<()> { Ok(()) }\n    async fn send_html_email_with_logo_and_link(\n        &self,\n        recipient: pii::Email,\n        subject: String,\n        body: Self::RichText,\n    ) -> EmailResult<()> { Ok(()) }\n    async fn send_html_email_with_logo_and_link_and_button(\n        &self,\n        recipient: pii::Email,\n        subject: String,\n        body: Self::RichText,\n    ) -> EmailResult<()> { Ok(()) }\n    async fn send_html_email_with_logo_and_link_and_button_and_link_text(\n        &self,\n        recipient: pii::Email,\n        subject: String,\n        body: Self::RichText,\n    ) -> EmailResult<()> { Ok(()) }\n    async fn send_html_email_with_logo_and_link_and_button_and_link_text_and_link_color(\n        &self,\n        recipient: pii::Email,\n        subject: String,\n        body: Self::RichText,\n    ) -> EmailResult<()> { Ok(()) }\n    async fn send_html_email_with_logo_and_link_and_button_and_link_text_and_link_color_and_link_hover_color(\n        &self,\n        recipient: pii::Email,\n        subject: String,\n        body: Self::RichText,\n    ) -> EmailResult<()> { Ok(()) }\n    async fn send_html_email_with_logo_and_link_and_button_and_link_text_and_link_color_and_link_hover_color_and_link_border_color(\n        &self,\n        recipient: pii::Email,\n        subject: String,\n        body: Self::RichText,\n    ) -> EmailResult<()> { Ok(()) }\n    async fn send_html_email_with_logo_and_link_and_button_and_link_text_and_link_color_and_link_hover_color_and_link_border_color_and_link_radius(\n        &self,\n        recipient: pii::Email,\n        subject: String,\n        body: Self::RichText,\n    ) -> EmailResult<()> { Ok(()) }\n    async fn send_html_email_with_logo_and_link_and_button_and_link_text_and_link_color_and_link_hover_color_and_link_border_color_and_link_radius_and_link_font_size(\n        &self,\n        recipient: pii::Email,\n        subject: String,\n        body: Self::RichText,\n    ) -> EmailResult<()> { Ok(()) }\n    async fn send_html_email_with_logo_and_link_and_button_and_link_text_and_link_color_and_link_hover_color_and_link_border_color_and_link_radius_and_link_font_size_and_link_font_family(\n        &self,\n        recipient: pii::Email,\n        subject: String,\n        body: Self::RichText,\n    ) -> EmailResult<()> { Ok(()) }\n    async fn send_html_email_with_logo_and_link_and_button_and_link_text_and_link_color_and_link_hover_color_and_link_border_color_and_link_radius_and_link_font_size_and_link_font_family_and_link_font_weight(\n        &self,\n        recipient: pii::Email,\n        subject: String,\n        body: Self::RichText,\n    ) -> EmailResult<()> { Ok(()) }\n    async fn send_html_email_with_logo_and_link_and_button_and_link_text_and_link_color_and_link_hover_color_and_link_border_color_and_link_radius_and_link_font_size_and_link_font_family_and_link_font_weight_and_link_font_style(\n        &self,\n        recipient: pii::Email,\n        subject: String,\n        body: Self::RichText,\n    ) -> EmailResult<()> { Ok(()) }\n    async fn send_html_email_with_logo_and_link_and_button_and_link_text_and_link_color_and_link_hover_color_and_link_border_color_and_link_radius_and_link_font_size_and_link_font_family_and_link_font_weight_and_link_font_style_and_link_font_variant(\n        &self,\n        recipient: pii::Email,\n        subject: String,\n        body: Self::RichText,\n    ) -> EmailResult<()> { Ok(()) }\n    async fn send_html_email_with_logo_and_link_and_button_and_link_text_and_link_color_and_link_hover', '', '']",0.7,0.7707707917001162,1.7271157167530224,0
crates/external_services/src/email/no_email.rs,2,155,"use common_utils::{errors::CustomResult, pii};
use router_env::logger;

use crate::email::{EmailClient, EmailError, EmailResult, IntermediateString};

/// Client when email support is disabled
#[derive(Debug, Clone, Default, serde::Deserialize)]
pub struct NoEmailClient {}

impl NoEmailClient {
    /// Constructs a new client when email is disabled
    pub async fn create() -> Self {
        Self ...","
        logger::info!(""Email not sent as email support is disabled, please enable any of the supported email clients to send emails"");
        Ok(())
    ","[' logger::info!(""Email client not configured, skipping email sending"") }\n}\n#[async_trait::async_trait]\nimpl super::EmailClient for NoEmailClient {\n    async fn send_email(\n        &self,\n        _recipient: pii::Email,\n        _subject: String,\n        _body: Self::RichText,\n        _proxy_url: Option<&String>,\n    ) -> EmailResult<()> { logger::info!(""Email client not configured, skipping email sending"") }\n}\n#[async_trait::async_trait]\nimpl super::EmailClient for NoEmailClient {\n    async fn send_email(\n        &self,\n        _recipient: pii::Email,\n        _subject: String,\n        _body: Self::RichText,\n        _proxy_url: Option<&String>,\n    ) -> EmailResult<()> { logger::info!(""Email client not configured, skipping email sending"") }\n}\n#[async_trait::async_trait]\nimpl super::EmailClient for NoEmailClient {\n    async fn send_email(\n        &self,\n        _recipient: pii::Email,\n        _subject: String,\n        _body: Self::RichText,\n        _proxy_url: Option<&String>,\n    ) -> EmailResult<()> { logger::info!(""Email client not configured, skipping email sending"") }\n}\n#[async_trait::async_trait]\nimpl super::EmailClient for NoEmailClient {\n    async fn send_email(\n        &self,\n        _recipient: pii::Email,\n        _subject: String,\n        _body: Self::RichText,\n        _proxy_url: Option<&String>,\n    ) -> EmailResult<()> { logger::info!(""Email client not configured, skipping email sending"") }\n}\n#[async_trait::async_trait]\nimpl super::EmailClient for NoEmailClient {\n    async fn send_email(\n        &self,\n        _recipient: pii::Email,\n        _subject: String,\n        _body: Self::RichText,\n        _proxy_url: Option<&String>,\n    ) -> EmailResult<()> { logger::info!(""Email client not configured, skipping email sending"") }\n}\n#[async_trait::async_trait]\nimpl super::EmailClient for NoEmailClient {\n    async fn send_email(\n        &self,\n        _recipient: pii::Email,\n        _subject: String,\n        _body: Self::RichText,\n        _proxy_url: Option<&String>,\n    ) -> EmailResult<()> { logger::info!(""Email client not configured, skipping email sending"") }\n}\n#[async_trait::async_trait]\nimpl super::EmailClient for NoEmailClient {\n    async fn send_email(\n        &self,\n        _recipient: pii::Email,\n        _subject: String,\n        _body: Self::RichText,\n        _proxy_url: Option<&String>,\n    ) -> EmailResult<()> { logger::info!(""Email client not configured, skipping email sending"") }\n}\n#[async_trait::async_trait]\nimpl super::EmailClient for NoEmailClient {\n    async fn send_email(\n        &self,\n        _recipient: pii::Email,\n        _subject: String,\n        _body: Self::RichText,\n        _proxy_url: Option<&String>,\n    ) -> EmailResult<()> { logger::info!(""Email client not configured, skipping email sending"") }\n}\n#[async_trait::async_trait]\nimpl super::EmailClient for NoEmailClient {\n    async fn send_email(\n        &self,\n        _recipient: pii::Email,\n        _subject: String,\n        _body: Self::RichText,\n        _proxy_url: Option<&String>,\n    ) -> EmailResult<()> { logger::info!(""Email client not configured, skipping email sending"") }\n}\n#[async_trait::async_trait]\nimpl super::EmailClient for NoEmailClient {\n    async fn send_email(\n        &self,\n        _recipient: pii::Email,\n        _subject: String,\n        _body: Self::RichText,\n        _proxy_url: Option<&String>,\n    ) -> EmailResult<()> { logger::info!(""Email client not configured, skipping email sending"") }\n}\n#[async_trait::async_trait]\nimpl super::EmailClient for NoEmailClient {\n    async fn send_email(\n        &self,\n        _recipient: pii::Email,\n        _subject: String,\n        _body: Self::RichText,\n        _proxy_url: Option<&String>,\n    ) -> EmailResult<()> { logger::info!(""Email client not configured, skipping email sending"") }\n}\n#[async_trait::async_trait]\nimpl super::EmailClient for NoEmailClient {\n    async fn send_email(\n        &self,\n        _recipient: pii::Email,\n        _subject: String,\n        _body: Self::RichText,\n        _proxy_url: Option<&String>,\n    ) -> EmailResult<()> { logger::info!(""Email client not configured, skipping email sending"") }\n}\n#[async_trait::async_trait]\nimpl super::EmailClient for NoEmailClient {\n    async fn send_email(\n        &self,\n        _recipient: pii::Email,\n        _', '', '']",0.3870967741935484,0.7620983099023326,2.9166666666666665,0
crates/common_utils/src/id_type/global_id/payment_methods.rs,0,122,"use error_stack::ResultExt;

use crate::{
    errors::CustomResult,
    id_type::global_id::{CellId, GlobalEntity, GlobalId},
};

/// A global id that can be used to identify a payment method
#[derive(
    Debug,
    Clone,
    Hash,
    PartialEq,
    Eq,
    serde::Serialize,
    serde::Deserialize,
    diesel::expression::AsExpression,
)]
#[diesel(sql_type = diesel::sql_types::Text)]
pub struct...","
        let global_id = GlobalId::generate(cell_id, GlobalEntity::PaymentMethodSession);
        Ok(Self(global_id))
    ","[' Self::new(cell_id) }\n\n    /// Get the cell id from a GlobalPaymentMethodSessionId\n    pub fn get_cell_id(&self) -> &CellId {\n        &self.0.get_cell_id()\n    }\n}\n\nimpl GlobalPaymentMethodId {\n    /// Create a new GlobalPaymentMethodId from cell id information\n    pub fn generate(cell_id: &CellId) -> error_stack::Result<Self, GlobalPaymentMethodIdError> {\n        Self::new(cell_id)\n    }\n\n    /// Get the cell id from a GlobalPaymentMethodId\n    pub fn get_cell_id(&self) -> &CellId {\n        &self.0.get_cell_id()\n    }\n}\n\nimpl GlobalPaymentMethodId {\n    /// Get the global id from a GlobalPaymentMethodId\n    pub fn get_global_id(&self) -> &GlobalId {\n        &self.0\n    }\n}\n\nimpl GlobalPaymentMethodSessionId {\n    /// Get the global id from a GlobalPaymentMethodSessionId\n    pub fn get_global_id(&self) -> &GlobalId {\n        &self.0\n    }\n}\n\nimpl GlobalPaymentMethodId {\n    /// Get the global id from a GlobalPaymentMethodId\n    pub fn get_global_id(&self) -> &GlobalId {\n        &self.0\n    }\n}\n\nimpl GlobalPaymentMethodId {\n    /// Get the global id from a GlobalPaymentMethodId\n    pub fn get_global_id(&self) -> &GlobalId {\n        &self.0\n    }\n}\n\nimpl GlobalPaymentMethodId {\n    /// Get the global id from a GlobalPaymentMethodId\n    pub fn get_global_id(&self) -> &GlobalId {\n        &self.0\n    }\n}\n\nimpl GlobalPaymentMethodId {\n    /// Get the global id from a GlobalPaymentMethodId\n    pub fn get_global_id(&self) -> &GlobalId {\n        &self.0\n    }\n}\n\nimpl GlobalPaymentMethodId {\n    /// Get the global id from a GlobalPaymentMethodId\n    pub fn get_global_id(&self) -> &GlobalId {\n        &self.0\n    }\n}\n\nimpl GlobalPaymentMethodId {\n    /// Get the global id from a GlobalPaymentMethodId\n    pub fn get_global_id(&self) -> &GlobalId {\n        &self.0\n    }\n}\n\nimpl GlobalPaymentMethodId {\n    /// Get the global id from a GlobalPaymentMethodId\n    pub fn get_global_id(&self) -> &GlobalId {\n        &self.0\n    }\n}\n\nimpl GlobalPaymentMethodId {\n    /// Get the global id from a GlobalPaymentMethodId\n    pub fn get_global_id(&self) -> &GlobalId {\n        &self.0\n    }\n}\n\nimpl GlobalPaymentMethodId {\n    /// Get the global id from a GlobalPaymentMethodId\n    pub fn get_global_id(&self) -> &GlobalId {\n        &self.0\n    }\n}\n\nimpl GlobalPaymentMethodId {\n    /// Get the global id from a GlobalPaymentMethodId\n    pub fn get_global_id(&self) -> &GlobalId {\n        &self.0\n    }\n}\n\nimpl GlobalPaymentMethodId {\n    /// Get the global id from a GlobalPaymentMethodId\n    pub fn get_global_id(&self) -> &GlobalId {\n        &self.0\n    }\n}\n\nimpl GlobalPaymentMethodId {\n    /// Get the global id from a GlobalPaymentMethodId\n    pub fn get_global_id(&self) -> &GlobalId {\n        &self.0\n    }\n}\n\nimpl GlobalPaymentMethodId {\n    /// Get the global id from a GlobalPaymentMethodId\n    pub fn get_global_id(&self) -> &GlobalId {\n        &self.0\n    }\n}\n\nimpl GlobalPaymentMethodId {\n    /// Get the global id from a GlobalPaymentMethodId\n    pub fn get_global_id(&self) -> &GlobalId {\n        &self.0\n    }\n}\n\nimpl GlobalPaymentMethodId {\n    /// Get the global id from a GlobalPaymentMethodId\n    pub fn get_global_id(&self) -> &GlobalId {\n        &self.0\n    }\n}\n\nimpl GlobalPaymentMethodId {\n    /// Get the global id from a GlobalPaymentMethodId\n    pub fn get_global_id(&self) -> &GlobalId {\n        &self.0\n    }\n}\n\nimpl GlobalPaymentMethodId {\n    /// Get the global id from a GlobalPaymentMethodId\n    pub fn get_global_id(&self) -> &GlobalId {\n        &self.0\n    }\n}\n\nimpl GlobalPaymentMethodId {\n    /// Get the global id from a GlobalPaymentMethodId\n    pub fn get_global_id(&self) -> &GlobalId {\n        &self.0\n    }\n}\n\nimpl GlobalPaymentMethodId {\n    /// Get the global id from a GlobalPaymentMethodId\n    pub fn get_global_id(&self) -> &GlobalId {\n        &self.0\n    }\n}\n\n', '', '']",0.6296296296296297,0.850766464855036,3.0567685589519655,0
crates/common_utils/src/id_type/global_id/payment_methods.rs,1,38,"use error_stack::ResultExt;

use crate::{
    errors::CustomResult,
    id_type::global_id::{CellId, GlobalEntity, GlobalId},
};

/// A global id that can be used to identify a payment method
#[derive(
    Debug,
    Clone,
    Hash,
    PartialEq,
    Eq,
    serde::Serialize,
    serde::Deserialize,
    diesel::expression::AsExpression,
)]
#[diesel(sql_type = diesel::sql_types::Text)]
pub struct...","
        self.0.get_string_repr()
    ","[' self.0.get_string_repr() }\n\n    /// Get the cell id from the id\n    pub fn get_cell_id(&self) -> error_stack::Result<&CellId, GlobalPaymentMethodSessionIdError> {\n        self.0.get_cell_id()\n    }\n}\n\nimpl GlobalPaymentMethodId {\n    /// Create a new GlobalPaymentMethodId from cell id information\n    pub fn generate(cell_id: &CellId) -> error_stack::Result<Self, GlobalPaymentMethodIdError> {\n        let global_id = GlobalId::generate(cell_id, GlobalEntity::PaymentMethod);\n        Ok(Self(global_id))\n    }\n\n    /// Get the string representation of the id\n    pub fn get_string_repr(&self) -> &str { self.0.get_string_repr() }\n\n    /// Get the cell id from the id\n    pub fn get_cell_id(&self) -> error_stack::Result<&CellId, GlobalPaymentMethodIdError> {\n        self.0.get_cell_id()\n    }\n}\n\nimpl From<GlobalPaymentMethodId> for String {\n    fn from(value: GlobalPaymentMethodId) -> Self {\n        value.0.get_string_repr().to_owned()\n    }\n}\n\nimpl From<GlobalPaymentMethodSessionId> for String {\n    fn from(value: GlobalPaymentMethodSessionId) -> Self {\n        value.0.get_string_repr().to_owned()\n    }\n}\n\nimpl From<GlobalPaymentMethodId> for GlobalId {\n    fn from(value: GlobalPaymentMethodId) -> Self {\n        value.0\n    }\n}\n\nimpl From<GlobalPaymentMethodSessionId> for GlobalId {\n    fn from(value: GlobalPaymentMethodSessionId) -> Self {\n        value.0\n    }\n}\n\nimpl From<GlobalPaymentMethodId> for GlobalEntity {\n    fn from(value: GlobalPaymentMethodId) -> Self {\n        GlobalEntity::PaymentMethod\n    }\n}\n\nimpl From<GlobalPaymentMethodSessionId> for GlobalEntity {\n    fn from(value: GlobalPaymentMethodSessionId) -> Self {\n        GlobalEntity::PaymentMethodSession\n    }\n}\n\nimpl From<GlobalPaymentMethodId> for GlobalPaymentMethodSessionId {\n    fn from(value: GlobalPaymentMethodId) -> Self {\n        Self::generate(&value.0.get_cell_id())\n            .change_context(GlobalPaymentMethodSessionIdError::ConstructionError)\n            .attach_printable(""Failed to construct GlobalPaymentMethodSessionId from GlobalPaymentMethodId"")\n            .map(|session_id| session_id.0)\n            .ok()\n            .unwrap_or_default()\n    }\n}\n\nimpl From<GlobalPaymentMethodSessionId> for GlobalPaymentMethodId {\n    fn from(value: GlobalPaymentMethodSessionId) -> Self {\n        Self::generate(&value.0.get_cell_id())\n            .change_context(GlobalPaymentMethodIdError::ConstructionError)\n            .attach_printable(""Failed to construct GlobalPaymentMethodId from GlobalPaymentMethodSessionId"")\n            .map(|payment_method_id| payment_method_id.0)\n            .ok()\n            .unwrap_or_default()\n    }\n}\n\nimpl From<GlobalPaymentMethodId> for GlobalPaymentMethodSessionId {\n    fn from(value: GlobalPaymentMethodId) -> Self {\n        Self::generate(&value.0.get_cell_id())\n            .change_context(GlobalPaymentMethodSessionIdError::ConstructionError)\n            .attach_printable(""Failed to construct GlobalPaymentMethodSessionId from GlobalPaymentMethodId"")\n            .map(|session_id| session_id.0)\n            .ok()\n            .unwrap_or_default()\n    }\n}\n\nimpl From<GlobalPaymentMethodSessionId> for GlobalPaymentMethodId {\n    fn from(value: GlobalPaymentMethodSessionId) -> Self {\n        Self::generate(&value.0.get_cell_id())\n            .change_context(GlobalPaymentMethodIdError::ConstructionError)\n            .attach_printable(""Failed to construct GlobalPaymentMethodId from GlobalPaymentMethodSessionId"")\n            .map(|payment_method_id| payment_method_id.0)\n            .ok()\n            .unwrap_or_default()\n    }\n}\n\nimpl From<GlobalPaymentMethodId> for GlobalPaymentMethodSessionId {\n    fn from(value: GlobalPaymentMethodId) -> Self {\n        Self::generate(&value.0.get_cell_id())\n            .change_context(GlobalPaymentMethodSessionIdError::ConstructionError)\n            .attach_printable(""Failed to construct GlobalPaymentMethodSessionId from GlobalPaymentMethodId"")\n            .map(|session_id| session_id.0)\n            .ok()\n            .unwrap_or_default()\n    }\n}\n\nimpl From<GlobalPaymentMethodSessionId> for GlobalPaymentMethodId {\n    fn from(value: GlobalPaymentMethodSessionId) -> Self {\n        Self::generate(&value.0.get_cell_id())\n            .change_context(GlobalPaymentMethodIdError::ConstructionError)\n            .attach_printable(""Failed to construct GlobalPaymentMethodId from GlobalPaymentMethodSessionId"")\n            .map(|payment_method_id| payment_method_id.0)\n            .ok()\n            .unwrap_or_default()\n    }\n}\n\nimpl From', '', '']",0.9,1.0062602745763214,2.3094688221709005,0
crates/common_utils/src/id_type/global_id/payment_methods.rs,2,74,"use error_stack::ResultExt;

use crate::{
    errors::CustomResult,
    id_type::global_id::{CellId, GlobalEntity, GlobalId},
};

/// A global id that can be used to identify a payment method
#[derive(
    Debug,
    Clone,
    Hash,
    PartialEq,
    Eq,
    serde::Serialize,
    serde::Deserialize,
    diesel::expression::AsExpression,
)]
#[diesel(sql_type = diesel::sql_types::Text)]
pub struct...","
        format!(""payment_method_session:{}"", self.get_string_repr())
    ","[' format!(""payment_method_session_{}"", self.get_string_repr()) }\n}\n\nimpl GlobalPaymentMethodId {\n    /// Create a new GlobalPaymentMethodId from cell id information\n    pub fn generate(cell_id: &CellId) -> error_stack::Result<Self, GlobalPaymentMethodIdError> {\n        let global_id = GlobalId::generate(cell_id, GlobalEntity::PaymentMethod);\n        Ok(Self(global_id))\n    }\n\n    /// Get the string representation of the id\n    pub fn get_string_repr(&self) -> &str {\n        self.0.get_string_repr()\n    }\n\n    /// Construct a redis key from the id to be stored in redis\n    pub fn get_redis_key(&self) -> String { format!(""payment_method_{}"", self.get_string_repr()) }\n}\n\nimpl From<GlobalPaymentMethodId> for String {\n    fn from(value: GlobalPaymentMethodId) -> Self {\n        value.get_string_repr().to_string()\n    }\n}\n\nimpl From<GlobalPaymentMethodSessionId> for String {\n    fn from(value: GlobalPaymentMethodSessionId) -> Self {\n        value.get_string_repr().to_string()\n    }\n}\n\nimpl From<GlobalPaymentMethodId> for GlobalId {\n    fn from(value: GlobalPaymentMethodId) -> Self {\n        value.0\n    }\n}\n\nimpl From<GlobalPaymentMethodSessionId> for GlobalId {\n    fn from(value: GlobalPaymentMethodSessionId) -> Self {\n        value.0\n    }\n}\n\nimpl From<GlobalPaymentMethodId> for String {\n    fn from(value: GlobalPaymentMethodId) -> Self {\n        value.get_string_repr().to_string()\n    }\n}\n\nimpl From<GlobalPaymentMethodSessionId> for String {\n    fn from(value: GlobalPaymentMethodSessionId) -> Self {\n        value.get_string_repr().to_string()\n    }\n}\n#[cfg(feature = ""v1"")]\nimpl From<GlobalPaymentMethodId> for String {\n    fn from(value: GlobalPaymentMethodId) -> Self {\n        format!(""payment_method_{}"", value.get_string_repr())\n    }\n}\n\n#[cfg(feature = ""v1"")]\nimpl From<GlobalPaymentMethodSessionId> for String {\n    fn from(value: GlobalPaymentMethodSessionId) -> Self {\n        format!(""payment_method_session_{}"", value.get_string_repr())\n    }\n}\n#[cfg(feature = ""v2"")]\nimpl From<GlobalPaymentMethodId> for String {\n    fn from(value: GlobalPaymentMethodId) -> Self {\n        format!(""payment_method_{}"", value.get_string_repr())\n    }\n}\n\n#[cfg(feature = ""v2"")]\nimpl From<GlobalPaymentMethodSessionId> for String {\n    fn from(value: GlobalPaymentMethodSessionId) -> Self {\n        format!(""payment_method_session_{}"", value.get_string_repr())\n    }\n}\n\nimpl From<GlobalPaymentMethodId> for String {\n    fn from(value: GlobalPaymentMethodId) -> Self {\n        format!(""payment_method_{}"", value.get_string_repr())\n    }\n}\n\n#[cfg(feature = ""v1"")]\nimpl From<GlobalPaymentMethodSessionId> for String {\n    fn from(value: GlobalPaymentMethodSessionId) -> Self {\n        format!(""payment_method_session_{}"", value.get_string_repr())\n    }\n}\n\n#[cfg(feature = ""v2"")]\nimpl From<GlobalPaymentMethodSessionId> for String {\n    fn from(value: GlobalPaymentMethodSessionId) -> Self {\n        format!(""payment_method_session_{}"", value.get_string_repr())\n    }\n}\n\nimpl From<GlobalPaymentMethodId> for String {\n    fn from(value: GlobalPaymentMethodId) -> Self {\n        format!(""payment_method_{}"", value.get_string_repr())\n    }\n}\n\n#[cfg(feature = ""v1"")]\nimpl From<GlobalPaymentMethodSessionId> for String {\n    fn from(value: GlobalPaymentMethodSessionId) -> Self {\n        format!(""payment_method_session_{}"", value.get_string_repr())\n    }\n}\n\n#[cfg(feature = ""v2"")]\nimpl From<GlobalPaymentMethodSessionId> for String {\n    fn from(value: GlobalPaymentMethodSessionId) -> Self {\n        format!(""payment_method_session_{}"", value.get_string_repr())\n    }\n}\n\nimpl From<GlobalPaymentMethodId> for String {\n    fn from(value: GlobalPaymentMethodId) -> Self {\n        format!(""payment_method_{}"", value.get_string_repr())\n    }\n}\n\n#[cfg(feature = ""v1"")]\nimpl From<GlobalPaymentMethodSessionId> for String {\n    fn from(value: GlobalPaymentMethodSessionId) -> Self {\n        format!(""payment_method_session_{}"", value.get_string_repr())\n    }\n}\n\n#[cfg(feature = ""v2"")]\nimpl From<GlobalPaymentMethodSessionId> for String {\n    fn from(value: GlobalPaymentMethodSessionId) -> Self {\n        format!(""payment_method_session_{}"", value.get_string_repr())\n    }\n}\n\nimpl From<GlobalPaymentMethodId> for String {\n    fn from(value: GlobalPaymentMethodId) -> Self {\n        format!(""payment_method_{}"", value.get_string_repr())\n    }\n}\n\n', '', '']",0.9333333333333333,1.81697829697786,3.4858387799564268,0
crates/router/src/core/payment_methods/cards.rs,0,2974,"use std::{
    collections::{HashMap, HashSet},
    fmt::Debug,
    str::FromStr,
};

#[cfg(all(
    any(feature = ""v1"", feature = ""v2""),
    not(feature = ""payment_methods_v2"")
))]
use api_models::admin::PaymentMethodsEnabled;
use api_models::{
    enums as api_enums,
    payment_methods::{
        BankAccountTokenData, Card, CardDetailUpdate, CardDetailsPaymentMethod, CardNetworkTypes,
        C...","
    let db = &*state.store;
    let customer = db
        .find_customer_by_customer_id_merchant_id(
            &state.into(),
            customer_id,
            merchant_id,
            key_store,
            storage_scheme,
        )
        .await
        .to_not_found_response(errors::ApiErrorResponse::CustomerNotFound)?;

    let client_secret = generate_id(
        consts::ID_LENGTH,
   ...","[' // TODO: remove customer_id and payment_method_id from the function signature\n    let payment_method = domain::PaymentMethod {\n        payment_method_id: payment_method_id.to_owned(),\n        payment_method_type: req.payment_method_type,\n        payment_method_subtype: req.payment_method_subtype,\n        payment_method_data,\n        payment_method_billing_address,\n        payment_method_metadata: pm_metadata,\n        payment_method_acceptance: customer_acceptance,\n        payment_method_status: status.unwrap_or_default(),\n        payment_method_created_at: common_utils::date_time::now(),\n        payment_method_updated_at: common_utils::date_time::now(),\n        payment_method_customer_id: customer_id.to_owned(),\n        payment_method_merchant_id: merchant_id.to_owned(),\n        payment_method_locker_id: locker_id,\n        payment_method_connector: None,\n        payment_method_type_data: None,\n        payment_method_issuer: None,\n        payment_method_issuing_country: None,\n        payment_method_issuing_network: None,\n        payment_method_issuing_authority: None,\n        payment_method_issuing_country_code: None,\n        payment_method_issuing_country_name: None,\n        payment_method_issuing_network_name: None,\n        payment_method_issuing_authority_name: None,\n        payment_method_issuing_country_code_with_name: None,\n        payment_method_issuing_country_name_with_code: None,\n        payment_method_issuing_network_name_with_code: None,\n        payment_method_issuing_authority_name_with_code: None,\n        payment_method_issuing_country_code_with_name_with_code: None,\n        payment_method_issuing_country_name_with_code_with_code: None,\n        payment_method_issuing_network_name_with_code_with_code: None,\n        payment_method_issuing_authority_name_with_code_with_code: None,\n        payment_method_issuing_country_code_with_name_with_code_with_code: None,\n        payment_method_issuing_country_name_with_code_with_code_with_code: None,\n        payment_method_issuing_network_name_with_code_with_code_with_code: None,\n        payment_method_issuing_authority_name_with_code_with_code_with_code: None,\n        payment_method_issuing_country_code_with_name_with_code_with_code_with_code: None,\n        payment_method_issuing_country_name_with_code_with_code_with_code_with_code: None,\n        payment_method_issuing_network_name_with_code_with_code_with_code_with_code: None,\n        payment_method_issuing_authority_name_with_code_with_code_with_code_with_code: None,\n        payment_method_issuing_country_code_with_name_with_code_with_code_with_code_with_code: None,\n        payment_method_issuing_country_name_with_code_with_code_with_code_with_code_with_code: None,\n        payment_method_issuing_network_name_with_code_with_code_with_code_with_code_with_code: None,\n        payment_method_issuing_authority_name_with_code_with_code_with_code_with_code_with_code: None,\n        payment_method_issuing_country_code_with_name_with_code_with_code_with_code_with_code_with_code: None,\n        payment_method_issuing_country_name_with_code_with_code_with_code_with_code_with_code_with_code: None,\n        payment_method_issuing_network_name_with_code_with_code_with_code_with_code_with_code_with_code: None,\n        payment_method_issuing_authority_name_with_code_with_code_with_code_with_code_with_code_with_code: None,\n        payment_method_issuing_country_code_with_name_with_code_with_code_with_code_with_code_with_code_with_code: None,\n        payment_method_issuing_country_name_with_code_with_code_with_code_with_code_with_code_with_code_with_code: None,\n        payment_method_issuing_network_name_with_code_with_code_with_code_with_code_with_code_with_code_with_code: None,\n        payment_method_issuing_authority_name_with_code_with_code_with_code_with_code_with_code_with_code_with_code: None,\n        payment_method_issuing_country_code_with_name_with_code_with_code_with_code_with_code_with_code_with_code_with_code: None,\n        payment_method_issuing_country_name_with_code_with_code_with_code_with_code_with_code_with_code_with_code_with_code: None,\n        payment_method_issuing_network_name_with_code_with_code_with_code_with_code_with_code_with_code_with_code_with_code: None,\n        payment_method_issuing_authority_name_with_code_with_code_with_code_with_code_with_code_with_code_with_code_with_code: None,\n        payment_method_issuing_country_code_with_name_with_code_with_code_with_code_with_code_with_code_with_code_with_code_with_code: None,\n        payment_method_issuing_country_name_with_code_with_code_with_code_with_code_with_code_with_code_with_code_with_code_with_code: None,\n        payment_method_issuing_network_name_with_code_with_code_with_code_with_code_with_code_with_code_with_code_with_code_with_code: None,\n        payment_method_issuing_authority_name_with_code_with_code_with_code_with_code_with_code_with_code_with_code_with_code_with_code: None,\n        payment_method_', '', '']",0.5110294117647058,13.54879387684179,17.315175097276263,0
crates/router/src/core/payment_methods/cards.rs,1,858,"use std::{
    collections::{HashMap, HashSet},
    fmt::Debug,
    str::FromStr,
};

#[cfg(all(
    any(feature = ""v1"", feature = ""v2""),
    not(feature = ""payment_methods_v2"")
))]
use api_models::admin::PaymentMethodsEnabled;
use api_models::{
    enums as api_enums,
    payment_methods::{
        BankAccountTokenData, Card, CardDetailUpdate, CardDetailsPaymentMethod, CardNetworkTypes,
        C...","
    let pm_id = generate_id(consts::ID_LENGTH, ""pm"");
    let payment_method_response = api::PaymentMethodResponse {
        merchant_id: merchant_id.to_owned(),
        customer_id: Some(customer_id.to_owned()),
        payment_method_id: pm_id,
        payment_method: req.payment_method,
        payment_method_type: req.payment_method_type,
        #[cfg(feature = ""payouts"")]
        bank_trans...","[' // TODO: Remove the `Option` once we are sure that the duplication check is always performed\n    let payment_method_id = generate_id(consts::ID_LENGTH, ""pm"");\n    let response = PaymentMethodResponse::from(\n        PaymentMethodCreateExt::try_from(req)\n            .change_context(errors::ApiErrorResponse::InvalidDataFormat {\n                field_name: ""payment_method_create"",\n            })\n            .attach_printable(""Failed to convert PaymentMethodCreate to PaymentMethodCreateExt"")?,\n    )\n    .into_inner();\n    let duplication_check = None;\n    (response, duplication_check)\n}\n\n#[cfg(all(feature = ""v2"", feature = ""payment_methods_v2""))]\n#[instrument(skip_all)]\npub async fn create_payment_method(\n    state: &routes::SessionState,\n    req: &api::PaymentMethodCreate,\n    customer_id: &id_type::CustomerId,\n    merchant_id: &id_type::MerchantId,\n    key_store: &domain::MerchantKeyStore,\n    storage_scheme: MerchantStorageScheme,\n    payment_method_data: crypto::OptionalEncryptableValue,\n    payment_method_billing_address: crypto::OptionalEncryptableValue,\n    payment_method_metadata: Option<serde_json::Value>,\n    payment_method_acceptance: Option<serde_json::Value>,\n    payment_method_issuer: Option<String>,\n    payment_method_issuer_code: Option<String>,\n    payment_method_issuer_country: Option<String>,\n    payment_method_issuer_name: Option<String>,\n    payment_method_issuer_country_code: Option<String>,\n    payment_method_issuer_code: Option<String>,\n    payment_method_issuer_name: Option<String>,\n    payment_method_issuer_country_code: Option<String>,\n    payment_method_issuer_code: Option<String>,\n    payment_method_issuer_name: Option<String>,\n    payment_method_issuer_country_code: Option<String>,\n    payment_method_issuer_code: Option<String>,\n    payment_method_issuer_name: Option<String>,\n    payment_method_issuer_country_code: Option<String>,\n    payment_method_issuer_code: Option<String>,\n    payment_method_issuer_name: Option<String>,\n    payment_method_issuer_country_code: Option<String>,\n    payment_method_issuer_code: Option<String>,\n    payment_method_issuer_name: Option<String>,\n    payment_method_issuer_country_code: Option<String>,\n    payment_method_issuer_code: Option<String>,\n    payment_method_issuer_name: Option<String>,\n    payment_method_issuer_country_code: Option<String>,\n    payment_method_issuer_code: Option<String>,\n    payment_method_issuer_name: Option<String>,\n    payment_method_issuer_country_code: Option<String>,\n    payment_method_issuer_code: Option<String>,\n    payment_method_issuer_name: Option<String>,\n    payment_method_issuer_country_code: Option<String>,\n    payment_method_issuer_code: Option<String>,\n    payment_method_issuer_name: Option<String>,\n    payment_method_issuer_country_code: Option<String>,\n    payment_method_issuer_code: Option<String>,\n    payment_method_issuer_name: Option<String>,\n    payment_method_issuer_country_code: Option<String>,\n    payment_method_issuer_code: Option<String>,\n    payment_method_issuer_name: Option<String>,\n    payment_method_issuer_country_code: Option<String>,\n    payment_method_issuer_code: Option<String>,\n    payment_method_issuer_name: Option<String>,\n    payment_method_issuer_country_code: Option<String>,\n    payment_method_issuer_code: Option<String>,\n    payment_method_issuer_name: Option<String>,\n    payment_method_issuer_country_code: Option<String>,\n    payment_method_issuer_code: Option<String>,\n    payment_method_issuer_name: Option<String>,\n    payment_method_issuer_country_code: Option<String>,\n    payment_method_issuer_code: Option<String>,\n    payment_method_issuer_name: Option<String>,\n    payment_method_issuer_country_code: Option<String>,\n    payment_method_issuer_code: Option<String>,\n    payment_method_issuer_name: Option<String>,\n    payment_method_issuer_country_code: Option<String>,\n    payment_method_issuer_code: Option<String>,\n    payment_method_issuer_name: Option<String>,\n    payment_method_issuer_country_code: Option<String>,\n    payment_method_issuer_code: Option<String>,\n    payment_method_issuer_name: Option<String>,\n    payment_method_issuer_country_code: Option<String>,\n    payment_method_issuer_code: Option<String>,\n    payment_method_issuer_name: Option<String>,\n    payment_method_issuer_country_code: Option<String>,\n    payment_method_issuer_code: Option<String>,\n    payment_method_issuer_name: Option<String>,\n    payment_method_issuer_country_code: Option<String>,\n    payment_method_issuer_code: Option<String>,\n    payment_method_issuer_name: Option<String>,\n    payment_method_issuer_country_code: Option<String>,\n    payment_method_issuer_code: Option<String>,\n    payment_method_issuer_name: Option<String>,\n    payment_method_issuer_country_code: Option<String>,\n    payment_method_issuer_code: Option<String>,\n    payment_method_issuer_name: Option<String>,\n    payment_method_issuer_country_code: Option<String>,\n', '', '']",0.6137566137566137,5.235086438365569,8.985507246376812,0
crates/router/src/core/payment_methods/cards.rs,2,13,"use std::{
    collections::{HashMap, HashSet},
    fmt::Debug,
    str::FromStr,
};

#[cfg(all(
    any(feature = ""v1"", feature = ""v2""),
    not(feature = ""payment_methods_v2"")
))]
use api_models::admin::PaymentMethodsEnabled;
use api_models::{
    enums as api_enums,
    payment_methods::{
        BankAccountTokenData, Card, CardDetailUpdate, CardDetailsPaymentMethod, CardNetworkTypes,
        C...","
    todo!()
","[' //TODO: implement\n    todo!()\n}\n\n#[cfg(all(feature = ""v1"", feature = ""payment_methods_v2""))]\n#[instrument(skip_all)]\n#[allow(clippy::too_many_arguments)]\npub async fn update_payment_method(\n    state: &routes::SessionState,\n    req: &api::PaymentMethodUpdate,\n    payment_method_id: &str,\n    merchant_id: &id_type::MerchantId,\n    customer_id: &id_type::CustomerId,\n    key_store: &domain::MerchantKeyStore,\n    storage_scheme: MerchantStorageScheme,\n    payment_method_data: crypto::OptionalEncryptableValue,\n    payment_method_billing_address: crypto::OptionalEncryptableValue,\n    card_scheme: Option<String>,\n    network_token_requestor_reference_id: Option<String>,\n    network_token_locker_id: Option<String>,\n    network_token_payment_method_data: crypto::OptionalEncryptableValue,\n) -> errors::CustomResult<domain::PaymentMethod, errors::ApiErrorResponse> {\n    let db = &*state.store;\n    let customer = db\n        .find_customer_by_customer_id_merchant_id(\n            &state.into(),\n            customer_id,\n            merchant_id,\n            key_store,\n            storage_scheme,\n        )\n        .await\n        .to_not_found_response(errors::ApiErrorResponse::CustomerNotFound)?;\n\n    let payment_method = db\n        .find_payment_method_by_payment_method_id_merchant_id(\n            &state.into(),\n            payment_method_id,\n            merchant_id,\n            key_store,\n            storage_scheme,\n        )\n        .await\n        .to_not_found_response(errors::ApiErrorResponse::PaymentMethodNotFound)?;\n\n    let current_time = common_utils::date_time::now();\n\n    let payment_method_update = payment_methods::PaymentMethodUpdate::from(req);\n\n    let payment_method = payment_method.update(payment_method_update);\n\n    let payment_method_data = payment_method_data.map(Secret::new);\n    let payment_method_billing_address = payment_method_billing_address.map(Secret::new);\n\n    let payment_method = payment_methods::PaymentMethodUpdateInternal::from(payment_method);\n\n    let payment_method = payment_methods::PaymentMethodUpdateInternal::apply_changeset(\n        payment_method,\n        payment_method_data,\n        payment_method_billing_address,\n        card_scheme,\n        network_token_requestor_reference_id,\n        network_token_locker_id,\n        network_token_payment_method_data,\n    );\n\n    let payment_method = db\n        .update_payment_method(\n            &state.into(),\n            key_store,\n            payment_method,\n            storage_scheme,\n        )\n        .await\n        .change_context(errors::ApiErrorResponse::InternalServerError)\n        .attach_printable(""Failed to update payment method in db"")?;\n\n    if payment_method.is_stored.unwrap_or(false) {\n        let _ = set_default_payment_method(\n            state,\n            merchant_id,\n            key_store.clone(),\n            customer_id,\n            payment_method.payment_method_id.clone(),\n            storage_scheme,\n        )\n        .await\n        .map_err(|error| logger::error!(?error, ""Failed to set the payment method as default""));\n    }\n    Ok(payment_method)\n}\n\n#[cfg(all(feature = ""v2"", feature = ""payment_methods_v2""))]\n#[instrument(skip_all)]\n#[allow(clippy::too_many_arguments)]\npub async fn update_payment_method(\n    state: &routes::SessionState,\n    req: &api::PaymentMethodUpdate,\n    payment_method_id: &str,\n    merchant_id: &id_type::MerchantId,\n    customer_id: &id_type::CustomerId,\n    key_store: &domain::MerchantKeyStore,\n    storage_scheme: MerchantStorageScheme,\n    payment_method_data: crypto::OptionalEncryptableValue,\n    payment_method_billing_address: crypto::OptionalEncryptableValue,\n    card_scheme: Option<String>,\n    network_token_requestor_reference_id: Option<String>,\n    network_token_locker_id: Option<String>,\n    network_token_payment_method_data: crypto::OptionalEncryptableValue,\n) -> errors::CustomResult<domain::PaymentMethod, errors::ApiErrorResponse> {\n    let db = &*state.store;\n    let customer = db\n        .find_customer_by_customer_id_merchant_id(\n            &state.into(),\n            customer_id,\n            merchant_id,\n            key_store,\n            storage_scheme,\n        )\n        .await\n        .to_not_found_response(errors::ApiErrorResponse::CustomerNotFound)?;\n\n    let payment_method = db\n        .find_payment_method_by_payment_method_id_merchant_id(\n            &state.into(),\n            payment_method_id,\n            merchant_id,\n            key_store,\n            storage_scheme,\n        )\n        .await\n        .to_not_found_response(errors::ApiErrorResponse::PaymentMethodNotFound)?;\n\n    let current_time = common_utils::date_time::now();\n\n    let payment_method_update = payment_methods::PaymentMethodUpdate::from(req);\n\n    let payment_method = payment_method.update(payment_method_update);\n\n    let payment_method_data = payment_method_data.map(Secret::new);\n    let payment_method_billing_address = payment_method_billing_address.map(Secret::new);\n\n', '', '']",1.0,0.1852963423130948,0.37950664136622386,0
crates/router/tests/connectors/payme.rs,0,234,"use std::str::FromStr;

use common_utils::{pii::Email, types::MinorUnit};
use diesel_models::types::OrderDetailsWithAmount;
use hyperswitch_domain_models::address::{Address, AddressDetails};
use masking::Secret;
use router::types::{self, domain, storage::enums, PaymentAddress};

use crate::{
    connector_auth,
    utils::{self, ConnectorActions, PaymentAuthorizeType},
};

#[derive(Clone, Copy)]
s...","
        use router::connector::Payme;
        utils::construct_connector_data_old(
            Box::new(Payme::new()),
            types::Connector::Payme,
            types::api::GetToken::Connector,
            None,
        )
    ","[' utils::construct_connector_data_old(""payme"", None) }\n    fn get_auth_token(&self) -> types::ConnectorAuthType {\n        utils::to_connector_auth_type(\n            connector_auth::ConnectorAuthentication::new()\n                .payme\n                .expect(""Missing connector authentication configuration"")\n                .into(),\n        )\n    }\n    fn get_name(&self) -> String {\n        ""payme"".to_string()\n    }\n}\n\nstatic CONNECTOR: PaymeTest = PaymeTest {};\n\nfn get_default_payment_info() -> Option<utils::PaymentInfo> {\n    None\n}\n\nfn get_default_billing_info() -> Option<utils::PaymentInfo> {\n    None\n}\n\nfn get_default_shipping_info() -> Option<utils::PaymentInfo> {\n    None\n}\n\nfn get_default_payment_method_info() -> Option<utils::PaymentInfo> {\n    None\n}\n\nfn get_default_capture_method() -> Option<enums::CaptureMethod> {\n    None\n}\n\nfn get_default_customer_acceptance() -> Option<utils::CustomerAcceptance> {\n    None\n}\n\nfn get_default_three_ds() -> Option<utils::ThreeDS> {\n    None\n}\n\nfn get_default_mandate_data() -> Option<utils::MandateData> {\n    None\n}\n\nfn get_default_payment_experience() -> Option<utils::PaymentExperience> {\n    None\n}\n\nfn get_default_payment_method() -> Option<enums::PaymentMethod> {\n    None\n}\n\nfn get_default_payment_method_type() -> Option<enums::PaymentMethodType> {\n    None\n}\n\nfn get_default_setup_future_usage() -> Option<enums::FutureUsage> {\n    None\n}\n\nfn get_default_customer_acceptance_for_three_ds() -> Option<utils::CustomerAcceptance> {\n    None\n}\n\nfn get_default_payment_method_data() -> Option<utils::PaymentMethodData> {\n    None\n}\n\nfn get_default_billing() -> Option<utils::Billing> {\n    None\n}\n\nfn get_default_shipping() -> Option<utils::Shipping> {\n    None\n}\n\nfn get_default_surcharge_details() -> Option<utils::SurchargeDetails> {\n    None\n}\n\nfn get_default_tax_details() -> Option<utils::TaxDetails> {\n    None\n}\n\nfn get_default_fraud_check() -> Option<utils::FraudCheck> {\n    None\n}\n\nfn get_default_three_ds_challenge() -> Option<utils::ThreeDSChallenge> {\n    None\n}\n\nfn get_default_three_ds_not_challenged() -> Option<utils::ThreeDSNotChallenged> {\n    None\n}\n\nfn get_default_payment_method_billing() -> Option<utils::PaymentMethodBilling> {\n    None\n}\n\nfn get_default_payment_method_shipping() -> Option<utils::PaymentMethodShipping> {\n    None\n}\n\nfn get_default_payment_method_surcharge_details() -> Option<utils::SurchargeDetails> {\n    None\n}\n\nfn get_default_payment_method_tax_details() -> Option<utils::TaxDetails> {\n    None\n}\n\nfn get_default_payment_method_fraud_check() -> Option<utils::FraudCheck> {\n    None\n}\n\nfn get_default_payment_method_three_ds_challenge() -> Option<utils::ThreeDSChallenge> {\n    None\n}\n\nfn get_default_payment_method_three_DS_not_challenged() -> Option<utils::ThreeDSNotChallenged> {\n    None\n}\n\nfn get_default_payment_method_three_ds_customer_acceptance() -> Option<utils::CustomerAcceptance> {\n    None\n}\n\nfn get_default_payment_method_three_ds_payment_experience() -> Option<utils::PaymentExperience> {\n    None\n}\n\nfn get_default_payment_method_three_DS_payment_method_data() -> Option<utils::PaymentMethodData> {\n    None\n}\n\nfn get_default_payment_method_three_DS_payment_method_billing() -> Option<utils::PaymentMethodBilling> {\n    None\n}\n\nfn get_default_payment_method_three_DS_payment_method_shipping() -> Option<utils::PaymentMethodShipping> {\n    None\n}\n\nfn get_default_payment_method_three_DS_payment_method_surcharge_details() -> Option<utils::SurchargeDetails> {\n    None\n}\n\nfn get_default_payment_method_three_DS_payment_method_tax_details() -> Option<utils::TaxDetails> {\n    None\n}\n\nfn get_default_payment_method_three_DS_payment_method_fraud_check() -> Option<utils::FraudCheck> {\n    None\n}\n\nfn get_default_payment_method_three_DS_payment_method_three_DS_challenge() -> Option<utils::ThreeDSChallenge> {\n    None\n}\n\nfn get_default_payment_method_three_DS_payment_method_three_DS_not_challenged() -> Option<utils::ThreeDSNotChallenged> {\n    None\n}\n\nfn get_default_payment_method_three_DS_payment_method_three_DS_customer_acceptance() -> Option<utils::CustomerAcceptance> {\n    None\n}\n\nfn get_default_payment_method_three_DS_payment_method_three_DS_payment_experience() -> Option<utils::PaymentExperience> {\n    None\n}\n\nfn get_default_payment_method_three_DS_payment_method_three_DS_payment_method_data() -> Option<utils', '', '']",0.6730769230769231,1.595215835221645,4.119850187265916,0
crates/router/tests/connectors/payme.rs,1,235,"use std::str::FromStr;

use common_utils::{pii::Email, types::MinorUnit};
use diesel_models::types::OrderDetailsWithAmount;
use hyperswitch_domain_models::address::{Address, AddressDetails};
use masking::Secret;
use router::types::{self, domain, storage::enums, PaymentAddress};

use crate::{
    connector_auth,
    utils::{self, ConnectorActions, PaymentAuthorizeType},
};

#[derive(Clone, Copy)]
s...","
        utils::to_connector_auth_type(
            connector_auth::ConnectorAuthentication::new()
                .payme
                .expect(""Missing connector authentication configuration"")
                .into(),
        )
    ","[' connector_auth::ConnectorAuthentication::new().payme }\n\n    fn get_name(&self) -> String {\n        ""payme"".to_string()\n    }\n}\n\nstatic CONNECTOR: PaymeTest = PaymeTest {};\n\nfn get_default_payment_info() -> Option<utils::PaymentInfo> {\n    None\n}\n\nfn payment_method_details() -> Option<types::PaymentsAuthorizeData> {\n    None\n}\n\n// Cards Positive Tests\n// Creates a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_only_authorize_payment() {\n    let response = CONNECTOR\n        .authorize_payment(payment_method_details(), get_default_payment_info())\n        .await\n        .expect(""Authorize payment response"");\n    assert_eq!(response.status, enums::AttemptStatus::Authorized);\n}\n\n// Captures a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_capture_authorized_payment() {\n    let response = CONNECTOR\n        .authorize_and_capture_payment(payment_method_details(), None, get_default_payment_info())\n        .await\n        .expect(""Capture payment response"");\n    assert_eq!(response.status, enums::AttemptStatus::Charged);\n}\n\n// Partially captures a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_partially_capture_authorized_payment() {\n    let response = CONNECTOR\n        .authorize_and_capture_payment(\n            payment_method_details(),\n            Some(types::PaymentsCaptureData {\n                amount_to_capture: MinorUnit::new(50),\n                ..utils::PaymentCaptureType::default().0\n            }),\n            get_default_payment_info(),\n        )\n        .await\n        .expect(""Capture payment response"");\n    assert_eq!(response.status, enums::AttemptStatus::Charged);\n}\n\n// Synchronizes a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_sync_authorized_payment() {\n    let authorize_response = CONNECTOR\n        .authorize_payment(payment_method_details(), get_default_payment_info())\n        .await\n        .expect(""Authorize payment response"");\n    let txn_id = utils::get_connector_transaction_id(authorize_response.response);\n    let response = CONNECTOR\n        .psync_retry_till_status_matches(\n            enums::AttemptStatus::Authorized,\n            Some(types::PaymentsSyncData {\n                connector_transaction_id: types::ResponseId::ConnectorTransactionId(\n                    txn_id.unwrap(),\n                ),\n                ..Default::default()\n            }),\n            get_default_payment_info(),\n        )\n        .await\n        .expect(""PSync response"");\n    assert_eq!(response.status, enums::AttemptStatus::Authorized,);\n}\n\n// Voids a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_void_authorized_payment() {\n    let response = CONNECTOR\n        .authorize_and_void_payment(\n            payment_method_details(),\n            Some(types::PaymentsCancelData {\n                connector_transaction_id: String::from(""""),\n                cancellation_reason: Some(""requested_by_customer"".to_string()),\n                ..Default::default()\n            }),\n            get_default_payment_info(),\n        )\n        .await\n        .expect(""Void payment response"");\n    assert_eq!(response.status, enums::AttemptStatus::Voided);\n}\n\n// Refunds a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_refund_manually_captured_payment() {\n    let response = CONNECTOR\n        .capture_payment_and_refund(\n            payment_method_details(),\n            None,\n            None,\n            get_default_payment_info(),\n        )\n        .await\n        .unwrap();\n    assert_eq!(\n        response.response.unwrap().refund_status,\n        enums::RefundStatus::Success,\n    );\n}\n\n// Partially refunds a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_partially_refund_manually_captured_payment() {\n    let response = CONNECTOR\n        .capture_payment_and_refund(\n            payment_method_details(),\n            None,\n            Some(types::RefundsData {\n                refund_amount: MinorUnit::new(50),\n                ..utils::PaymentRefundType::default().0\n            }),\n            get_default_payment_info(),\n        )\n        .await\n        .unwrap();\n    assert_eq!(\n        response.response.unwrap().refund_status,\n        enums::RefundStatus::Success,\n    );\n}\n\n// Synchronizes a refund using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_sync_manually_captured_refund() {\n    let refund_response = CONNECTOR\n        .capture_payment_and_refund(\n            payment_method_details(),\n            None,\n            None,\n            get_default_payment_info(),\n        )\n        .await\n        .unwrap();\n    let response = CONNECTOR\n        .rsync_retry_till_status_matches(\n            enums::RefundStatus::Success,\n            refund', '', '']",0.8205128205128205,1.7814243594248511,2.7290448343079925,0
crates/router/tests/connectors/payme.rs,2,33,"use std::str::FromStr;

use common_utils::{pii::Email, types::MinorUnit};
use diesel_models::types::OrderDetailsWithAmount;
use hyperswitch_domain_models::address::{Address, AddressDetails};
use masking::Secret;
use router::types::{self, domain, storage::enums, PaymentAddress};

use crate::{
    connector_auth,
    utils::{self, ConnectorActions, PaymentAuthorizeType},
};

#[derive(Clone, Copy)]
s...","
        ""payme"".to_string()
    ","[' ""payme"".to_string() }\n}\n\nstatic CONNECTOR: PaymeTest = PaymeTest {};\n\nfn get_default_payment_info() -> Option<utils::PaymentInfo> {\n    None\n}\n\nfn payment_method_details() -> Option<types::PaymentsAuthorizeData> {\n    None\n}\n\n// Cards Positive Tests\n// Creates a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_only_authorize_payment() {\n    let response = CONNECTOR\n        .authorize_payment(payment_method_details(), get_default_payment_info())\n        .await\n        .expect(""Authorize payment response"");\n    assert_eq!(response.status, enums::AttemptStatus::Authorized);\n}\n\n// Captures a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_capture_authorized_payment() {\n    let response = CONNECTOR\n        .authorize_and_capture_payment(payment_method_details(), None, get_default_payment_info())\n        .await\n        .expect(""Capture payment response"");\n    assert_eq!(response.status, enums::AttemptStatus::Charged);\n}\n\n// Partially captures a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_partially_capture_authorized_payment() {\n    let response = CONNECTOR\n        .authorize_and_capture_payment(\n            payment_method_details(),\n            Some(types::PaymentsCaptureData {\n                amount_to_capture: MinorUnit::new(50),\n                ..utils::PaymentCaptureType::default().0\n            }),\n            get_default_payment_info(),\n        )\n        .await\n        .expect(""Capture payment response"");\n    assert_eq!(response.status, enums::AttemptStatus::Charged);\n}\n\n// Synchronizes a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_sync_authorized_payment() {\n    let authorize_response = CONNECTOR\n        .authorize_payment(payment_method_details(), get_default_payment_info())\n        .await\n        .expect(""Authorize payment response"");\n    let txn_id = utils::get_connector_transaction_id(authorize_response.response);\n    let response = CONNECTOR\n        .psync_retry_till_status_matches(\n            enums::AttemptStatus::Authorized,\n            Some(types::PaymentsSyncData {\n                connector_transaction_id: types::ResponseId::ConnectorTransactionId(\n                    txn_id.unwrap(),\n                ),\n                ..Default::default()\n            }),\n            get_default_payment_info(),\n        )\n        .await\n        .expect(""PSync response"");\n    assert_eq!(response.status, enums::AttemptStatus::Authorized,);\n}\n\n// Voids a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_void_authorized_payment() {\n    let response = CONNECTOR\n        .authorize_and_void_payment(\n            payment_method_details(),\n            Some(types::PaymentsCancelData {\n                connector_transaction_id: String::from(""""),\n                cancellation_reason: Some(""requested_by_customer"".to_string()),\n                ..Default::default()\n            }),\n            get_default_payment_info(),\n        )\n        .await\n        .expect(""Void payment response"");\n    assert_eq!(response.status, enums::AttemptStatus::Voided);\n}\n\n// Refunds a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_refund_manually_captured_payment() {\n    let response = CONNECTOR\n        .capture_payment_and_refund(\n            payment_method_details(),\n            None,\n            None,\n            get_default_payment_info(),\n        )\n        .await\n        .unwrap();\n    assert_eq!(\n        response.response.unwrap().refund_status,\n        enums::RefundStatus::Success,\n    );\n}\n\n// Partially refunds a payment using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_partially_refund_manually_captured_payment() {\n    let response = CONNECTOR\n        .capture_payment_and_refund(\n            payment_method_details(),\n            None,\n            Some(types::RefundsData {\n                refund_amount: MinorUnit::new(50),\n                ..utils::PaymentRefundType::default().0\n            }),\n            get_default_payment_info(),\n        )\n        .await\n        .unwrap();\n    assert_eq!(\n        response.response.unwrap().refund_status,\n        enums::RefundStatus::Success,\n    );\n}\n\n// Synchronizes a refund using the manual capture flow (Non 3DS).\n#[actix_web::test]\nasync fn should_sync_manually_captured_refund() {\n    let refund_response = CONNECTOR\n        .capture_payment_and_refund(\n            payment_method_details(),\n            None,\n            None,\n            get_default_payment_info(),\n        )\n        .await\n        .unwrap();\n    let response = CONNECTOR\n        .rsync_retry_till_status_matches(\n            enums::RefundStatus::Success,\n            refund_response.response.unwrap().connector_refund_id,\n            None,\n            get_default_payment_info(),\n        )\n        .await', '', '']",0.9,0.6451143114151935,1.1952191235059761,0
crates/api_models/src/webhook_events.rs,0,75,"use common_enums::{EventClass, EventType, WebhookDeliveryAttempt};
use masking::Secret;
use serde::{Deserialize, Serialize};
use time::PrimitiveDateTime;
use utoipa::ToSchema;

/// The constraints to apply when filtering events.
#[derive(Clone, Debug, Serialize, Deserialize, ToSchema)]
pub struct EventListConstraints {
    /// Filter events created after the specified time.
    #[serde(default, wi...","
        Self {
            events,
            total_count,
        }
    ","[' Self { events, total_count } }\n}\n\n/// The response body of list delivery attempts api call.\n#[derive(Debug, Serialize, ToSchema)]\npub struct DeliveryAttemptResponse {\n    /// The identifier for the delivery attempt.\n    #[schema(max_length = 64, example = ""evt_018e31720d1b7a2b82677d3032cab959"")]\n    pub delivery_attempt_id: String,\n\n    /// The identifier for the delivery attempt.\n    #[schema(max_length = 64, example = ""evt_018e31720d1b7a2b82677d3032cab959"")]\n    pub event_id: String,\n\n    /// The identifier for the Merchant Account.\n    #[schema(max_length = 64, example = ""y3oqhf46pyzuxjbcn2giaqnb44"", value_type = String)]\n    pub merchant_id: common_utils::id_type::MerchantId,\n\n    /// The identifier for the Business Profile.\n    #[schema(max_length = 64, value_type = String, example = ""SqB0zwDGR5wHppWf0bx7GKr1f2"")]\n    pub profile_id: common_utils::id_type::ProfileId,\n\n    /// The identifier for the object (Payment Intent ID, Refund ID, etc.)\n    #[schema(max_length = 64, example = ""QHrfd5LUDdZaKtAjdJmMu0dMa1"")]\n    pub object_id: String,\n\n    /// Specifies the type of event, which includes the object and its status.\n    pub event_type: EventType,\n\n    /// Specifies the class of event (the type of object: Payment, Refund, etc.)\n    pub event_class: EventClass,\n\n    /// The identifier for the initial delivery attempt. This will be the same as `event_id` for\n    /// the initial delivery attempt.\n    #[schema(max_length = 64, example = ""evt_018e31720d1b7a2b82677d3032cab959"")]\n    pub initial_attempt_id: String,\n\n    /// Time at which the event was created.\n    #[schema(example = ""2022-09-10T10:11:12Z"")]\n    #[serde(with = ""common_utils::custom_serde::iso8601"")]\n    pub created: PrimitiveDateTime,\n\n    /// The status of the delivery attempt.\n    #[schema(value_type = WebhookDeliveryAttempt)]\n    pub status: WebhookDeliveryAttempt,\n}\n\n/// The response body of list delivery attempts api call.\n#[derive(Debug, Serialize, ToSchema)]\npub struct ListDeliveryAttemptsResponse {\n    /// The list of delivery attempts\n    pub delivery_attempts: Vec<DeliveryAttemptResponse>,\n    /// Count of total delivery attempts\n    pub total_count: i64,\n}\n\nimpl ListDeliveryAttemptsResponse {\n    pub fn new(total_count: i64, delivery_attempts: Vec<DeliveryAttemptResponse>) -> Self {\n        Self {\n            delivery_attempts,\n            total_count,\n        }\n    }\n}\n\n/// The response body for each item when listing delivery attempts.\n#[derive(Debug, Serialize, ToSchema)]\npub struct DeliveryAttemptListItemResponse {\n    /// The identifier for the delivery attempt.\n    #[schema(max_length = 64, example = ""evt_018e31720d1b7a2b82677d3032cab959"")]\n    pub delivery_attempt_id: String,\n\n    /// The identifier for the delivery attempt.\n    #[schema(max_length = 64, example = ""evt_018e31720d1b7a2b82677d3032cab959"")]\n    pub event_id: String,\n\n    /// The identifier for the Merchant Account.\n    #[schema(max_length = 64, example = ""y3oqhf46pyzuxjbcn2giaqnb44"", value_type = String)]\n    pub merchant_id: common_utils::id_type::MerchantId,\n\n    /// The identifier for the Business Profile.\n    #[schema(max_length = 64, value_type = String, example = ""SqB0zwDGR5wHppWf0bx7GKr1f2"")]\n    pub profile_id: common_utils::id_type::ProfileId,\n\n    /// The identifier for the object (Payment Intent ID, Refund ID, etc.)\n    #[schema(max_length = 64, example = ""QHrfd5LUDdZaKtAjdJmMu0dMa1"")]\n    pub object_id: String,\n\n    /// Specifies the type of event, which', '', '']",0.9285714285714286,0.9217641594958889,1.9753086419753085,0
crates/api_models/src/webhook_events.rs,1,161,"use common_enums::{EventClass, EventType, WebhookDeliveryAttempt};
use masking::Secret;
use serde::{Deserialize, Serialize};
use time::PrimitiveDateTime;
use utoipa::ToSchema;

/// The constraints to apply when filtering events.
#[derive(Clone, Debug, Serialize, Deserialize, ToSchema)]
pub struct EventListConstraints {
    /// Filter events created after the specified time.
    #[serde(default, wi...","
        Some(common_utils::events::ApiEventsType::Events {
            merchant_id: self.events.first().map(|event| event.merchant_id.clone())?,
        })
    ","[' Some(common_utils::events::ApiEventsType::Webhooks) }\n}\n\n/// The response body for each item when listing delivery attempts.\n#[derive(Debug, Serialize, ToSchema)]\npub struct WebhookDeliveryAttemptResponse {\n    /// The identifier for the delivery attempt.\n    #[schema(max_length = 64, example = ""evt_018e31720d1b7a2b82677d3032cab959"")]\n    pub delivery_attempt_id: String,\n\n    /// The identifier for the delivery attempt.\n    #[schema(max_length = 64, example = ""evt_018e31720d1b7a2b82677d3032cab959"")]\n    pub event_id: String,\n\n    /// The identifier for the Merchant Account.\n    #[schema(max_length = 64, example = ""y3oqhf46pyzuxjbcn2giaqnb44"", value_type = String)]\n    pub merchant_id: common_utils::id_type::MerchantId,\n\n    /// The identifier for the Business Profile.\n    #[schema(max_length = 64, value_type = String, example = ""SqB0zwDGR5wHppWf0bx7GKr1f2"")]\n    pub profile_id: common_utils::id_type::ProfileId,\n\n    /// The identifier for the object (Payment Intent ID, Refund ID, etc.)\n    #[schema(max_length = 64, example = ""QHrfd5LUDdZaKtAjdJmMu0dMa1"")]\n    pub object_id: String,\n\n    /// Specifies the type of event, which includes the object and its status.\n    pub event_type: EventType,\n\n    /// Specifies the class of event (the type of object: Payment, Refund, etc.)\n    pub event_class: EventClass,\n\n    /// The identifier for the initial delivery attempt. This will be the same as `event_id` for\n    /// the initial delivery attempt.\n    #[schema(max_length = 64, example = ""evt_018e31720d1b7a2b82677d3032cab959"")]\n    pub initial_attempt_id: String,\n\n    /// Time at which the event was created.\n    #[schema(example = ""2022-09-10T10:11:12Z"")]\n    #[serde(with = ""common_utils::custom_serde::iso8601"")]\n    pub created: PrimitiveDateTime,\n\n    /// The delivery attempt status.\n    #[schema(value_type = WebhookDeliveryAttempt)]\n    pub delivery_attempt_status: WebhookDeliveryAttempt,\n}\n\nimpl common_utils::events::ApiEventMetric for WebhookDeliveryAttemptResponse {\n    fn get_api_event_type(&self) -> Option<common_utils::events::ApiEventsType> { Some(common_utils::events::ApiEventsType::Webhooks) }\n}\n\n/// The response body for each item when listing delivery attempts.\n#[derive(Debug, Serialize, ToSchema)]\npub struct WebhookDeliveryAttemptResponseWithDeliveryAttemptId {\n    /// The identifier for the delivery attempt.\n    #[schema(max_length = 64, example = ""evt_018e31720d1b7a2b82677d3032cab959"")]\n    pub delivery_attempt_id: String,\n\n    /// The identifier for the delivery attempt.\n    #[schema(max_length = 64, example = ""evt_018e31720d1b7a2b82677d3032cab959"")]\n    pub event_id: String,\n\n    /// The identifier for the Merchant Account.\n    #[schema(max_length = 64, example = ""y3oqhf46pyzuxjbcn2giaqnb44"", value_type = String)]\n    pub merchant_id: common_utils::id_type::MerchantId,\n\n    /// The identifier for the Business Profile.\n    #[schema(max_length = 64, value_type = String, example = ""SqB0zwDGR5wHppWf0bx7GKr1f2"")]\n    pub profile_id: common_utils::id_type::ProfileId,\n\n    /// The identifier for the object (Payment Intent ID, Refund ID, etc.)\n    #[schema(max_length = 64, example = ""QHrfd5LUDdZaKtAjdJmMu0dMa1"")]\n    pub object_id: String,\n\n    /// Specifies the type of event, which includes the object and its status.\n    pub event_type: EventType,\n\n    /// Specifies the class of event (the type of object: Payment, Refund, etc.)\n    pub event_class: EventClass,\n\n', '', '']",0.5277777777777778,2.2317292204147776,5.741626794258373,0
crates/api_models/src/webhook_events.rs,2,144,"use common_enums::{EventClass, EventType, WebhookDeliveryAttempt};
use masking::Secret;
use serde::{Deserialize, Serialize};
use time::PrimitiveDateTime;
use utoipa::ToSchema;

/// The constraints to apply when filtering events.
#[derive(Clone, Debug, Serialize, Deserialize, ToSchema)]
pub struct EventListConstraints {
    /// Filter events created after the specified time.
    #[serde(default, wi...","
        Some(common_utils::events::ApiEventsType::Events {
            merchant_id: self.event_information.merchant_id.clone(),
        })
    ","[' Some(common_utils::events::ApiEventsType::Events {\n        merchant_id: self.event_information.merchant_id.clone(),\n    }) }\n\n    fn get_api_event_object(&self) -> Option<common_utils::events::ApiEventsObject> {\n        Some(common_utils::events::ApiEventsObject::WebhookDeliveryAttempt {\n            delivery_attempt: self.delivery_attempt,\n            request: self.request,\n            response: self.response,\n        })\n    }\n}\n\n/// The request information sent in the webhook.\n#[derive(Debug, Serialize, ToSchema)]\npub struct OutgoingWebhookRequestContent {\n    /// The request method.\n    pub method: common_enums::http::Method,\n\n    /// The request headers.\n    pub headers: Option<Vec<(String, masking::Maskable<String>)>,\n\n    /// The request body.\n    pub body: Option<masking::SecretSerdeValue>,\n}\n\n/// The response information received for the webhook sent.\n#[derive(Debug, Serialize, ToSchema)]\npub struct OutgoingWebhookResponseContent {\n    /// The response status code.\n    pub status_code: u16,\n\n    /// The response headers.\n    pub headers: Option<Vec<(String, masking::Maskable<String>)>,\n\n    /// The response body.\n    pub body: Option<masking::SecretSerdeValue>,\n}\n\n/// The response body for retrieving an event delivery attempt.\n#[derive(Debug, Serialize, ToSchema)]\npub struct EventDeliveryAttemptResponse {\n    /// The identifier for the delivery attempt.\n    #[schema(max_length = 64, example = ""evt_018e31720d1b7a2b82677d3032cab959"")]\n    pub delivery_attempt_id: String,\n\n    /// The identifier for the delivery attempt.\n    #[schema(max_length = 64, example = ""evt_018e31720d1b7a2b82677d3032cab959"")]\n    pub event_id: String,\n\n    /// The identifier for the delivery attempt.\n    #[schema(max_length = 64, example = ""evt_018e31720d1b7a2b82677d3032cab959"")]\n    pub attempt_id: String,\n\n    /// The identifier for the delivery attempt.\n    #[schema(max_length = 64, example = ""evt_018e31720d1b7a2b82677d3032cab959"")]\n    pub delivery_attempt_status: WebhookDeliveryAttempt,\n\n    /// The identifier for the delivery attempt.\n    #[schema(max_length = 64, example = ""evt_018e31720d1b7a2b82677d3032cab959"")]\n    pub delivery_attempt_reason: Option<String>,\n\n    /// The identifier for the delivery attempt.\n    #[schema(max_length = 64, example = ""evt_018e31720d1b7a2b82677d3032cab959"")]\n    pub delivery_attempt_error: Option<String>,\n\n    /// The identifier for the delivery attempt.\n    #[schema(max_length = 64, example = ""evt_018e31720d1b7a2b82677d3032cab959"")]\n    pub delivery_attempt_error_code: Option<String>,\n\n    /// The identifier for the delivery attempt.\n    #[schema(max_length = 64, example = ""evt_018e31720d1b7a2b82677d3032cab959"")]\n    pub delivery_attempt_error_message: Option<String>,\n\n    /// The identifier for the delivery attempt.\n    #[schema(max_length = 64, example = ""evt_018e31720d1b7a2b82677d3032cab959"")]\n    pub delivery_attempt_error_reason: Option<String>,\n\n    /// The identifier for the delivery attempt.\n    #[schema(max_length = 64, example = ""evt_018e31720d1b7a2b82677d3032cab959"")]\n    pub delivery_attempt_error_type: Option<String>,\n\n    /// The identifier for the delivery attempt.\n    #[schema(max_length = 64, example = ""evt_018e31720d1b7a2b82677d3032cab959"")]\n    pub delivery_attempt_error_message: Option<String>,\n\n    /// The identifier for the delivery attempt.\n    #[schema(max_length = 6', '', '']",0.9310344827586207,4.3229653079220345,7.4866310160427805,0
crates/api_models/src/events/locker_migration.rs,0,67,"use common_utils::events::ApiEventMetric;

use crate::locker_migration::MigrateCardResponse;

impl ApiEventMetric for MigrateCardResponse {
    fn get_api_event_type(&self) -> Option<common_utils::events::ApiEventsType> {","
        Some(common_utils::events::ApiEventsType::RustLocker)
    ","[' self.migrate_type }\n}\nimpl ApiEventMetric for common_enums::MigrateCardType {\n    fn get_api_event_type(&self) -> Option<common_utils::events::ApiEventsType> { Some(*self) }\n}\nimpl ApiEventMetric for common_enums::MigrateCardStatus {\n    fn get_api_event_type(&self) -> Option<common_utils::events::ApiEventsType> { Some(*self) }\n}\nimpl ApiEventMetric for common_enums::MigrateCardReason {\n    fn get_api_event_type(&self) -> Option<common_utils::events::ApiEventsType> { Some(*self) }\n}\nimpl ApiEventMetric for common_enums::MigrateCardError {\n    fn get_api_event_type(&self) -> Option<common_utils::events::ApiEventsType> { Some(*self) }\n}\nimpl ApiEventMetric for common_enums::MigrateCardErrorReason {\n    fn get_api_event_type(&self) -> Option<common_utils::events::ApiEventsType> { Some(*self) }\n}\nimpl ApiEventMetric for common_enums::MigrateCardErrorType {\n    fn get_api_event_type(&self) -> Option<common_utils::events::ApiEventsType> { Some(*self) }\n}\nimpl ApiEventMetric for common_enums::MigrateCardErrorSubType {\n    fn get_api_event_type(&self) -> Option<common_utils::events::ApiEventsType> { Some(*self) }\n}\nimpl ApiEventMetric for common_enums::MigrateCardErrorSubSubType {\n    fn get_api_event_type(&self) -> Option<common_utils::events::ApiEventsType> { Some(*self) }\n}\nimpl ApiEventMetric for common_enums::MigrateCardErrorSubSubSubType {\n    fn get_api_event_type(&self) -> Option<common_utils::events::ApiEventsType> { Some(*self) }\n}\nimpl ApiEventMetric for common_enums::MigrateCardErrorSubSubSubSubType {\n    fn get_api_event_type(&self) -> Option<common_utils::events::ApiEventsType> { Some(*self) }\n}\nimpl ApiEventMetric for common_enums::MigrateCardErrorSubSubSubSubSubType {\n    fn get_api_event_type(&self) -> Option<common_utils::events::ApiEventsType> { Some(*self) }\n}\nimpl ApiEventMetric for common_enums::MigrateCardErrorSubSubSubSubSubSubType {\n    fn get_api_event_type(&self) -> Option<common_utils::events::ApiEventsType> { Some(*self) }\n}\nimpl ApiEventMetric for common_enums::MigrateCardErrorSubSubSubSubSubSubSubType {\n    fn get_api_event_type(&self) -> Option<common_utils::events::ApiEventsType> { Some(*self) }\n}\nimpl ApiEventMetric for common_enums::MigrateCardErrorSubSubSubSubSubSubSubSubType {\n    fn get_api_event_type(&self) -> Option<common_utils::events::ApiEventsType> { Some(*self) }\n}\nimpl ApiEventMetric for common_enums::MigrateCardErrorSubSubSubSubSubSubSubSubSubType {\n    fn get_api_event_type(&self) -> Option<common_utils::events::ApiEventsType> { Some(*self) }\n}\nimpl ApiEventMetric for common_enums::MigrateCardErrorSubSubSubSubSubSubSubSubSubSubType {\n    fn get_api_event_type(&self) -> Option<common_utils::events::ApiEventsType> { Some(*self) }\n}\nimpl ApiEventMetric for common_enums::MigrateCardErrorSubSubSubSubSubSubSubSubSubSubSubType {\n    fn get_api_event_type(&self) -> Option<common_utils::events::ApiEventsType> { Some(*self) }\n}\nimpl ApiEventMetric for common_enums::MigrateCardErrorSubSubSubSubSubSubSubSubSubSubSubSubType {\n    fn get_api_event_type(&self) -> Option<common_utils::events::ApiEventsType> { Some(*self) }\n}\nimpl ApiEventMetric for common_enums::MigrateCardErrorSubSubSubSubSubSubSubSubSubSubSubSubSubType {\n    fn get_api_event_type(&self) -> Option<common_utils::events::ApiEventsType> { Some(*self) }\n}\nimpl ApiEventMetric for common_enums::MigrateCardErrorSubSubSubSubSubSubSubSubSubSubSubSubSubSubType {\n    fn get_api_event_type(&self) -> Option<common_utils::events::ApiEventsType> { Some(*self) }\n}\nimpl ApiEventMetric for common_enums::MigrateCardErrorSubSubSubSubSubSubSubSubSubSubSubSubSubSubSubType {\n    fn get_api_event_type(&self) -> Option<common_utils::events::ApiEventsType> { Some(*self) }\n', '', '']",0.5294117647058824,0.9431108436519093,2.450980392156863,0
crates/router/tests/connectors/getnet.rs,0,229,"use hyperswitch_domain_models::payment_method_data::{Card, PaymentMethodData};
use masking::Secret;
use router::types::{self, api, storage::enums};
use test_utils::connector_auth;

use crate::utils::{self, ConnectorActions};

#[derive(Clone, Copy)]
struct GetnetTest;
impl ConnectorActions for GetnetTest {}
impl utils::Connector for GetnetTest {
    fn get_data(&self) -> api::ConnectorData {","
        use router::connector::Getnet;
        utils::construct_connector_data_old(
            Box::new(Getnet::new()),
            types::Connector::Plaid,
            api::GetToken::Connector,
            None,
        )
    ","['', '', '']",0.0,0.0,0.0,0
crates/router/tests/connectors/getnet.rs,1,236,"use hyperswitch_domain_models::payment_method_data::{Card, PaymentMethodData};
use masking::Secret;
use router::types::{self, api, storage::enums};
use test_utils::connector_auth;

use crate::utils::{self, ConnectorActions};

#[derive(Clone, Copy)]
struct GetnetTest;
impl ConnectorActions for GetnetTest {}
impl utils::Connector for GetnetTest {
    fn get_data(&self) -> api::ConnectorData {
      ...","
        utils::to_connector_auth_type(
            connector_auth::ConnectorAuthentication::new()
                .getnet
                .expect(""Missing connector authentication configuration"")
                .into(),
        )
    ","['', '', '']",0.0,0.0,0.0,0
crates/router/tests/connectors/getnet.rs,2,34,"use hyperswitch_domain_models::payment_method_data::{Card, PaymentMethodData};
use masking::Secret;
use router::types::{self, api, storage::enums};
use test_utils::connector_auth;

use crate::utils::{self, ConnectorActions};

#[derive(Clone, Copy)]
struct GetnetTest;
impl ConnectorActions for GetnetTest {}
impl utils::Connector for GetnetTest {
    fn get_data(&self) -> api::ConnectorData {
      ...","
        ""getnet"".to_string()
    ","['', '', '']",0.0,0.0,0.0,0
crates/router/src/db/fraud_check.rs,0,1828,"use diesel_models::fraud_check::{self as storage, FraudCheck, FraudCheckUpdate};
use error_stack::report;
use router_env::{instrument, tracing};

use super::MockDb;
use crate::{
    connection,
    core::errors::{self, CustomResult},
    services::Store,
};

#[async_trait::async_trait]
pub trait FraudCheckInterface {
    async fn insert_fraud_check_response(
        &self,
        new: storage::Fr...","
    #[instrument(skip_all)]
    async fn insert_fraud_check_response(
        &self,
        new: storage::FraudCheckNew,
    ) -> CustomResult<FraudCheck, errors::StorageError> {
        let conn = connection::pg_connection_write(self).await?;
        new.insert(&conn)
            .await
            .map_err(|error| report!(errors::StorageError::from(error)))
    }

    #[instrument(skip_all)]
 ...","['', '', '']",0.0,0.0,0.0,0
crates/router/src/db/fraud_check.rs,1,53,"use diesel_models::fraud_check::{self as storage, FraudCheck, FraudCheckUpdate};
use error_stack::report;
use router_env::{instrument, tracing};

use super::MockDb;
use crate::{
    connection,
    core::errors::{self, CustomResult},
    services::Store,
};

#[async_trait::async_trait]
pub trait FraudCheckInterface {
    async fn insert_fraud_check_response(
        &self,
        new: storage::Fr...","
        Err(errors::StorageError::MockDbError)?
    ","['', '', '']",0.0,0.0,0.0,0
crates/router/src/db/fraud_check.rs,2,53,"use diesel_models::fraud_check::{self as storage, FraudCheck, FraudCheckUpdate};
use error_stack::report;
use router_env::{instrument, tracing};

use super::MockDb;
use crate::{
    connection,
    core::errors::{self, CustomResult},
    services::Store,
};

#[async_trait::async_trait]
pub trait FraudCheckInterface {
    async fn insert_fraud_check_response(
        &self,
        new: storage::Fr...","
        Err(errors::StorageError::MockDbError)?
    ","['', '', '']",0.0,0.0,0.0,0
crates/router/tests/connectors/airwallex.rs,0,240,"use std::str::FromStr;

use hyperswitch_domain_models::address::{Address, AddressDetails};
use masking::{PeekInterface, Secret};
use router::types::{self, domain, storage::enums, AccessToken};

use crate::{
    connector_auth,
    utils::{self, Connector, ConnectorActions},
};

#[derive(Clone, Copy)]
struct AirwallexTest;
impl ConnectorActions for AirwallexTest {}

static CONNECTOR: AirwallexTest ...","
        use router::connector::Airwallex;
        utils::construct_connector_data_old(
            Box::new(&Airwallex),
            types::Connector::Airwallex,
            types::api::GetToken::Connector,
            None,
        )
    ","['', '', '']",0.0,0.0,0.0,0
crates/router/tests/connectors/airwallex.rs,1,239,"use std::str::FromStr;

use hyperswitch_domain_models::address::{Address, AddressDetails};
use masking::{PeekInterface, Secret};
use router::types::{self, domain, storage::enums, AccessToken};

use crate::{
    connector_auth,
    utils::{self, Connector, ConnectorActions},
};

#[derive(Clone, Copy)]
struct AirwallexTest;
impl ConnectorActions for AirwallexTest {}

static CONNECTOR: AirwallexTest ...","
        utils::to_connector_auth_type(
            connector_auth::ConnectorAuthentication::new()
                .airwallex
                .expect(""Missing connector authentication configuration"")
                .into(),
        )
    ","['', '', '']",0.0,0.0,0.0,0
crates/router/tests/connectors/airwallex.rs,2,37,"use std::str::FromStr;

use hyperswitch_domain_models::address::{Address, AddressDetails};
use masking::{PeekInterface, Secret};
use router::types::{self, domain, storage::enums, AccessToken};

use crate::{
    connector_auth,
    utils::{self, Connector, ConnectorActions},
};

#[derive(Clone, Copy)]
struct AirwallexTest;
impl ConnectorActions for AirwallexTest {}

static CONNECTOR: AirwallexTest ...","
        ""airwallex"".to_string()
    ","['', '', '']",0.0,0.0,0.0,0
crates/hyperswitch_connectors/src/connectors/fiserv/transformers.rs,0,79,"use common_enums::enums;
use common_utils::{ext_traits::ValueExt, pii, types::FloatMajorUnit};
use error_stack::ResultExt;
use hyperswitch_domain_models::{
    payment_method_data::PaymentMethodData,
    router_data::{ConnectorAuthType, RouterData},
    router_flow_types::refunds::{Execute, RSync},
    router_request_types::ResponseId,
    router_response_types::{PaymentsResponseData, RefundsRespo...","
        Ok(Self {
            amount,
            router_data,
        })
    ","['', '', '']",0.0,0.0,0.0,0
crates/hyperswitch_connectors/src/connectors/fiserv/transformers.rs,1,3437,"use common_enums::enums;
use common_utils::{ext_traits::ValueExt, pii, types::FloatMajorUnit};
use error_stack::ResultExt;
use hyperswitch_domain_models::{
    payment_method_data::PaymentMethodData,
    router_data::{ConnectorAuthType, RouterData},
    router_flow_types::refunds::{Execute, RSync},
    router_request_types::ResponseId,
    router_response_types::{PaymentsResponseData, RefundsRespo...","
        let auth: FiservAuthType = FiservAuthType::try_from(&item.router_data.connector_auth_type)?;
        let amount = Amount {
            total: item.amount,
            currency: item.router_data.request.currency.to_string(),
        };
        let transaction_details = TransactionDetails {
            capture_flag: Some(matches!(
                item.router_data.request.capture_method,
   ...","['', '', '']",0.0,0.0,0.0,0
crates/hyperswitch_connectors/src/connectors/fiserv/transformers.rs,2,425,"use common_enums::enums;
use common_utils::{ext_traits::ValueExt, pii, types::FloatMajorUnit};
use error_stack::ResultExt;
use hyperswitch_domain_models::{
    payment_method_data::PaymentMethodData,
    router_data::{ConnectorAuthType, RouterData},
    router_flow_types::refunds::{Execute, RSync},
    router_request_types::ResponseId,
    router_response_types::{PaymentsResponseData, RefundsRespo...","
        if let ConnectorAuthType::SignatureKey {
            api_key,
            key1,
            api_secret,
        } = auth_type
        {
            Ok(Self {
                api_key: api_key.to_owned(),
                merchant_account: key1.to_owned(),
                api_secret: api_secret.to_owned(),
            })
        } else {
            Err(errors::ConnectorError::FailedToObtain...","['', '', '']",0.0,0.0,0.0,0
crates/router/tests/health_check.rs,0,150,"mod utils;

use utils::{mk_service, AppClient};

#[actix_web::test]
async fn health_check() {","
    let server = Box::pin(mk_service()).await;
    let client = AppClient::guest();

    assert_eq!(client.health(&server).await, ""health is good"");
","['', '', '']",0.0,0.0,0.0,0
