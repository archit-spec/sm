[
  {
    "file": "crates/router/src/db/user_role.rs",
    "mask_idx": 0,
    "target_len": 4951,
    "prompt_snippet": "use common_utils::id_type;\nuse diesel_models::{\n    enums::{self, UserStatus},\n    user_role as storage,\n};\nuse error_stack::{report, ResultExt};\nuse router_env::{instrument, tracing};\n\nuse super::MockDb;\nuse crate::{\n    connection,\n    core::errors::{self, CustomResult},\n    services::Store,\n};\n\npub struct ListUserRolesByOrgIdPayload<'a> {\n    pub user_id: Option<&'a String>,\n    pub tenant_id: ...",
    "target_snippet": "\n    #[instrument(skip_all)]\n    async fn insert_user_role(\n        &self,\n        user_role: storage::UserRoleNew,\n    ) -> CustomResult<storage::UserRole, errors::StorageError> {\n        let conn = connection::pg_connection_write(self).await?;\n\n        user_role\n            .insert(&conn)\n            .await\n            .map_err(|error| report!(errors::StorageError::from(error)))\n    }\n\n    #[ins...",
    "generations": [
      " // Database related implementations\n    #[instrument(skip_all)]\n    async fn insert_user_role(\n        &self,\n        user_role: storage::UserRoleNew,\n    ) -> CustomResult<storage::UserRole, errors::StorageError> {\n        let conn = connection::pg_connection_write(self).await?;\n        user_role\n            .insert(&conn)\n            .await\n            .map_err(|error| report!(errors::StorageError::from(error)))\n    }\n\n    #[instrument(skip_all)]\n    async fn find_user_role_by_user_id_and_lineage(\n        &self,\n        user_id: &str,\n        tenant_id: &id_type::TenantId,\n        org_id: &id_type::OrganizationId,\n        merchant_id: &id_type::MerchantId,\n        profile_id: &id_type::ProfileId,\n        version: enums::UserRoleVersion,\n    ) -> CustomResult<storage::UserRole, errors::StorageError> {\n        let conn = connection::pg_connection_read(self).await?;\n        storage::UserRole::find_by_user_id_tenant_id_org_id_merchant_id_profile_id(\n            &conn,\n            user_id,\n            tenant_id,\n            org_id,\n            merchant_id,\n            profile_id,\n            version,\n        )\n        .await\n        .map_err(|error| report!(errors::StorageError::from(error)))\n    }\n\n    #[instrument(skip_all)]\n    async fn update_user_role_by_user_id_and_lineage(\n        &self,\n        user_id: &str,\n        tenant_id: &id_type::TenantId,\n        org_id: &id_type::OrganizationId,\n        merchant_id: Option<&id_type::MerchantId>,\n        profile_id: Option<&id_type::ProfileId>,\n        update: storage::UserRoleUpdate,\n        version: enums::UserRoleVersion,\n    ) -> CustomResult<storage::UserRole, errors::StorageError> {\n        let conn = connection::pg_connection_write(self).await?;\n        storage::UserRole::update_by_user_id_tenant_id_org_id_merchant_id_profile_id(\n            &conn,\n            user_id,\n            tenant_id,\n            org_id,\n            merchant_id.cloned(),\n            profile_id.cloned(),\n            update,\n            version,\n        )\n        .await\n        .map_err(|error| report!(errors::StorageError::from(error)))\n    }\n\n    #[instrument(skip_all)]\n    async fn delete_user_role_by_user_id_and_lineage(\n        &self,\n        user_id: &str,\n        tenant_id: &id_type::TenantId,\n        org_id: &id_type::OrganizationId,\n        merchant_id: &id_type::MerchantId,\n        profile_id: &id_type::ProfileId,\n        version: enums::UserRoleVersion,\n    ) -> CustomResult<storage::UserRole, errors::StorageError> {\n        let conn = connection::pg_connection_write(self).await?;\n        storage::UserRole::delete_by_user_id_tenant_id_org_id_merchant_id_profile_id(\n            &conn,\n            user_id,\n            tenant_id,\n            org_id,\n            merchant_id,\n            profile_id,\n            version,\n        )\n        .await\n        .map_err(|error| report!(errors::StorageError::from(error)))\n    }\n\n    #[instrument(skip_all)]\n    async fn list_user_roles_by_user_id<'a>(\n        &self,\n        payload: ListUserRolesByUserIdPayload<'a>,\n    ) -> CustomResult<Vec<storage::UserRole>, errors::StorageError> {\n        let conn = connection::pg_connection_read(self).await?;\n        storage::UserRole::list_user_roles_by_user_id(\n            &conn,\n            payload.user_id,\n            payload.tenant_id,\n            payload.org_id.cloned(),\n            payload.merchant_id.cloned(),\n            payload.profile_id.cloned(),\n            payload.entity_id.cloned(),\n            payload.status.cloned(),\n            payload.limit.cloned(),\n            payload.version.cloned(),\n        )\n        .await\n        .map_err(|error| report!(errors::StorageError::from(error)))\n    }\n\n    #[instrument(skip_all)]\n    async fn list_user_roles_by_user_id_across_tenants(\n        &self,\n        user_id: &str,\n        limit: Option<u32>,\n    ) -> CustomResult<Vec<storage::UserRole>, errors::StorageError> {\n        let conn = connection::pg_connection_read(self).await?;\n        storage::UserRole::list_user_roles_by_user_id_across_tenants(&conn, user_id, limit)\n            .await\n            .map_err(|error| report!(errors::StorageError::from(error)))\n    }\n\n    #[instrument(skip_all)]\n    async fn list_user_roles_by_org_id<'a>(\n        &self,\n        payload: ListUserRolesByOrgIdPayload<'a>,\n    ) -> CustomResult<Vec<storage::UserRole>, errors::StorageError> {\n        let conn = connection::pg_connection_read(self).await?;\n        storage::UserRole::list_user_roles_by_org_id(\n            &conn,\n            payload.user_id.cloned",
      "",
      ""
    ],
    "best_token_recall": 0.9590909090909091,
    "best_bleu": 82.9966681035222,
    "best_rougeL": 90.73359073359075,
    "exact_match_any": 0
  },
  {
    "file": "crates/router/src/db/user_role.rs",
    "mask_idx": 1,
    "target_len": 1180,
    "prompt_snippet": "use common_utils::id_type;\nuse diesel_models::{\n    enums::{self, UserStatus},\n    user_role as storage,\n};\nuse error_stack::{report, ResultExt};\nuse router_env::{instrument, tracing};\n\nuse super::MockDb;\nuse crate::{\n    connection,\n    core::errors::{self, CustomResult},\n    services::Store,\n};\n\npub struct ListUserRolesByOrgIdPayload<'a> {\n    pub user_id: Option<&'a String>,\n    pub tenant_id: ...",
    "target_snippet": "\n        let mut db_user_roles = self.user_roles.lock().await;\n\n        if db_user_roles\n            .iter()\n            .any(|user_role_inner| user_role_inner.user_id == user_role.user_id)\n        {\n            Err(errors::StorageError::DuplicateValue {\n                entity: \"user_id\",\n                key: None,\n            })?\n        }\n        let user_role = storage::UserRole {\n            i...",
    "generations": [
      " Ok(user_role) }\n\n    async fn find_user_role_by_user_id_and_lineage(\n        &self,\n        user_id: &str,\n        tenant_id: &id_type::TenantId,\n        org_id: &id_type::OrganizationId,\n        merchant_id: &id_type::MerchantId,\n        profile_id: &id_type::ProfileId,\n        version: enums::UserRoleVersion,\n    ) -> CustomResult<storage::UserRole, errors::StorageError> {\n        self.user_role\n            .iter()\n            .find(|user_role| {\n                user_role.user_id == user_id\n                    && user_role.tenant_id == tenant_id\n                    && user_role.org_id == org_id\n                    && user_role.merchant_id == merchant_id\n                    && user_role.profile_id == profile_id\n                    && user_role.version == version\n            })\n            .cloned()\n            .ok_or(errors::StorageError::ValueNotFound(\n                \"user role not found\".to_string(),\n            ))\n    }\n\n    async fn update_user_role_by_user_id_and_lineage(\n        &self,\n        user_id: &str,\n        tenant_id: &id_type::TenantId,\n        org_id: &id_type::OrganizationId,\n        merchant_id: Option<&id_type::MerchantId>,\n        profile_id: Option<&id_type::ProfileId>,\n        update: storage::UserRoleUpdate,\n        version: enums::UserRoleVersion,\n    ) -> CustomResult<storage::UserRole, errors::StorageError> {\n        self.user_role\n            .iter_mut()\n            .find(|user_role| {\n                user_role.user_id == user_id\n                    && user_role.tenant_id == tenant_id\n                    && user_role.org_id == org_id\n                    && user_role.merchant_id == merchant_id.cloned()\n                    && user_role.profile_id == profile_id.cloned()\n                    && user_role.version == version\n            })\n            .map(|user_role| {\n                *user_role = user_role.clone().update(update);\n                user_role.clone()\n            })\n            .ok_or(errors::StorageError::ValueNotFound(\n                \"user role not found\".to_string(),\n            ))\n    }\n\n    async fn delete_user_role_by_user_id_and_lineage(\n        &self,\n        user_id: &str,\n        tenant_id: &id_type::TenantId,\n        org_id: &id_type::OrganizationId,\n        merchant_id: &id_type::MerchantId,\n        profile_id: &id_type::ProfileId,\n        version: enums::UserRoleVersion,\n    ) -> CustomResult<storage::UserRole, errors::StorageError> {\n        self.user_role\n            .iter()\n            .position(|user_role| {\n                user_role.user_id == user_id\n                    && user_role.tenant_id == tenant_id\n                    && user_role.org_id == org_id\n                    && user_role.merchant_id == merchant_id\n                    && user_role.profile_id == profile_id\n                    && user_role.version == version\n            })\n            .map(|index| {\n                self.user_role.remove(index);\n                Ok(self.user_role[index])\n            })\n            .transpose()\n            .map_err(|_| errors::StorageError::ValueNotFound(\n                \"user role not found\".to_string(),\n            ))\n    }\n\n    async fn list_user_roles_by_user_id<'a>(\n        &self,\n        payload: ListUserRolesByUserIdPayload<'a>,\n    ) -> CustomResult<Vec<storage::UserRole>, errors::StorageError> {\n        let mut user_role_list = Vec::new();\n        for user_role in self.user_role.iter() {\n            if user_role.user_id == payload.user_id\n                && user_role.tenant_id == payload.tenant_id\n                && user_role.org_id == payload.org_id.cloned()\n                && user_role.merchant_id == payload.merchant_id.cloned()\n                && user_role.profile_id == payload.profile_id.cloned()\n                && user_role.entity_id == payload.entity_id.cloned()\n                && user_role.status == payload.status\n                && user_role.version == payload.version\n            {\n                user_role_list.push(user_role.clone());\n            }\n        }\n        Ok(user_role_list)\n    }\n\n    async fn list_user_roles_by_user_id_across_tenants(\n        &self,\n        user_id: &str,\n        limit: Option<u32>,\n    ) -> CustomResult<Vec<storage::UserRole>, errors::StorageError> {\n        let mut user_role_list = Vec::new();\n        for user_role in self.user_role.iter() {\n            if user_role.user_id == user_id {\n                user_role_list.push(user_role.clone());\n            }\n        }\n        Ok(user_role_list)\n    }\n\n    async fn list_user_roles_by_org_id<'a>(\n        &self,\n        payload: ListUserRolesByOrgIdPayload<'a>,\n    ) -> CustomResult<Vec<storage::UserRole>, errors::StorageError> {\n        let mut user_role_list = Vec::new();\n        for user_role in self.user_role.iter",
      "",
      ""
    ],
    "best_token_recall": 0.782258064516129,
    "best_bleu": 11.801527496402446,
    "best_rougeL": 23.692307692307693,
    "exact_match_any": 0
  },
  {
    "file": "crates/router/src/db/user_role.rs",
    "mask_idx": 2,
    "target_len": 1694,
    "prompt_snippet": "use common_utils::id_type;\nuse diesel_models::{\n    enums::{self, UserStatus},\n    user_role as storage,\n};\nuse error_stack::{report, ResultExt};\nuse router_env::{instrument, tracing};\n\nuse super::MockDb;\nuse crate::{\n    connection,\n    core::errors::{self, CustomResult},\n    services::Store,\n};\n\npub struct ListUserRolesByOrgIdPayload<'a> {\n    pub user_id: Option<&'a String>,\n    pub tenant_id: ...",
    "target_snippet": "\n        let user_roles = self.user_roles.lock().await;\n\n        for user_role in user_roles.iter() {\n            let tenant_level_check = user_role.tenant_id == *tenant_id\n                && user_role.org_id.is_none()\n                && user_role.merchant_id.is_none()\n                && user_role.profile_id.is_none();\n\n            let org_level_check = user_role.tenant_id == *tenant_id\n          ...",
    "generations": [
      "",
      "",
      ""
    ],
    "best_token_recall": 0.0,
    "best_bleu": 0.0,
    "best_rougeL": 0.0,
    "exact_match_any": 0
  },
  {
    "file": "crates/analytics/src/payments/metrics.rs",
    "mask_idx": 0,
    "target_len": 3941,
    "prompt_snippet": "use std::collections::HashSet;\n\nuse api_models::analytics::{\n    payments::{PaymentDimensions, PaymentFilters, PaymentMetrics, PaymentMetricsBucketIdentifier},\n    Granularity, TimeRange,\n};\nuse diesel_models::enums as storage_enums;\nuse time::PrimitiveDateTime;\n\nuse crate::{\n    enums::AuthInfo,\n    query::{Aggregate, GroupByClause, ToSql, Window},\n    types::{AnalyticsCollection, AnalyticsDataSo...",
    "target_snippet": "\n    async fn load_metrics(\n        &self,\n        dimensions: &[PaymentDimensions],\n        auth: &AuthInfo,\n        filters: &PaymentFilters,\n        granularity: Option<Granularity>,\n        time_range: &TimeRange,\n        pool: &T,\n    ) -> MetricsResult<HashSet<(PaymentMetricsBucketIdentifier, PaymentMetricRow)>> {\n        match self {\n            Self::PaymentSuccessRate => {\n               ...",
    "generations": [
      "",
      "",
      ""
    ],
    "best_token_recall": 0.0,
    "best_bleu": 0.0,
    "best_rougeL": 0.0,
    "exact_match_any": 0
  },
  {
    "file": "crates/analytics/src/api_event/events.rs",
    "mask_idx": 0,
    "target_len": 2704,
    "prompt_snippet": "use api_models::analytics::{\n    api_event::{ApiLogsRequest, QueryType},\n    Granularity,\n};\nuse common_utils::errors::ReportSwitchExt;\nuse error_stack::ResultExt;\nuse router_env::Flow;\nuse time::PrimitiveDateTime;\n\nuse crate::{\n    query::{Aggregate, GroupByClause, QueryBuilder, ToSql, Window},\n    types::{AnalyticsCollection, AnalyticsDataSource, FiltersError, FiltersResult, LoadRow},\n};\npub tra...",
    "target_snippet": "\n    let mut query_builder: QueryBuilder<T> = QueryBuilder::new(AnalyticsCollection::ApiEvents);\n    query_builder.add_select_column(\"*\").switch()?;\n\n    query_builder\n        .add_filter_clause(\"merchant_id\", merchant_id)\n        .switch()?;\n    match query_param.query_param {\n        QueryType::Payment { payment_id } => {\n            query_builder\n                .add_filter_clause(\"payment_id\",...",
    "generations": [
      "",
      "",
      ""
    ],
    "best_token_recall": 0.0,
    "best_bleu": 0.0,
    "best_rougeL": 0.0,
    "exact_match_any": 0
  },
  {
    "file": "crates/diesel_models/src/query/role.rs",
    "mask_idx": 0,
    "target_len": 56,
    "prompt_snippet": "use async_bb8_diesel::AsyncRunQueryDsl;\nuse common_enums::EntityType;\nuse common_utils::id_type;\nuse diesel::{\n    associations::HasTable, debug_query, pg::Pg, result::Error as DieselError,\n    BoolExpressionMethods, ExpressionMethods, QueryDsl,\n};\nuse error_stack::{report, ResultExt};\nuse strum::IntoEnumIterator;\n\nuse crate::{\n    enums::RoleScope, errors, query::generics, role::*, schema::roles:...",
    "target_snippet": "\n        generics::generic_insert(conn, self).await\n    ",
    "generations": [
      "",
      "",
      ""
    ],
    "best_token_recall": 0.0,
    "best_bleu": 0.0,
    "best_rougeL": 0.0,
    "exact_match_any": 0
  },
  {
    "file": "crates/diesel_models/src/query/role.rs",
    "mask_idx": 1,
    "target_len": 253,
    "prompt_snippet": "use async_bb8_diesel::AsyncRunQueryDsl;\nuse common_enums::EntityType;\nuse common_utils::id_type;\nuse diesel::{\n    associations::HasTable, debug_query, pg::Pg, result::Error as DieselError,\n    BoolExpressionMethods, ExpressionMethods, QueryDsl,\n};\nuse error_stack::{report, ResultExt};\nuse strum::IntoEnumIterator;\n\nuse crate::{\n    enums::RoleScope, errors, query::generics, role::*, schema::roles:...",
    "target_snippet": "\n        is_lineage_data_required\n            .then(|| {\n                EntityType::iter()\n                    .filter(|variant| *variant <= current_entity)\n                    .collect()\n            })\n            .unwrap_or(vec![current_entity])\n    ",
    "generations": [
      "",
      "",
      ""
    ],
    "best_token_recall": 0.0,
    "best_bleu": 0.0,
    "best_rougeL": 0.0,
    "exact_match_any": 0
  },
  {
    "file": "crates/diesel_models/src/query/role.rs",
    "mask_idx": 2,
    "target_len": 168,
    "prompt_snippet": "use async_bb8_diesel::AsyncRunQueryDsl;\nuse common_enums::EntityType;\nuse common_utils::id_type;\nuse diesel::{\n    associations::HasTable, debug_query, pg::Pg, result::Error as DieselError,\n    BoolExpressionMethods, ExpressionMethods, QueryDsl,\n};\nuse error_stack::{report, ResultExt};\nuse strum::IntoEnumIterator;\n\nuse crate::{\n    enums::RoleScope, errors, query::generics, role::*, schema::roles:...",
    "target_snippet": "\n        generics::generic_find_one::<<Self as HasTable>::Table, _, _>(\n            conn,\n            dsl::role_id.eq(role_id.to_owned()),\n        )\n        .await\n    ",
    "generations": [
      "",
      "",
      ""
    ],
    "best_token_recall": 0.0,
    "best_bleu": 0.0,
    "best_rougeL": 0.0,
    "exact_match_any": 0
  },
  {
    "file": "crates/common_utils/src/pii.rs",
    "mask_idx": 0,
    "target_len": 399,
    "prompt_snippet": "//! Personal Identifiable Information protection.\n\nuse std::{convert::AsRef, fmt, ops, str::FromStr};\n\nuse diesel::{\n    backend::Backend,\n    deserialize,\n    deserialize::FromSql,\n    prelude::*,\n    serialize::{Output, ToSql},\n    sql_types, AsExpression,\n};\nuse error_stack::ResultExt;\nuse masking::{ExposeInterface, Secret, Strategy, WithType};\n#[cfg(feature = \"logs\")]\nuse router_env::logger;\nu...",
    "target_snippet": "\n        let val_str: &str = val.as_ref();\n\n        if let Some(val_str) = val_str.get(val_str.len() - 4..) {\n            // masks everything but the last 4 digits\n            write!(f, \"{}{}\", \"*\".repeat(val_str.len() - 4), val_str)\n        } else {\n            #[cfg(feature = \"logs\")]\n            logger::error!(\"Invalid phone number: {val_str}\");\n            WithType::fmt(val, f)\n        }\n    ",
    "generations": [
      "",
      "",
      ""
    ],
    "best_token_recall": 0.0,
    "best_bleu": 0.0,
    "best_rougeL": 0.0,
    "exact_match_any": 0
  },
  {
    "file": "crates/common_utils/src/pii.rs",
    "mask_idx": 1,
    "target_len": 167,
    "prompt_snippet": "//! Personal Identifiable Information protection.\n\nuse std::{convert::AsRef, fmt, ops, str::FromStr};\n\nuse diesel::{\n    backend::Backend,\n    deserialize,\n    deserialize::FromSql,\n    prelude::*,\n    serialize::{Output, ToSql},\n    sql_types, AsExpression,\n};\nuse error_stack::ResultExt;\nuse masking::{ExposeInterface, Secret, Strategy, WithType};\n#[cfg(feature = \"logs\")]\nuse router_env::logger;\nu...",
    "target_snippet": "\n        validate_phone_number(phone_number)?;\n        let secret = Secret::<String, PhoneNumberStrategy>::new(phone_number.to_string());\n        Ok(Self(secret))\n    ",
    "generations": [
      "",
      "",
      ""
    ],
    "best_token_recall": 0.0,
    "best_bleu": 0.0,
    "best_rougeL": 0.0,
    "exact_match_any": 0
  },
  {
    "file": "crates/common_utils/src/pii.rs",
    "mask_idx": 2,
    "target_len": 98,
    "prompt_snippet": "//! Personal Identifiable Information protection.\n\nuse std::{convert::AsRef, fmt, ops, str::FromStr};\n\nuse diesel::{\n    backend::Backend,\n    deserialize,\n    deserialize::FromSql,\n    prelude::*,\n    serialize::{Output, ToSql},\n    sql_types, AsExpression,\n};\nuse error_stack::ResultExt;\nuse masking::{ExposeInterface, Secret, Strategy, WithType};\n#[cfg(feature = \"logs\")]\nuse router_env::logger;\nu...",
    "target_snippet": "\n        Self::from_str(&value).change_context(errors::ParsingError::PhoneNumberParsingError)\n    ",
    "generations": [
      "",
      "",
      ""
    ],
    "best_token_recall": 0.0,
    "best_bleu": 0.0,
    "best_rougeL": 0.0,
    "exact_match_any": 0
  },
  {
    "file": "crates/diesel_models/src/payment_intent.rs",
    "mask_idx": 0,
    "target_len": 382,
    "prompt_snippet": "use common_enums::{PaymentMethodType, RequestIncrementalAuthorization};\nuse common_types::primitive_wrappers::RequestExtendedAuthorizationBool;\nuse common_utils::{encryption::Encryption, pii, types::MinorUnit};\nuse diesel::{AsChangeset, Identifiable, Insertable, Queryable, Selectable};\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\n\n#[cfg(feature = \"v1\")]\nuse crate::schema::paym...",
    "target_snippet": "\n        self.payment_method_type\n            .as_ref()\n            .zip(payment_method)\n            .filter(|(payment_method_type_tax, payment_method)| {\n                payment_method_type_tax.pmt == *payment_method\n            })\n            .map(|(payment_method_type_tax, _)| payment_method_type_tax.order_tax_amount)\n            .or_else(|| self.get_default_tax_amount())\n    ",
    "generations": [
      "",
      "",
      ""
    ],
    "best_token_recall": 0.0,
    "best_bleu": 0.0,
    "best_rougeL": 0.0,
    "exact_match_any": 0
  },
  {
    "file": "crates/diesel_models/src/payment_intent.rs",
    "mask_idx": 1,
    "target_len": 125,
    "prompt_snippet": "use common_enums::{PaymentMethodType, RequestIncrementalAuthorization};\nuse common_types::primitive_wrappers::RequestExtendedAuthorizationBool;\nuse common_utils::{encryption::Encryption, pii, types::MinorUnit};\nuse diesel::{AsChangeset, Identifiable, Insertable, Queryable, Selectable};\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\n\n#[cfg(feature = \"v1\")]\nuse crate::schema::paym...",
    "target_snippet": "\n        self.default\n            .as_ref()\n            .map(|default_tax_details| default_tax_details.order_tax_amount)\n    ",
    "generations": [
      "",
      "",
      ""
    ],
    "best_token_recall": 0.0,
    "best_bleu": 0.0,
    "best_rougeL": 0.0,
    "exact_match_any": 0
  },
  {
    "file": "crates/diesel_models/src/payment_intent.rs",
    "mask_idx": 2,
    "target_len": 4229,
    "prompt_snippet": "use common_enums::{PaymentMethodType, RequestIncrementalAuthorization};\nuse common_types::primitive_wrappers::RequestExtendedAuthorizationBool;\nuse common_utils::{encryption::Encryption, pii, types::MinorUnit};\nuse diesel::{AsChangeset, Identifiable, Insertable, Queryable, Selectable};\nuse serde::{Deserialize, Serialize};\nuse time::PrimitiveDateTime;\n\n#[cfg(feature = \"v1\")]\nuse crate::schema::paym...",
    "target_snippet": "\n        let PaymentIntentUpdateInternal {\n            amount,\n            currency,\n            status,\n            amount_captured,\n            customer_id,\n            return_url,\n            setup_future_usage,\n            off_session,\n            metadata,\n            billing_address_id,\n            shipping_address_id,\n            modified_at: _,\n            active_attempt_id,\n            bu...",
    "generations": [
      "",
      "",
      ""
    ],
    "best_token_recall": 0.0,
    "best_bleu": 0.0,
    "best_rougeL": 0.0,
    "exact_match_any": 0
  },
  {
    "file": "crates/hyperswitch_connectors/src/connectors/nomupay/transformers.rs",
    "mask_idx": 0,
    "target_len": 178,
    "prompt_snippet": "#[cfg(feature = \"payouts\")]\nuse common_enums::enums::PayoutEntityType;\nuse common_enums::{enums, Currency, PayoutStatus};\nuse common_utils::{pii::Email, types::FloatMajorUnit};\nuse hyperswitch_domain_models::router_data::ConnectorAuthType;\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_response_types::PayoutsResponseData, types::PayoutsRouterData,\n};\nuse hyperswitch_interf...",
    "target_snippet": "\n        //Todo :  use utils to convert the amount to the type of amount that a connector accepts\n        Self {\n            amount,\n            router_data: item,\n        }\n    ",
    "generations": [
      "",
      "",
      ""
    ],
    "best_token_recall": 0.0,
    "best_bleu": 0.0,
    "best_rougeL": 0.0,
    "exact_match_any": 0
  },
  {
    "file": "crates/hyperswitch_connectors/src/connectors/nomupay/transformers.rs",
    "mask_idx": 1,
    "target_len": 221,
    "prompt_snippet": "#[cfg(feature = \"payouts\")]\nuse common_enums::enums::PayoutEntityType;\nuse common_enums::{enums, Currency, PayoutStatus};\nuse common_utils::{pii::Email, types::FloatMajorUnit};\nuse hyperswitch_domain_models::router_data::ConnectorAuthType;\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_response_types::PayoutsResponseData, types::PayoutsRouterData,\n};\nuse hyperswitch_interf...",
    "target_snippet": "\n        match entity {\n            PayoutEntityType::Personal\n            | PayoutEntityType::NaturalPerson\n            | PayoutEntityType::Individual => Self::Individual,\n            _ => Self::Businness,\n        }\n    ",
    "generations": [
      "",
      "",
      ""
    ],
    "best_token_recall": 0.0,
    "best_bleu": 0.0,
    "best_rougeL": 0.0,
    "exact_match_any": 0
  },
  {
    "file": "crates/hyperswitch_connectors/src/connectors/nomupay/transformers.rs",
    "mask_idx": 2,
    "target_len": 323,
    "prompt_snippet": "#[cfg(feature = \"payouts\")]\nuse common_enums::enums::PayoutEntityType;\nuse common_enums::{enums, Currency, PayoutStatus};\nuse common_utils::{pii::Email, types::FloatMajorUnit};\nuse hyperswitch_domain_models::router_data::ConnectorAuthType;\n#[cfg(feature = \"payouts\")]\nuse hyperswitch_domain_models::{\n    router_response_types::PayoutsResponseData, types::PayoutsRouterData,\n};\nuse hyperswitch_interf...",
    "target_snippet": "\n        match auth_type {\n            #[cfg(feature = \"payouts\")]\n            ConnectorAuthType::BodyKey { api_key, key1 } => Ok(Self {\n                kid: api_key.to_owned(),\n                eid: key1.to_owned(),\n            }),\n            _ => Err(errors::ConnectorError::FailedToObtainAuthType.into()),\n        }\n    ",
    "generations": [
      "",
      "",
      ""
    ],
    "best_token_recall": 0.0,
    "best_bleu": 0.0,
    "best_rougeL": 0.0,
    "exact_match_any": 0
  },
  {
    "file": "crates/analytics/src/payments/metrics/payment_count.rs",
    "mask_idx": 0,
    "target_len": 3368,
    "prompt_snippet": "use std::collections::HashSet;\n\nuse api_models::analytics::{\n    payments::{PaymentDimensions, PaymentFilters, PaymentMetricsBucketIdentifier},\n    Granularity, TimeRange,\n};\nuse common_utils::errors::ReportSwitchExt;\nuse error_stack::ResultExt;\nuse time::PrimitiveDateTime;\n\nuse super::PaymentMetricRow;\nuse crate::{\n    enums::AuthInfo,\n    query::{Aggregate, GroupByClause, QueryBuilder, QueryFilt...",
    "target_snippet": "\n        let mut query_builder: QueryBuilder<T> = QueryBuilder::new(AnalyticsCollection::Payment);\n\n        for dim in dimensions.iter() {\n            query_builder.add_select_column(dim).switch()?;\n        }\n\n        query_builder\n            .add_select_column(Aggregate::Count {\n                field: None,\n                alias: Some(\"count\"),\n            })\n            .switch()?;\n        quer...",
    "generations": [
      "",
      "",
      ""
    ],
    "best_token_recall": 0.0,
    "best_bleu": 0.0,
    "best_rougeL": 0.0,
    "exact_match_any": 0
  }
]